# 简单明了计算机网络基础知识

**你是一台电脑，你的名字叫 A**

很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/40e02943f3c142369a28c69a0cd20285?aliyun)



直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根**网线**连接了起来。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/12d3ea3666424a9f8650447723eaf7c1.png?aliyun)



用一根网线连接起来怎么就能"通信"了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。

如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在**开枪**吧~

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/d43e8afc30b0486b9f4ae0db60729752?aliyun)



反正，你们就是连起来了，并且可以通信。



**第一层**



有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开**两个网口**，用一共**三根网线**，彼此相连。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/866adcfbe064494fb81465abbc22ad5f.png?aliyun)



随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/36d894392a024a489a0feed14fd1e14c.png?aliyun)



于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/28de0be491294e1dac3002ac7f1a9379.png?aliyun)



你给它取名叫**集线器**，它仅仅是无脑将电信号**转发到所有出口（广播）**，不做任何处理，你觉得它是没有智商的，因此把人家定性在了**物理层**。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/bd4cc3987d78408198e74f04785486f2?aliyun)



由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？

首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，**全局唯一**的名字作为标识，你把这个更高端的名字称为 **MAC 地址**。

你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。

这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/eb857bd65b48499ea9b1ae4bf3a1183a?aliyun)



B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便**收下**。

其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便**丢弃**。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/62c38ba22c664c419567815c1491b205?aliyun)



虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。



**第二层**



如果把这个集线器弄得更智能一些，**只发给目标 MAC 地址指向的那台电脑**，就好了。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/9343e1ac854f4e8589c71b46ee165251?aliyun)



虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做**交换机**。也正因为这一点点智能，你把它放在了另一个层级，**数据链路层**。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/71785b0fb46f40b7b15c55074020b4ee.png?aliyun)



如上图所示，你是这样设计的。

交换机内部维护一张 **MAC 地址表**，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。

MAC 地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc3
aa-aa-aa-aa-aa-aa4
dd-dd-dd-dd-dd-dd5

假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/5236bd1c36bb492390e978b21b24ad9b?aliyun)



到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现**目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上**，于是把数据从 1 号端口发给了 B，完事~

你给这个通过这样传输方式而组成的小范围的网络，叫做**以太网**。

当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？

假如在 MAC 地址表为空是，你给 B 发送了如下数据

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/f1e0e29570d14af1b9f121d92d685e9f.png?aliyun)



由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：

**MAC：aa-aa-aa-aa-aa-aa-aa
端口：4**

交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了**所有端口**，也即发给了所有机器。

之后，只有机器 B 收到了确实是发给自己的包，于是做出了**响应**，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：

**MAC：bb-bb-bb-bb-bb-bb
端口：1**

过程如下

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/1b042b3316124369a18e96b3572b3cf2?aliyun)



经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/a582d62d57cf432a971ad990a2385485?aliyun)



随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/92775375d1c7400593d3a0226d82a831?aliyun)



你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。

但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。

最终，**两个交换机将分别记录 A ~ H 所有机器的映射记录**。

**左边的交换机**

MAC 地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc3
aa-aa-aa-aa-aa-aa4
dd-dd-dd-dd-dd-dd5
ee-ee-ee-ee-ee-ee
6
ff-ff-ff-ff-ff-ff
6gg-gg-gg-gg-gg-gg
6
hh-hh-hh-hh-hh-hh
6

**右边的交换机**

MAC 地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc1
aa-aa-aa-aa-aa-aa1
dd-dd-dd-dd-dd-dd1
ee-ee-ee-ee-ee-ee
2
ff-ff-ff-ff-ff-ff
3gg-gg-gg-gg-gg-gg
4
hh-hh-hh-hh-hh-hh
6

这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。

但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。



**第三层**



交换机已经无法记录如此庞大的映射关系了。

此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。

那我可不可以让那根红色的网线，接入一个**新的设备**，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次**转发**呢？

这个设备就是**路由器，**它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发**，**你把它定在了**网络层。**

![大学要是这样讲述计算机网络我当初怎么也不会挂科啊](https://imgoss.xgss.net/picgo/3e9cca5de0bb406e9297f33877ec2824?aliyun)



注意，路由器的每一个端口，都有独立的 MAC 地址

好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。

那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH.... 的数据包，统统先发送给路由器呢？

不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是

**C 的 MAC 地址：FFFF-FFFF-CCCC**

**D 的 MAC 地址：FFFF-FFFF-DDDD**

那我们就可以说，将目标 MAC 地址为 **FFFF-FFFF-？开头的**，统统先发送给路由器。

这样是否可行呢？答案是否定的。

我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示

**00-16-EA-AE-3C-40**

它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中**前 24 位（00-16-EA）代表网络硬件制造商的编号，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。**只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。

那如果你希望向上面那样表示将目标 MAC 地址为 **FFFF-FFFF-？开头的**，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。

这显然是不现实的。

于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：

**11000000101010000000000000000001**

你觉得有些不清晰，于是把它分成四个部分，中间用点相连。

**11000000.10101000.00000000.00000001**

你还觉得不清晰，于是把它转换成 10 进制。

**192.168.0.1**

最后你给了这个地址一个响亮的名字，**IP 地址**。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是**软件层面**上的，可以随时修改，MAC 地址一般是无法修改的。

这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。